[
  {
    "sample_id": "SOL_AC_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn update_authority(\n        ctx: Context<UpdateAuthority>,\n        new_authority: Pubkey,\n    ) -> Result<()> {\n        let config = &mut ctx.accounts.config;\n        // VULNERABLE: No validation that signer is the current authority\n        // Anyone can call this and change the authority\n        config.authority = new_authority;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UpdateAuthority<'info> {\n    #[account(mut)]\n    pub config: Account<'info, Config>,\n    pub signer: Signer<'info>,\n}\n\n#[account]\npub struct Config {\n    pub authority: Pubkey,\n    pub vault_balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Missing Authority Validation\nSeverity: CRITICAL\nLocation: update_authority function\nDescription: The function modifies config.authority without verifying that ctx.accounts.signer.key() == config.authority. Any signer can change the authority to themselves, gaining full control over the contract.\nExploit Scenario: Attacker calls update_authority(attacker_pubkey) and becomes the new authority.\nRecommendation: Add constraint: #[account(mut, has_one = authority)] or require!(config.authority == signer.key())",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Missing Authority Check"
  },
  {
    "sample_id": "SOL_AC_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn withdraw(\n        ctx: Context<Withdraw>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        let user = &ctx.accounts.user;\n        \n        // VULNERABLE: Only checks signer, not vault ownership\n        // No verification that user.key() == vault.owner\n        require!(vault.balance >= amount, CustomError::InsufficientFunds);\n        \n        vault.balance = vault.balance.checked_sub(amount).unwrap();\n        \n        // Transfer logic would go here\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct Vault {\n    pub owner: Pubkey,\n    pub balance: u64,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Insufficient funds\")]\n    InsufficientFunds,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Missing Owner Validation\nSeverity: CRITICAL\nLocation: withdraw function\nDescription: The function validates that user is a signer but does not verify that user.key() == vault.owner. Any signer can withdraw funds from any vault.\nExploit Scenario: Attacker finds a vault with funds, calls withdraw() specifying that vault, and drains all funds.\nRecommendation: Add constraint: #[account(mut, has_one = owner @ CustomError::Unauthorized)] on vault, where owner points to user",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Missing Owner Check"
  },
  {
    "sample_id": "SOL_AC_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn close_account(\n        ctx: Context<CloseAccount>,\n    ) -> Result<()> {\n        // VULNERABLE: No signer in accounts, no ownership check\n        // Anyone can close any account\n        let account_to_close = &mut ctx.accounts.account_to_close;\n        let recipient = &ctx.accounts.recipient;\n        \n        // Anchor's close constraint should be used instead\n        account_to_close.closed = true;\n        \n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CloseAccount<'info> {\n    #[account(mut)]\n    pub account_to_close: Account<'info, UserAccount>,\n    /// CHECK: Recipient for lamports\n    #[account(mut)]\n    pub recipient: AccountInfo<'info>,\n    // MISSING: No Signer account!\n}\n\n#[account]\npub struct UserAccount {\n    pub owner: Pubkey,\n    pub data: [u8; 32],\n    pub closed: bool,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Missing Signer and Owner Checks\nSeverity: CRITICAL\nLocation: CloseAccount struct and close_account function\nDescription: The instruction has no Signer account defined, meaning anyone can invoke it. Additionally, there's no verification that the caller owns the account being closed.\nExploit Scenario: Attacker calls close_account for any UserAccount, marking it as closed and potentially disrupting the system.\nRecommendation: Add 'pub authority: Signer<'info>' and constraint '#[account(mut, has_one = owner, close = recipient)]'",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Missing Signer + Missing Owner Check"
  },
  {
    "sample_id": "SOL_AC_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn transfer_ownership(\n        ctx: Context<TransferOwnership>,\n        new_owner: Pubkey,\n    ) -> Result<()> {\n        let asset = &mut ctx.accounts.asset;\n        // VULNERABLE: Signer exists but no check that signer == current owner\n        asset.owner = new_owner;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferOwnership<'info> {\n    #[account(mut)]\n    pub asset: Account<'info, Asset>,\n    pub caller: Signer<'info>,\n}\n\n#[account]\npub struct Asset {\n    pub owner: Pubkey,\n    pub value: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Incomplete Permission Validation\nSeverity: CRITICAL\nLocation: transfer_ownership function\nDescription: The function accepts any signer but does not verify that caller.key() == asset.owner. Any signer can transfer ownership of any asset to themselves or others.\nExploit Scenario: Attacker calls transfer_ownership(attacker_pubkey) on a valuable asset they don't own.\nRecommendation: Add require!(asset.owner == caller.key(), CustomError::Unauthorized) or use has_one constraint",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Signer Without Owner Verification"
  },
  {
    "sample_id": "SOL_AC_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, MintTo, Mint};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn mint_tokens(\n        ctx: Context<MintTokens>,\n        amount: u64,\n    ) -> Result<()> {\n        // VULNERABLE: No verification that authority == mint.mint_authority\n        let cpi_accounts = MintTo {\n            mint: ctx.accounts.mint.to_account_info(),\n            to: ctx.accounts.token_account.to_account_info(),\n            authority: ctx.accounts.authority.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::mint_to(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct MintTokens<'info> {\n    #[account(mut)]\n    pub mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub token_account: Account<'info, TokenAccount>,\n    pub authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - CPI Authority Mismatch\nSeverity: CRITICAL\nLocation: mint_tokens function\nDescription: While SPL Token program will reject unauthorized mints, this code pattern is dangerous because it doesn't explicitly validate that authority.key() matches the mint's mint_authority. If the mint_authority is a PDA controlled by this program, any signer could potentially mint tokens.\nExploit Scenario: If mint_authority is misconfigured or is a program-controlled PDA without proper seeds validation, unauthorized minting could occur.\nRecommendation: Add explicit check: require!(ctx.accounts.mint.mint_authority.unwrap() == ctx.accounts.authority.key())",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Missing Mint Authority Validation"
  },
  {
    "sample_id": "SOL_AC_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\nuse anchor_lang::solana_program::instruction::{Instruction, AccountMeta};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn execute_cpi(\n        ctx: Context<ExecuteCpi>,\n        instruction_data: Vec<u8>,\n    ) -> Result<()> {\n        // VULNERABLE: No validation of target_program identity\n        // Attacker can pass any program and execute arbitrary instructions\n        let instruction = Instruction {\n            program_id: ctx.accounts.target_program.key(),\n            accounts: vec![\n                AccountMeta::new(ctx.accounts.user_account.key(), false),\n            ],\n            data: instruction_data,\n        };\n        invoke(\n            &instruction,\n            &[\n                ctx.accounts.target_program.to_account_info(),\n                ctx.accounts.user_account.to_account_info(),\n            ],\n        )?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteCpi<'info> {\n    /// CHECK: Target program - DANGEROUS: not validated!\n    pub target_program: AccountInfo<'info>,\n    /// CHECK: User account for CPI\n    #[account(mut)]\n    pub user_account: AccountInfo<'info>,\n    pub invoker: Signer<'info>,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Untrusted CPI Target\nSeverity: CRITICAL\nLocation: execute_cpi function, target_program account\nDescription: The function performs Cross-Program Invocation to any program address passed by the caller. There's no whitelist or validation of the target program identity. This allows attackers to redirect calls to malicious programs.\nExploit Scenario: Attacker passes a malicious program that steals funds or corrupts state when invoked.\nRecommendation: Whitelist trusted program IDs: require!(target_program.key() == TRUSTED_PROGRAM_ID, CustomError::InvalidProgram)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Untrusted CPI Target"
  },
  {
    "sample_id": "SOL_AC_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn unlock_treasury(\n        ctx: Context<UnlockTreasury>,\n    ) -> Result<()> {\n        let treasury = &mut ctx.accounts.treasury;\n        // VULNERABLE: No validation whatsoever\n        // requester is not even a Signer!\n        treasury.locked = false;\n        treasury.last_unlock_time = Clock::get()?.unix_timestamp;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UnlockTreasury<'info> {\n    #[account(mut)]\n    pub treasury: Account<'info, Treasury>,\n    /// CHECK: No signer constraint - anyone can unlock!\n    pub requester: AccountInfo<'info>,\n}\n\n#[account]\npub struct Treasury {\n    pub locked: bool,\n    pub last_unlock_time: i64,\n    pub admin: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Complete Missing Validation\nSeverity: CRITICAL\nLocation: UnlockTreasury struct\nDescription: The requester account is AccountInfo without Signer constraint. Anyone can call this instruction. Additionally, there's no check that requester == treasury.admin even if it were a signer.\nExploit Scenario: Any user can unlock any treasury without authorization, potentially enabling unauthorized fund withdrawals.\nRecommendation: Change to 'pub requester: Signer<'info>' and add constraint '#[account(mut, has_one = admin)]' where admin = requester",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "No Signer + No Admin Check"
  },
  {
    "sample_id": "SOL_AC_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn burn_tokens(\n        ctx: Context<BurnTokens>,\n        amount: u64,\n    ) -> Result<()> {\n        let token_account = &mut ctx.accounts.token_account;\n        // VULNERABLE: Checks signer but not account ownership\n        require!(\n            token_account.amount >= amount,\n            CustomError::InsufficientBalance\n        );\n        token_account.amount = token_account.amount.checked_sub(amount).unwrap();\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BurnTokens<'info> {\n    #[account(mut)]\n    pub token_account: Account<'info, TokenAccount>,\n    pub caller: Signer<'info>,\n}\n\n#[account]\npub struct TokenAccount {\n    pub amount: u64,\n    pub owner: Pubkey,\n    pub mint: Pubkey,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Insufficient balance\")]\n    InsufficientBalance,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Account Ownership Not Validated\nSeverity: CRITICAL\nLocation: burn_tokens function\nDescription: The function verifies the caller is a signer but does not check that caller.key() == token_account.owner. Any signer can burn tokens from any account.\nExploit Scenario: Attacker burns tokens from victim's account, destroying their holdings.\nRecommendation: Add require!(token_account.owner == caller.key(), CustomError::Unauthorized) or use has_one constraint",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Missing Token Account Owner Check"
  },
  {
    "sample_id": "SOL_AC_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn freeze_account(\n        ctx: Context<FreezeAccount>,\n    ) -> Result<()> {\n        let account_to_freeze = &mut ctx.accounts.account_to_freeze;\n        // VULNERABLE: No validation that authority is the freeze_authority\n        account_to_freeze.frozen = true;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct FreezeAccount<'info> {\n    #[account(mut)]\n    pub account_to_freeze: Account<'info, FreezableAccount>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct FreezableAccount {\n    pub frozen: bool,\n    pub freeze_authority: Pubkey,\n    pub owner: Pubkey,\n    pub data: [u8; 64],\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Authority Identity Mismatch\nSeverity: CRITICAL\nLocation: freeze_account function\nDescription: The function accepts any signer but doesn't verify authority.key() == account_to_freeze.freeze_authority. Any signer can freeze any account, causing denial of service.\nExploit Scenario: Attacker freezes all user accounts, preventing legitimate users from accessing their funds.\nRecommendation: Add require!(authority.key() == account_to_freeze.freeze_authority) or #[account(mut, has_one = freeze_authority)]",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Freeze Authority Mismatch"
  },
  {
    "sample_id": "SOL_AC_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod vulnerable_contract {\n    use super::*;\n\n    pub fn revoke_role(\n        ctx: Context<RevokeRole>,\n        role_id: u8,\n    ) -> Result<()> {\n        let target = &mut ctx.accounts.target;\n        // VULNERABLE: Only checks signer, not admin identity\n        // No check: admin.key() != access_control.admin\n        require!(role_id < 8, CustomError::InvalidRole);\n        target.roles &= !(1 << role_id);\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct RevokeRole<'info> {\n    pub access_control: Account<'info, AccessControl>,\n    #[account(mut)]\n    pub target: Account<'info, RoleHolder>,\n    pub admin: Signer<'info>,\n}\n\n#[account]\npub struct AccessControl {\n    pub admin: Pubkey,\n    pub paused: bool,\n}\n\n#[account]\npub struct RoleHolder {\n    pub roles: u8,\n    pub holder: Pubkey,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Invalid role ID\")]\n    InvalidRole,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Access Control - Role Validation Missing\nSeverity: CRITICAL\nLocation: revoke_role function\nDescription: The function verifies a signer exists but doesn't check admin.key() == access_control.admin. Any signer can revoke roles from any user, breaking the access control system.\nExploit Scenario: Attacker revokes admin roles from legitimate admins, taking over governance.\nRecommendation: Add require!(admin.key() == access_control.admin) or #[account(has_one = admin)]",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Missing Admin Role Check"
  }
]
[
  {
    "sample_id": "SOL_AC_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn update_authority(\n        ctx: Context<UpdateAuthority>,\n        new_authority: Pubkey,\n    ) -> Result<()> {\n        let config = &mut ctx.accounts.config;\n        // SECURE: has_one constraint ensures current_authority == config.authority\n        config.authority = new_authority;\n        emit!(AuthorityChanged {\n            old_authority: ctx.accounts.current_authority.key(),\n            new_authority,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UpdateAuthority<'info> {\n    #[account(\n        mut,\n        has_one = authority @ CustomError::Unauthorized\n    )]\n    pub config: Account<'info, Config>,\n    #[account(constraint = authority.key() == config.authority)]\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct Config {\n    pub authority: Pubkey,\n    pub vault_balance: u64,\n}\n\n#[event]\npub struct AuthorityChanged {\n    pub old_authority: Pubkey,\n    pub new_authority: Pubkey,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The update_authority function uses Anchor's has_one constraint to verify that the signer (authority) matches config.authority. Only the current authority can update to a new authority. The Signer type ensures the caller signed the transaction.\nSecurity Controls: has_one constraint + Signer type\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "has_one Constraint"
  },
  {
    "sample_id": "SOL_AC_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn withdraw(\n        ctx: Context<Withdraw>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &mut ctx.accounts.vault;\n        // SECURE: has_one ensures owner == user.key()\n        require!(vault.balance >= amount, CustomError::InsufficientFunds);\n        vault.balance = vault.balance.checked_sub(amount).ok_or(CustomError::Overflow)?;\n        \n        // Transfer SOL from vault PDA to user\n        let seeds = &[b\"vault\", vault.owner.as_ref(), &[ctx.bumps.vault]];\n        let signer_seeds = &[&seeds[..]];\n        \n        let transfer_ctx = CpiContext::new_with_signer(\n            ctx.accounts.system_program.to_account_info(),\n            anchor_lang::system_program::Transfer {\n                from: ctx.accounts.vault_pda.to_account_info(),\n                to: ctx.accounts.user.to_account_info(),\n            },\n            signer_seeds,\n        );\n        anchor_lang::system_program::transfer(transfer_ctx, amount)?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct Withdraw<'info> {\n    #[account(\n        mut,\n        has_one = owner @ CustomError::Unauthorized,\n        seeds = [b\"vault\", owner.key().as_ref()],\n        bump\n    )]\n    pub vault: Account<'info, Vault>,\n    /// CHECK: PDA for holding SOL\n    #[account(mut, seeds = [b\"vault\", owner.key().as_ref()], bump)]\n    pub vault_pda: AccountInfo<'info>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n    pub owner: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct Vault {\n    pub owner: Pubkey,\n    pub balance: u64,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n    #[msg(\"Insufficient funds\")]\n    InsufficientFunds,\n    #[msg(\"Arithmetic overflow\")]\n    Overflow,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The withdraw function properly validates ownership through has_one constraint ensuring vault.owner == owner.key(). The vault PDA is derived using seeds that include the owner's key, making it owner-specific. Only the vault owner can withdraw funds.\nSecurity Controls: has_one constraint + PDA seeds validation + Signer type\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "has_one + PDA Seeds"
  },
  {
    "sample_id": "SOL_AC_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn close_account(\n        ctx: Context<CloseAccount>,\n    ) -> Result<()> {\n        // SECURE: Anchor's close constraint handles lamport transfer\n        // has_one ensures only owner can close\n        emit!(AccountClosed {\n            account: ctx.accounts.account_to_close.key(),\n            owner: ctx.accounts.owner.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CloseAccount<'info> {\n    #[account(\n        mut,\n        has_one = owner @ CustomError::Unauthorized,\n        close = owner\n    )]\n    pub account_to_close: Account<'info, UserAccount>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n}\n\n#[account]\npub struct UserAccount {\n    pub owner: Pubkey,\n    pub data: [u8; 32],\n}\n\n#[event]\npub struct AccountClosed {\n    pub account: Pubkey,\n    pub owner: Pubkey,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The close_account function uses Anchor's close constraint which safely transfers all lamports to the specified account and zeros the data. The has_one constraint ensures only the account owner can close it. The owner must be a Signer.\nSecurity Controls: close constraint + has_one constraint + Signer type\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "close + has_one Constraints"
  },
  {
    "sample_id": "SOL_AC_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn transfer_ownership(\n        ctx: Context<TransferOwnership>,\n        new_owner: Pubkey,\n    ) -> Result<()> {\n        let asset = &mut ctx.accounts.asset;\n        // SECURE: require! validates caller == current owner\n        require!(\n            asset.owner == ctx.accounts.caller.key(),\n            CustomError::Unauthorized\n        );\n        \n        let old_owner = asset.owner;\n        asset.owner = new_owner;\n        \n        emit!(OwnershipTransferred {\n            asset: ctx.accounts.asset.key(),\n            old_owner,\n            new_owner,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferOwnership<'info> {\n    #[account(mut)]\n    pub asset: Account<'info, Asset>,\n    pub caller: Signer<'info>,\n}\n\n#[account]\npub struct Asset {\n    pub owner: Pubkey,\n    pub value: u64,\n}\n\n#[event]\npub struct OwnershipTransferred {\n    pub asset: Pubkey,\n    pub old_owner: Pubkey,\n    pub new_owner: Pubkey,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The transfer_ownership function explicitly validates that the signer (caller) is the current owner using require! macro. Only the current asset owner can transfer ownership. The Signer type ensures the caller signed the transaction.\nSecurity Controls: require! validation + Signer type\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Explicit require! Check"
  },
  {
    "sample_id": "SOL_AC_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_spl::token::{self, Token, TokenAccount, MintTo, Mint};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn mint_tokens(\n        ctx: Context<MintTokens>,\n        amount: u64,\n    ) -> Result<()> {\n        // SECURE: Constraint validates authority == mint.mint_authority\n        let cpi_accounts = MintTo {\n            mint: ctx.accounts.mint.to_account_info(),\n            to: ctx.accounts.token_account.to_account_info(),\n            authority: ctx.accounts.mint_authority.to_account_info(),\n        };\n        let cpi_program = ctx.accounts.token_program.to_account_info();\n        let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);\n        token::mint_to(cpi_ctx, amount)?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct MintTokens<'info> {\n    #[account(\n        mut,\n        constraint = mint.mint_authority.unwrap() == mint_authority.key() @ CustomError::InvalidAuthority\n    )]\n    pub mint: Account<'info, Mint>,\n    #[account(mut)]\n    pub token_account: Account<'info, TokenAccount>,\n    pub mint_authority: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Invalid mint authority\")]\n    InvalidAuthority,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The mint_tokens function validates that the signer (mint_authority) matches the mint's mint_authority using a constraint. This prevents unauthorized minting. The SPL Token program will also reject the CPI if authorities don't match, providing defense in depth.\nSecurity Controls: constraint validation + Signer type + SPL Token authority check\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Mint Authority Constraint"
  },
  {
    "sample_id": "SOL_AC_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\nuse anchor_lang::solana_program::instruction::{Instruction, AccountMeta};\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n// Whitelisted program IDs\nconst TRUSTED_PROGRAM_A: Pubkey = solana_program::pubkey!(\"11111111111111111111111111111111\");\nconst TRUSTED_PROGRAM_B: Pubkey = solana_program::pubkey!(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn execute_cpi(\n        ctx: Context<ExecuteCpi>,\n        instruction_data: Vec<u8>,\n    ) -> Result<()> {\n        let target = ctx.accounts.target_program.key();\n        \n        // SECURE: Whitelist check for trusted programs only\n        require!(\n            target == TRUSTED_PROGRAM_A || target == TRUSTED_PROGRAM_B,\n            CustomError::UntrustedProgram\n        );\n        \n        let instruction = Instruction {\n            program_id: target,\n            accounts: vec![\n                AccountMeta::new(ctx.accounts.user_account.key(), false),\n            ],\n            data: instruction_data,\n        };\n        invoke(\n            &instruction,\n            &[\n                ctx.accounts.target_program.to_account_info(),\n                ctx.accounts.user_account.to_account_info(),\n            ],\n        )?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteCpi<'info> {\n    /// CHECK: Validated against whitelist in instruction\n    pub target_program: AccountInfo<'info>,\n    /// CHECK: User account for CPI\n    #[account(mut)]\n    pub user_account: AccountInfo<'info>,\n    pub invoker: Signer<'info>,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Untrusted program\")]\n    UntrustedProgram,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The execute_cpi function validates the target program against a whitelist of trusted program IDs before performing CPI. Only calls to pre-approved programs (System Program and Token Program in this case) are allowed.\nSecurity Controls: Whitelist validation + require! check + Signer type\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "CPI Whitelist Validation"
  },
  {
    "sample_id": "SOL_AC_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn unlock_treasury(\n        ctx: Context<UnlockTreasury>,\n    ) -> Result<()> {\n        let treasury = &mut ctx.accounts.treasury;\n        // SECURE: has_one ensures admin == treasury.admin\n        treasury.locked = false;\n        treasury.last_unlock_time = Clock::get()?.unix_timestamp;\n        \n        emit!(TreasuryUnlocked {\n            treasury: ctx.accounts.treasury.key(),\n            admin: ctx.accounts.admin.key(),\n            timestamp: treasury.last_unlock_time,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UnlockTreasury<'info> {\n    #[account(\n        mut,\n        has_one = admin @ CustomError::Unauthorized\n    )]\n    pub treasury: Account<'info, Treasury>,\n    pub admin: Signer<'info>,\n}\n\n#[account]\npub struct Treasury {\n    pub locked: bool,\n    pub last_unlock_time: i64,\n    pub admin: Pubkey,\n    pub balance: u64,\n}\n\n#[event]\npub struct TreasuryUnlocked {\n    pub treasury: Pubkey,\n    pub admin: Pubkey,\n    pub timestamp: i64,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The unlock_treasury function uses has_one constraint to ensure the signer (admin) matches treasury.admin. Only the designated admin can unlock the treasury. The Signer type guarantees the admin signed the transaction.\nSecurity Controls: has_one constraint + Signer type\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Admin has_one Constraint"
  },
  {
    "sample_id": "SOL_AC_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn burn_tokens(\n        ctx: Context<BurnTokens>,\n        amount: u64,\n    ) -> Result<()> {\n        let token_account = &mut ctx.accounts.token_account;\n        // SECURE: has_one ensures owner == caller\n        require!(\n            token_account.amount >= amount,\n            CustomError::InsufficientBalance\n        );\n        token_account.amount = token_account\n            .amount\n            .checked_sub(amount)\n            .ok_or(CustomError::Overflow)?;\n        \n        emit!(TokensBurned {\n            account: ctx.accounts.token_account.key(),\n            owner: ctx.accounts.owner.key(),\n            amount,\n            remaining: token_account.amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BurnTokens<'info> {\n    #[account(\n        mut,\n        has_one = owner @ CustomError::Unauthorized\n    )]\n    pub token_account: Account<'info, TokenAccount>,\n    pub owner: Signer<'info>,\n}\n\n#[account]\npub struct TokenAccount {\n    pub amount: u64,\n    pub owner: Pubkey,\n    pub mint: Pubkey,\n}\n\n#[event]\npub struct TokensBurned {\n    pub account: Pubkey,\n    pub owner: Pubkey,\n    pub amount: u64,\n    pub remaining: u64,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n    #[msg(\"Insufficient balance\")]\n    InsufficientBalance,\n    #[msg(\"Arithmetic overflow\")]\n    Overflow,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The burn_tokens function validates token account ownership using has_one constraint (owner == token_account.owner). Uses checked_sub for safe arithmetic. Only the token owner can burn their tokens.\nSecurity Controls: has_one constraint + Signer type + checked arithmetic\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Owner has_one + Safe Math"
  },
  {
    "sample_id": "SOL_AC_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn freeze_account(\n        ctx: Context<FreezeAccount>,\n    ) -> Result<()> {\n        let account_to_freeze = &mut ctx.accounts.account_to_freeze;\n        // SECURE: has_one validates freeze_authority\n        require!(!account_to_freeze.frozen, CustomError::AlreadyFrozen);\n        \n        account_to_freeze.frozen = true;\n        \n        emit!(AccountFrozen {\n            account: ctx.accounts.account_to_freeze.key(),\n            authority: ctx.accounts.freeze_authority.key(),\n            timestamp: Clock::get()?.unix_timestamp,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct FreezeAccount<'info> {\n    #[account(\n        mut,\n        has_one = freeze_authority @ CustomError::Unauthorized\n    )]\n    pub account_to_freeze: Account<'info, FreezableAccount>,\n    pub freeze_authority: Signer<'info>,\n}\n\n#[account]\npub struct FreezableAccount {\n    pub frozen: bool,\n    pub freeze_authority: Pubkey,\n    pub owner: Pubkey,\n    pub data: [u8; 64],\n}\n\n#[event]\npub struct AccountFrozen {\n    pub account: Pubkey,\n    pub authority: Pubkey,\n    pub timestamp: i64,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n    #[msg(\"Account already frozen\")]\n    AlreadyFrozen,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The freeze_account function validates that the signer is the designated freeze_authority using has_one constraint. Includes additional check to prevent double-freezing. Only the freeze authority can freeze accounts.\nSecurity Controls: has_one constraint + Signer type + state validation\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Freeze Authority has_one"
  },
  {
    "sample_id": "SOL_AC_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for access control vulnerabilities. Identify if the code properly validates account ownership, signer status, and authority permissions before executing state-modifying operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS\");\n\n#[program]\npub mod secure_contract {\n    use super::*;\n\n    pub fn revoke_role(\n        ctx: Context<RevokeRole>,\n        role_id: u8,\n    ) -> Result<()> {\n        let target = &mut ctx.accounts.target;\n        // SECURE: has_one validates admin == access_control.admin\n        require!(role_id < 8, CustomError::InvalidRole);\n        require!(\n            (target.roles & (1 << role_id)) != 0,\n            CustomError::RoleNotAssigned\n        );\n        \n        target.roles &= !(1 << role_id);\n        \n        emit!(RoleRevoked {\n            target: ctx.accounts.target.key(),\n            role_id,\n            admin: ctx.accounts.admin.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct RevokeRole<'info> {\n    #[account(has_one = admin @ CustomError::Unauthorized)]\n    pub access_control: Account<'info, AccessControl>,\n    #[account(mut)]\n    pub target: Account<'info, RoleHolder>,\n    pub admin: Signer<'info>,\n}\n\n#[account]\npub struct AccessControl {\n    pub admin: Pubkey,\n    pub paused: bool,\n}\n\n#[account]\npub struct RoleHolder {\n    pub roles: u8,\n    pub holder: Pubkey,\n}\n\n#[event]\npub struct RoleRevoked {\n    pub target: Pubkey,\n    pub role_id: u8,\n    pub admin: Pubkey,\n}\n\n#[error_code]\npub enum CustomError {\n    #[msg(\"Unauthorized\")]\n    Unauthorized,\n    #[msg(\"Invalid role ID\")]\n    InvalidRole,\n    #[msg(\"Role not assigned\")]\n    RoleNotAssigned,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A\nDescription: The revoke_role function validates admin identity using has_one constraint on access_control (admin == access_control.admin). Includes validation for role_id bounds and role existence. Only the designated admin can revoke roles.\nSecurity Controls: has_one constraint + Signer type + input validation\nRisk Level: LOW",
    "meta_platform": "Solana",
    "meta_vuln_type": "V1 - Access Control",
    "meta_pattern": "Admin has_one + Role Validation"
  }
]
