[
  {
    "sample_id": "SOL_V5_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates and handles external program calls, account permissions, and CPI results. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn transfer_tokens_external(\n        ctx: Context<TransferTokensExternal>,\n        amount: u64,\n    ) -> Result<()> {\n        let from_account = &ctx.accounts.from_account;\n        let to_account = &ctx.accounts.to_account;\n        // VULNERABLE: Calling external program without verifying its ID\n        // Attacker could pass a malicious program that steals tokens\n        let instruction = spl_token::instruction::transfer(\n            &ctx.accounts.token_program.key(),\n            &from_account.key(),\n            &to_account.key(),\n            &ctx.accounts.authority.key(),\n            &[],\n            amount,\n        )?;\n        invoke(\n            &instruction,\n            &[from_account.clone(), to_account.clone()],\n        )?;\n        emit!(TokensTransferred {\n            from: from_account.key(),\n            to: to_account.key(),\n            amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferTokensExternal<'info> {\n    pub from_account: AccountInfo<'info>,\n    pub to_account: AccountInfo<'info>,\n    pub token_program: AccountInfo<'info>,\n    pub authority: Signer<'info>,\n}\n\n#[event]\npub struct TokensTransferred {\n    pub from: Pubkey,\n    pub to: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - Missing Program ID Validation\nDescription: The contract invokes an external program (Token Program) without verifying its ID. An attacker can pass a malicious program in place of the legitimate Token Program, causing unauthorized token transfers or data theft.\nRisk Level: CRITICAL\nRecommendation: Verify program ID before CPI: require!(ctx.accounts.token_program.key() == &spl_token::ID, ProgramError::IncorrectProgramId)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Program ID Validation in CPI"
  },
  {
    "sample_id": "SOL_V5_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates account signatures and authorities in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn execute_protected_action(\n        ctx: Context<ExecuteProtectedAction>,\n    ) -> Result<()> {\n        let authority = &ctx.accounts.authority;\n        let action_account = &ctx.accounts.action_account;\n        // VULNERABLE: Authority not verified to be a signer of the action_account\n        // Attacker could provide any signer, bypassing authorization\n        let instruction = system_program::create_account(\n            &ctx.accounts.payer.to_account_info(),\n            &action_account.to_account_info(),\n            1000000,\n            0,\n            &authority.key(),\n        );\n        invoke(\n            &instruction,\n            &[ctx.accounts.payer.to_account_info(), action_account.clone()],\n        )?;\n        emit!(ProtectedActionExecuted {\n            authority: authority.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteProtectedAction<'info> {\n    pub authority: AccountInfo<'info>,\n    pub action_account: AccountInfo<'info>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n}\n\n#[event]\npub struct ProtectedActionExecuted {\n    pub authority: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - Missing Signer Validation\nDescription: The contract invokes a system program instruction without verifying that the authority is a valid signer. An attacker can pass an unauthorized signer, bypassing access control checks.\nRisk Level: CRITICAL\nRecommendation: Verify authority is a valid signer: require!(authority.is_signer, ProgramError::MissingRequiredSignature)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Signer Validation in CPI"
  },
  {
    "sample_id": "SOL_V5_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly handles CPI return values and error propagation. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn deposit_with_external_lock(\n        ctx: Context<DepositWithExternalLock>,\n        amount: u64,\n    ) -> Result<()> {\n        let lock_account = &ctx.accounts.lock_account;\n        // VULNERABLE: CPI result is not checked or handled\n        // If CPI fails, state update still occurs, causing inconsistency\n        let _ = invoke(\n            &build_lock_instruction(),\n            &[lock_account.clone()],\n        );\n        // State update happens regardless of CPI success/failure\n        let mut state_data = ctx.accounts.state.try_borrow_mut_data()?;\n        let state = ProgramState::try_from_slice_mut(&mut state_data)?;\n        state.total_deposits += amount;\n        emit!(DepositRecorded {\n            amount,\n            total: state.total_deposits,\n        });\n        Ok(())\n    }\n}\n\nfn build_lock_instruction() -> Instruction {\n    Instruction {\n        program_id: Pubkey::default(),\n        accounts: vec![],\n        data: vec![],\n    }\n}\n\n#[derive(Accounts)]\npub struct DepositWithExternalLock<'info> {\n    pub lock_account: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n}\n\n#[account]\npub struct ProgramState {\n    pub total_deposits: u64,\n}\n\n#[event]\npub struct DepositRecorded {\n    pub amount: u64,\n    pub total: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - CPI Result Not Checked\nDescription: The contract executes a CPI and ignores the result using `let _ = ...`. If the external call fails, the program continues and updates state, creating an inconsistent state where deposits are recorded but locks are not applied.\nRisk Level: CRITICAL\nRecommendation: Propagate CPI result: invoke(...)?; to ensure state updates only occur upon successful CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Unchecked CPI Result Handling"
  },
  {
    "sample_id": "SOL_V5_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates account ownership in CPI contexts. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn modify_shared_state(\n        ctx: Context<ModifySharedState>,\n    ) -> Result<()> {\n        let external_program = &ctx.accounts.external_program;\n        let shared_state = &ctx.accounts.shared_state;\n        // VULNERABLE: Passing writable shared state to unverified external program\n        // External program could modify shared_state in unexpected ways\n        let instruction = Instruction {\n            program_id: external_program.key(),\n            accounts: vec![\n                AccountMeta::new(shared_state.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(\n            &instruction,\n            &[external_program.clone(), shared_state.clone()],\n        )?;\n        // State might have been corrupted by external program\n        let state_data = shared_state.try_borrow_data()?;\n        let state = SharedState::try_from_slice(&state_data)?;\n        require!(state.is_valid(), ProgramError::InvalidAccountData);\n        emit!(StateModified {\n            by: external_program.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ModifySharedState<'info> {\n    pub external_program: AccountInfo<'info>,\n    #[account(mut)]\n    pub shared_state: AccountInfo<'info>,\n}\n\n#[account]\npub struct SharedState {\n    pub value: u64,\n    pub timestamp: u64,\n}\n\nimpl SharedState {\n    fn is_valid(&self) -> bool {\n        self.value > 0\n    }\n}\n\n#[event]\npub struct StateModified {\n    pub by: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - No Validation of External Program\nDescription: The contract passes a writable shared state account to an unverified external program via CPI. The external program can arbitrarily modify the shared state, bypassing internal logic and causing state corruption.\nRisk Level: CRITICAL\nRecommendation: Verify external program ownership and whitelist trusted programs: require!(external_program.owner == &expected_owner, ProgramError::IncorrectProgramId)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Unverified External Program State Access"
  },
  {
    "sample_id": "SOL_V5_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates write permissions in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn withdraw_and_notify(\n        ctx: Context<WithdrawAndNotify>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        let notifier = &ctx.accounts.notifier;\n        // VULNERABLE: Granting write access to notifier without validation\n        // Notifier could modify vault balance directly\n        let notification_instruction = Instruction {\n            program_id: notifier.key(),\n            accounts: vec![\n                AccountMeta::new(vault.key(), false),  // WRONG: Vault is writable!\n            ],\n            data: vec![],\n        };\n        invoke(\n            &notification_instruction,\n            &[notifier.clone(), vault.clone()],\n        )?;\n        // Update vault balance after external call\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        vault_state.balance -= amount;\n        emit!(WithdrawalProcessed {\n            amount,\n            new_balance: vault_state.balance,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawAndNotify<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n    pub notifier: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub balance: u64,\n}\n\n#[event]\npub struct WithdrawalProcessed {\n    pub amount: u64,\n    pub new_balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - Excessive Write Permissions in CPI\nDescription: The contract grants write access to the vault account to an external program via CPI. The external program can modify the vault balance directly, bypassing withdrawal controls and logic.\nRisk Level: CRITICAL\nRecommendation: Pass read-only accounts when possible: AccountMeta::new_readonly(vault.key(), false) when the external program only needs to read",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Over-Permissive Write Access in CPI"
  },
  {
    "sample_id": "SOL_V5_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates rent-exemption and account state before CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn sync_external_state(\n        ctx: Context<SyncExternalState>,\n    ) -> Result<()> {\n        let external_account = &ctx.accounts.external_account;\n        // VULNERABLE: No check for rent exemption before CPI\n        // Account could be deleted/reclaimed after CPI call\n        let sync_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(\n            &sync_instruction,\n            &[external_account.clone()],\n        )?;\n        // After CPI, account might no longer exist or be modified\n        let account_data = external_account.try_borrow_data()?;\n        let state = ExternalState::try_from_slice(&account_data)?;\n        require!(\n            state.last_sync > 0,\n            ProgramError::InvalidAccountData\n        );\n        emit!(Statesynced {\n            account: external_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SyncExternalState<'info> {\n    pub external_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct ExternalState {\n    pub last_sync: u64,\n}\n\n#[event]\npub struct Statesynced {\n    pub account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - No Rent Exemption Validation Before CPI\nDescription: The contract invokes a CPI on an account without verifying its rent exemption status. After the CPI, the account could be closed or reclaimed, causing the subsequent data access to fail or read corrupted data.\nRisk Level: HIGH\nRecommendation: Check rent exemption before CPI: require!(Rent::get()?.is_exempt(external_account.lamports(), external_account.data_len()), ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Rent Exemption Validation Before CPI"
  },
  {
    "sample_id": "SOL_V5_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates data consistency after CPI execution. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn batch_transfer_with_hook(\n        ctx: Context<BatchTransferWithHook>,\n        amount: u64,\n    ) -> Result<()> {\n        let recipient = &ctx.accounts.recipient;\n        let hook_program = &ctx.accounts.hook_program;\n        // VULNERABLE: No validation of recipient state before/after hook\n        // Hook could modify recipient in unexpected ways\n        let hook_instruction = Instruction {\n            program_id: hook_program.key(),\n            accounts: vec![\n                AccountMeta::new(recipient.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(\n            &hook_instruction,\n            &[hook_program.clone(), recipient.clone()],\n        )?;\n        // Assume recipient is in valid state, but hook could have corrupted it\n        let recipient_data = recipient.try_borrow_data()?;\n        let recipient_state = RecipientState::try_from_slice(&recipient_data)?;\n        // Blindly transfer without checking if recipient state is still valid\n        emit!(TransferCompleted {\n            recipient: recipient.key(),\n            amount,\n            final_balance: recipient_state.balance + amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BatchTransferWithHook<'info> {\n    pub recipient: AccountInfo<'info>,\n    pub hook_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct RecipientState {\n    pub is_active: bool,\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferCompleted {\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub final_balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - No State Validation After CPI\nDescription: The contract invokes a hook program that modifies recipient state, then assumes the state is still valid. The hook could corrupt the recipient state, bypass checks, or create invariant violations that aren't caught.\nRisk Level: HIGH\nRecommendation: Validate state consistency before and after CPI: require!(recipient_state.is_active, ...) after CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing State Validation After CPI"
  },
  {
    "sample_id": "SOL_V5_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates signer authority in multi-signature scenarios. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn execute_multisig_action(\n        ctx: Context<ExecuteMultisigAction>,\n    ) -> Result<()> {\n        let signer1 = &ctx.accounts.signer1;\n        let signer2 = &ctx.accounts.signer2;\n        let multisig_program = &ctx.accounts.multisig_program;\n        // VULNERABLE: Signers not validated to be required signers of multisig_program\n        // Attacker could pass unauthorized signers\n        let instruction = Instruction {\n            program_id: multisig_program.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(signer1.key(), true),  // Marked as signer but not validated\n                AccountMeta::new_readonly(signer2.key(), true),  // Marked as signer but not validated\n            ],\n            data: vec![1], // Action ID\n        };\n        invoke(\n            &instruction,\n            &[signer1.clone(), signer2.clone(), multisig_program.clone()],\n        )?;\n        emit!(MultisigActionExecuted {\n            signers: vec![signer1.key(), signer2.key()],\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteMultisigAction<'info> {\n    pub signer1: Signer<'info>,\n    pub signer2: Signer<'info>,\n    pub multisig_program: AccountInfo<'info>,\n}\n\n#[event]\npub struct MultisigActionExecuted {\n    pub signers: Vec<Pubkey>,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - No Signer Authority Validation in Multi-Signature CPI\nDescription: The contract marks accounts as signers in the CPI instruction without validating they are authorized signers for the target program. An attacker can pass unrelated signers, bypassing multi-signature requirements.\nRisk Level: CRITICAL\nRecommendation: Verify signer authority: Ensure signers match expected set for the target program, or use invoke_signed with proper PDA derivation",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Multi-Signature Signer Validation"
  },
  {
    "sample_id": "SOL_V5_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates account key consistency in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn forward_to_service(\n        ctx: Context<ForwardToService>,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        let service = &ctx.accounts.service;\n        let service_account = &ctx.accounts.service_account;\n        // VULNERABLE: No verification that service_account belongs to service program\n        // Attacker could pass unrelated accounts\n        let instruction = Instruction {\n            program_id: service.key(),\n            accounts: vec![\n                AccountMeta::new(service_account.key(), false),\n            ],\n            data,\n        };\n        invoke(\n            &instruction,\n            &[service.clone(), service_account.clone()],\n        )?;\n        emit!(DataForwarded {\n            service: service.key(),\n            account: service_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ForwardToService<'info> {\n    pub service: AccountInfo<'info>,\n    pub service_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct DataForwarded {\n    pub service: Pubkey,\n    pub account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - No Account Key Validation in CPI\nDescription: The contract forwards arbitrary accounts to an external service without verifying their ownership or relationship to the service. An attacker can pass unrelated accounts, causing the external service to operate on wrong data.\nRisk Level: HIGH\nRecommendation: Validate account ownership: require!(service_account.owner == &service.key(), ProgramError::IncorrectProgramId)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Account Key Validation in CPI"
  },
  {
    "sample_id": "SOL_V5_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly handles re-entrancy protection in CPI scenarios. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_unchecked_calls {\n    use super::*;\n\n    pub fn execute_callback_action(\n        ctx: Context<ExecuteCallbackAction>,\n        callback_data: Vec<u8>,\n    ) -> Result<()> {\n        let callback_program = &ctx.accounts.callback_program;\n        let state = &ctx.accounts.state;\n        // VULNERABLE: No re-entrancy guard before CPI\n        // Callback program could re-enter and call execute_callback_action again\n        let state_data = state.try_borrow_data()?;\n        let mut program_state = ProgramState::try_from_slice(&state_data)?;\n        program_state.execution_count += 1;\n        \n        let callback_instruction = Instruction {\n            program_id: callback_program.key(),\n            accounts: vec![],\n            data: callback_data,\n        };\n        invoke(\n            &callback_instruction,\n            &[callback_program.clone()],\n        )?;\n        // State update after CPI - vulnerable to re-entrancy\n        drop(state_data);\n        let mut state_data_mut = state.try_borrow_mut_data()?;\n        let program_state = ProgramState::try_from_slice_mut(&mut state_data_mut)?;\n        program_state.last_execution = Clock::get()?.unix_timestamp as u64;\n        emit!(CallbackExecuted {\n            execution_count: program_state.execution_count,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteCallbackAction<'info> {\n    pub callback_program: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n}\n\n#[account]\npub struct ProgramState {\n    pub execution_count: u64,\n    pub last_execution: u64,\n}\n\n#[event]\npub struct CallbackExecuted {\n    pub execution_count: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Unchecked External Calls - No Re-entrancy Protection in CPI\nDescription: The contract executes a CPI to a callback program without preventing re-entrancy. The callback could invoke the same function recursively, causing state corruption, logic bypass, or unbounded resource consumption.\nRisk Level: CRITICAL\nRecommendation: Implement re-entrancy guard: Set a lock flag in state before CPI and verify it's not already locked",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Re-entrancy Guard in CPI"
  }
]
[
  {
    "sample_id": "SOL_V5_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates and handles external program calls, account permissions, and CPI results. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\nuse spl_token::ID as TOKEN_PROGRAM_ID;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn transfer_tokens_external_safely(\n        ctx: Context<TransferTokensExternalSafely>,\n        amount: u64,\n    ) -> Result<()> {\n        let from_account = &ctx.accounts.from_account;\n        let to_account = &ctx.accounts.to_account;\n        let token_program = &ctx.accounts.token_program;\n        // SECURE: Verify program ID before CPI\n        require!(\n            token_program.key() == &TOKEN_PROGRAM_ID,\n            ProgramError::IncorrectProgramId\n        );\n        let instruction = spl_token::instruction::transfer(\n            &token_program.key(),\n            &from_account.key(),\n            &to_account.key(),\n            &ctx.accounts.authority.key(),\n            &[],\n            amount,\n        )?;\n        invoke(\n            &instruction,\n            &[from_account.clone(), to_account.clone(), token_program.clone()],\n        )?;\n        emit!(TokensTransferredSafely {\n            from: from_account.key(),\n            to: to_account.key(),\n            amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferTokensExternalSafely<'info> {\n    pub from_account: AccountInfo<'info>,\n    pub to_account: AccountInfo<'info>,\n    pub token_program: AccountInfo<'info>,\n    pub authority: Signer<'info>,\n}\n\n#[event]\npub struct TokensTransferredSafely {\n    pub from: Pubkey,\n    pub to: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Program ID Verified\nDescription: The contract verifies the Token Program ID before executing the CPI. This ensures only the legitimate Token Program is invoked, preventing attacks via malicious program substitution.\nRisk Level: LOW\nValidation: Program ID checked against spl_token::ID",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Program ID in CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates account signatures and authorities in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\nuse anchor_lang::solana_program::system_instruction;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn execute_protected_action_safely(\n        ctx: Context<ExecuteProtectedActionSafely>,\n    ) -> Result<()> {\n        let authority = &ctx.accounts.authority;\n        let action_account = &ctx.accounts.action_account;\n        // SECURE: Verify authority is a valid signer\n        require!(\n            authority.is_signer,\n            ProgramError::MissingRequiredSignature\n        );\n        let instruction = system_instruction::create_account(\n            &ctx.accounts.payer.key(),\n            &action_account.key(),\n            1000000,\n            0,\n            &authority.key(),\n        );\n        invoke(\n            &instruction,\n            &[ctx.accounts.payer.to_account_info(), action_account.clone()],\n        )?;\n        emit!(ProtectedActionExecutedSafely {\n            authority: authority.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteProtectedActionSafely<'info> {\n    pub authority: Signer<'info>,\n    pub action_account: AccountInfo<'info>,\n    #[account(mut)]\n    pub payer: Signer<'info>,\n}\n\n#[event]\npub struct ProtectedActionExecutedSafely {\n    pub authority: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Signer Validation\nDescription: The contract verifies that the authority is a valid signer before executing the CPI. This prevents attackers from passing unauthorized signers to bypass access control.\nRisk Level: LOW\nValidation: authority.is_signer checked before CPI",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Signer in CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly handles CPI return values and error propagation. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn deposit_with_external_lock_safely(\n        ctx: Context<DepositWithExternalLockSafely>,\n        amount: u64,\n    ) -> Result<()> {\n        let lock_account = &ctx.accounts.lock_account;\n        // SECURE: CPI result is checked via ? operator\n        // If CPI fails, execution stops and error is propagated\n        invoke(\n            &build_lock_instruction(),\n            &[lock_account.clone()],\n        )?;  // ? propagates error if CPI fails\n        // State update only happens if CPI succeeded\n        let mut state_data = ctx.accounts.state.try_borrow_mut_data()?;\n        let state = ProgramState::try_from_slice_mut(&mut state_data)?;\n        state.total_deposits += amount;\n        emit!(DepositRecordedSafely {\n            amount,\n            total: state.total_deposits,\n        });\n        Ok(())\n    }\n}\n\nfn build_lock_instruction() -> Instruction {\n    Instruction {\n        program_id: Pubkey::default(),\n        accounts: vec![],\n        data: vec![],\n    }\n}\n\n#[derive(Accounts)]\npub struct DepositWithExternalLockSafely<'info> {\n    pub lock_account: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n}\n\n#[account]\npub struct ProgramState {\n    pub total_deposits: u64,\n}\n\n#[event]\npub struct DepositRecordedSafely {\n    pub amount: u64,\n    pub total: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - CPI Result Checked\nDescription: The contract checks the CPI result via the ? operator. If the external call fails, the program exits with an error, preventing state updates when CPI execution fails.\nRisk Level: LOW\nValidation: CPI result propagated with ? operator",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Checked CPI Result Handling"
  },
  {
    "sample_id": "SOL_V5_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates account ownership in CPI contexts. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\nconst TRUSTED_EXTERNAL_PROGRAM: &str = \"TrustedProgram1111111111111111111111111111111\";\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn modify_shared_state_safely(\n        ctx: Context<ModifySharedStateSafely>,\n    ) -> Result<()> {\n        let external_program = &ctx.accounts.external_program;\n        let shared_state = &ctx.accounts.shared_state;\n        // SECURE: Verify external program ownership\n        let trusted_id = TRUSTED_EXTERNAL_PROGRAM.parse::<Pubkey>()\n            .map_err(|_| ProgramError::InvalidArgument)?;\n        require!(\n            external_program.key() == &trusted_id,\n            ProgramError::IncorrectProgramId\n        );\n        let instruction = Instruction {\n            program_id: external_program.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(shared_state.key(), false),  // Read-only!\n            ],\n            data: vec![],\n        };\n        invoke(\n            &instruction,\n            &[external_program.clone(), shared_state.clone()],\n        )?;\n        // State is safe - external program has only read access\n        let state_data = shared_state.try_borrow_data()?;\n        let state = SharedState::try_from_slice(&state_data)?;\n        require!(state.is_valid(), ProgramError::InvalidAccountData);\n        emit!(StateModifiedSafely {\n            by: external_program.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ModifySharedStateSafely<'info> {\n    pub external_program: AccountInfo<'info>,\n    pub shared_state: AccountInfo<'info>,\n}\n\n#[account]\npub struct SharedState {\n    pub value: u64,\n    pub timestamp: u64,\n}\n\nimpl SharedState {\n    fn is_valid(&self) -> bool {\n        self.value > 0\n    }\n}\n\n#[event]\npub struct StateModifiedSafely {\n    pub by: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Trusted Program Verified & Read-Only Access\nDescription: The contract verifies the external program against a whitelist of trusted programs. Additionally, the shared state is passed as read-only to the external program, preventing unauthorized modifications.\nRisk Level: LOW\nValidation: Program ID whitelisted and state passed read-only",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Trusted Program with Minimal Permissions"
  },
  {
    "sample_id": "SOL_V5_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates write permissions in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn withdraw_and_notify_safely(\n        ctx: Context<WithdrawAndNotifySafely>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        let notifier = &ctx.accounts.notifier;\n        // SECURE: Update vault balance BEFORE CPI and grant only read access\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        vault_state.balance -= amount;\n        drop(vault_data);  // Release the borrow before CPI\n        \n        // Grant read-only access to vault for notification\n        let notification_instruction = Instruction {\n            program_id: notifier.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(vault.key(), false),  // Read-only!\n            ],\n            data: vec![],\n        };\n        invoke(\n            &notification_instruction,\n            &[notifier.clone(), vault.clone()],\n        )?;\n        emit!(WithdrawalProcessedSafely {\n            amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawAndNotifySafely<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n    pub notifier: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub balance: u64,\n}\n\n#[event]\npub struct WithdrawalProcessedSafely {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Minimal Write Permissions in CPI\nDescription: The contract updates the vault balance before invoking the external program and passes the vault as read-only to the notifier. This prevents the external program from modifying critical state.\nRisk Level: LOW\nValidation: State updated before CPI; external program has read-only access",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Restricted Write Permissions in CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates rent-exemption and account state before CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn sync_external_state_safely(\n        ctx: Context<SyncExternalStateSafely>,\n    ) -> Result<()> {\n        let external_account = &ctx.accounts.external_account;\n        let rent = Rent::get()?;\n        // SECURE: Check rent exemption before CPI\n        require!(\n            rent.is_exempt(external_account.lamports(), external_account.data_len()),\n            ProgramError::AccountNotRentExempt\n        );\n        let sync_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(\n            &sync_instruction,\n            &[external_account.clone()],\n        )?;\n        // Account is guaranteed to still exist after CPI\n        let account_data = external_account.try_borrow_data()?;\n        let state = ExternalState::try_from_slice(&account_data)?;\n        require!(\n            state.last_sync > 0,\n            ProgramError::InvalidAccountData\n        );\n        emit!(StateSyncedSafely {\n            account: external_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SyncExternalStateSafely<'info> {\n    pub external_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct ExternalState {\n    pub last_sync: u64,\n}\n\n#[event]\npub struct StateSyncedSafely {\n    pub account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Rent Exemption Verified Before CPI\nDescription: The contract verifies that the external account is rent-exempt before executing the CPI. This ensures the account cannot be closed or reclaimed during or after the external call.\nRisk Level: LOW\nValidation: Rent exemption checked before CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Rent Exemption Validation Before CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates data consistency after CPI execution. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn batch_transfer_with_hook_safely(\n        ctx: Context<BatchTransferWithHookSafely>,\n        amount: u64,\n    ) -> Result<()> {\n        let recipient = &ctx.accounts.recipient;\n        let hook_program = &ctx.accounts.hook_program;\n        // SECURE: Validate recipient state BEFORE and AFTER hook\n        let recipient_data = recipient.try_borrow_data()?;\n        let recipient_state = RecipientState::try_from_slice(&recipient_data)?;\n        require!(recipient_state.is_active, ProgramError::InvalidAccountData);\n        drop(recipient_data);\n        \n        let hook_instruction = Instruction {\n            program_id: hook_program.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(recipient.key(), false),  // Read-only!\n            ],\n            data: vec![],\n        };\n        invoke(\n            &hook_instruction,\n            &[hook_program.clone(), recipient.clone()],\n        )?;\n        \n        // SECURE: Re-validate state after CPI\n        let recipient_data = recipient.try_borrow_data()?;\n        let recipient_state = RecipientState::try_from_slice(&recipient_data)?;\n        require!(recipient_state.is_active, ProgramError::InvalidAccountData);\n        emit!(TransferCompletedSafely {\n            recipient: recipient.key(),\n            amount,\n            final_balance: recipient_state.balance + amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BatchTransferWithHookSafely<'info> {\n    pub recipient: AccountInfo<'info>,\n    pub hook_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct RecipientState {\n    pub is_active: bool,\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferCompletedSafely {\n    pub recipient: Pubkey,\n    pub amount: u64,\n    pub final_balance: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - State Validation Before and After CPI\nDescription: The contract validates the recipient state before and after the hook execution. If the hook corrupts the state, the post-CPI check catches the violation and prevents further execution.\nRisk Level: LOW\nValidation: State validated before and after CPI; read-only access granted to hook",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "State Validation Before and After CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates signer authority in multi-signature scenarios. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n// Hardcoded list of authorized signers for multisig\nconst AUTHORIZED_SIGNER_1: &str = \"AuthorizedSigner11111111111111111111111111\";\nconst AUTHORIZED_SIGNER_2: &str = \"AuthorizedSigner22222222222222222222222222\";\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn execute_multisig_action_safely(\n        ctx: Context<ExecuteMultisigActionSafely>,\n    ) -> Result<()> {\n        let signer1 = &ctx.accounts.signer1;\n        let signer2 = &ctx.accounts.signer2;\n        let multisig_program = &ctx.accounts.multisig_program;\n        // SECURE: Verify signers are authorized\n        let auth_signer1 = AUTHORIZED_SIGNER_1.parse::<Pubkey>()\n            .map_err(|_| ProgramError::InvalidArgument)?;\n        let auth_signer2 = AUTHORIZED_SIGNER_2.parse::<Pubkey>()\n            .map_err(|_| ProgramError::InvalidArgument)?;\n        require!(\n            signer1.key() == &auth_signer1,\n            ProgramError::IncorrectProgramId\n        );\n        require!(\n            signer2.key() == &auth_signer2,\n            ProgramError::IncorrectProgramId\n        );\n        let instruction = Instruction {\n            program_id: multisig_program.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(signer1.key(), true),\n                AccountMeta::new_readonly(signer2.key(), true),\n            ],\n            data: vec![1],  // Action ID\n        };\n        invoke(\n            &instruction,\n            &[signer1.clone(), signer2.clone(), multisig_program.clone()],\n        )?;\n        emit!(MultisigActionExecutedSafely {\n            signers: vec![signer1.key(), signer2.key()],\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteMultisigActionSafely<'info> {\n    pub signer1: Signer<'info>,\n    pub signer2: Signer<'info>,\n    pub multisig_program: AccountInfo<'info>,\n}\n\n#[event]\npub struct MultisigActionExecutedSafely {\n    pub signers: Vec<Pubkey>,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Multi-Signature Signer Authority Validated\nDescription: The contract verifies that both signers match the authorized signer set before executing the CPI. This ensures only authorized parties can execute multi-signature actions.\nRisk Level: LOW\nValidation: Signers validated against authorized signer whitelist",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Authorized Signer Validation in CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly validates account key consistency in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn forward_to_service_safely(\n        ctx: Context<ForwardToServiceSafely>,\n        data: Vec<u8>,\n    ) -> Result<()> {\n        let service = &ctx.accounts.service;\n        let service_account = &ctx.accounts.service_account;\n        // SECURE: Verify that service_account is owned by the service program\n        require!(\n            service_account.owner == service.key(),\n            ProgramError::IncorrectProgramId\n        );\n        let instruction = Instruction {\n            program_id: service.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(service_account.key(), false),\n            ],\n            data,\n        };\n        invoke(\n            &instruction,\n            &[service.clone(), service_account.clone()],\n        )?;\n        emit!(DataForwardedSafely {\n            service: service.key(),\n            account: service_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ForwardToServiceSafely<'info> {\n    pub service: AccountInfo<'info>,\n    pub service_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct DataForwardedSafely {\n    pub service: Pubkey,\n    pub account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Account Ownership Validated in CPI\nDescription: The contract verifies that the service_account is owned by the service program before forwarding data. This ensures the external program receives valid accounts that it controls.\nRisk Level: LOW\nValidation: Account ownership checked against service program ID",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Account Ownership Validation in CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external call vulnerabilities and Cross-Program Invocation (CPI) safety issues. Identify if the code properly handles re-entrancy protection in CPI scenarios. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_unchecked_calls {\n    use super::*;\n\n    pub fn execute_callback_action_safely(\n        ctx: Context<ExecuteCallbackActionSafely>,\n        callback_data: Vec<u8>,\n    ) -> Result<()> {\n        let callback_program = &ctx.accounts.callback_program;\n        let state = &ctx.accounts.state;\n        // SECURE: Implement re-entrancy guard\n        let mut state_data = state.try_borrow_mut_data()?;\n        let program_state = ProgramState::try_from_slice_mut(&mut state_data)?;\n        // Check lock flag\n        require!(\n            !program_state.is_locked,\n            ProgramError::Custom(1)  // Re-entrancy detected\n        );\n        // Set lock BEFORE CPI\n        program_state.is_locked = true;\n        drop(state_data);  // Release borrow\n        \n        let callback_instruction = Instruction {\n            program_id: callback_program.key(),\n            accounts: vec![],\n            data: callback_data,\n        };\n        invoke(\n            &callback_instruction,\n            &[callback_program.clone()],\n        )?;\n        \n        // Release lock AFTER CPI\n        let mut state_data = state.try_borrow_mut_data()?;\n        let program_state = ProgramState::try_from_slice_mut(&mut state_data)?;\n        program_state.is_locked = false;\n        program_state.last_execution = Clock::get()?.unix_timestamp as u64;\n        emit!(CallbackExecutedSafely {\n            execution_count: program_state.execution_count + 1,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteCallbackActionSafely<'info> {\n    pub callback_program: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n}\n\n#[account]\npub struct ProgramState {\n    pub is_locked: bool,\n    pub execution_count: u64,\n    pub last_execution: u64,\n}\n\n#[event]\npub struct CallbackExecutedSafely {\n    pub execution_count: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Re-entrancy Guard Implemented\nDescription: The contract implements a re-entrancy guard using a lock flag. Before invoking the callback, the lock is set. If a re-entrant call attempts to execute the same function, it will fail at the lock check, preventing recursive execution.\nRisk Level: LOW\nValidation: Lock flag checked before CPI and released after CPI completion",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Re-entrancy Guard with Lock Flag"
  }
]
