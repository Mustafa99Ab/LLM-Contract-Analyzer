[
  {
    "sample_id": "SOL_V5_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities and violations of the Checks-Effects-Interactions (CEI) pattern. Identify if the code properly updates state before making external calls. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn withdraw_reentrancy(\n        ctx: Context<WithdrawReentrancy>,\n        amount: u64,\n    ) -> Result<()> {\n        let user = &ctx.accounts.user;\n        let vault = &ctx.accounts.vault;\n        // CHECK: Balance check passes\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        require!(vault_state.balance >= amount, ProgramError::InsufficientFunds);\n        drop(vault_data);\n        // INTERACTION: Transfer funds BEFORE updating state (VULNERABLE!)\n        let transfer_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&transfer_instruction, &[user.to_account_info()])?;\n        // EFFECT: Update user balance AFTER external call\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        vault_state.balance -= amount;\n        emit!(WithdrawalAttempted { user: *user.key(), amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawReentrancy<'info> {\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub balance: u64,\n}\n\n#[event]\npub struct WithdrawalAttempted {\n    pub user: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (CEI Pattern Violation)\nAnalysis: The function executes the external transfer (Interaction) BEFORE updating the user's balance (Effect). During the external call, a reentrancy attack can call this function again, reading the original balance and withdrawing funds multiple times before the balance is updated.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Follow CEI pattern: Check â†’ Effect (update balance) â†’ Interaction (external call)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Effect-Interaction Order Violation (CEI)"
  },
  {
    "sample_id": "SOL_V5_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities through shared mutable state. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn transfer_with_callback(\n        ctx: Context<TransferWithCallback>,\n        amount: u64,\n    ) -> Result<()> {\n        let receiver = &ctx.accounts.receiver;\n        let callback_program = &ctx.accounts.callback_program;\n        // VULNERABLE: Passing writable receiver account to external callback\n        let callback_instruction = Instruction {\n            program_id: callback_program.key(),\n            accounts: vec![\n                AccountMeta::new(receiver.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&callback_instruction, &[receiver.clone(), callback_program.clone()])?;\n        // Update balance AFTER callback\n        let mut receiver_data = receiver.try_borrow_mut_data()?;\n        let receiver_state = ReceiverState::try_from_slice_mut(&mut receiver_data)?;\n        receiver_state.balance += amount;\n        emit!(TransferExecuted { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithCallback<'info> {\n    #[account(mut)]\n    pub receiver: AccountInfo<'info>,\n    pub callback_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct ReceiverState {\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferExecuted {\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (Shared Mutable State)\nAnalysis: The receiver account is passed as writable to an external callback. The callback can re-enter and call transfer_with_callback again while the balance update is pending, causing reentrancy through shared state modification.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Pass receiver as read-only: AccountMeta::new_readonly(receiver.key(), false)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Shared Mutable State Reentrancy"
  },
  {
    "sample_id": "SOL_V5_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in nested CPI calls. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn nested_cpi_without_guard(\n        ctx: Context<NestedCPIWithoutGuard>,\n    ) -> Result<()> {\n        let state = &ctx.accounts.state;\n        let external_program1 = &ctx.accounts.external_program1;\n        // VULNERABLE: Two CPI calls without depth limit\n        let instruction1 = Instruction {\n            program_id: external_program1.key(),\n            accounts: vec![],\n            data: vec![1],\n        };\n        invoke(&instruction1, &[external_program1.clone()])?;\n        let instruction2 = Instruction {\n            program_id: external_program1.key(),\n            accounts: vec![],\n            data: vec![2],\n        };\n        invoke(&instruction2, &[external_program1.clone()])?;\n        // State update\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = NestedState::try_from_slice_mut(&mut state_data)?;\n        state_obj.execution_count += 1;\n        emit!(ExecutionCompleted { count: state_obj.execution_count });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct NestedCPIWithoutGuard<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub external_program1: AccountInfo<'info>,\n}\n\n#[account]\npub struct NestedState {\n    pub execution_count: u64,\n}\n\n#[event]\npub struct ExecutionCompleted {\n    pub count: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (Nested CPI without Depth Guard)\nAnalysis: Sequential CPI calls are made without any limit on recursion depth. If either external program re-enters, there is no guard preventing unbounded nested calls, leading to stack issues or logic bypass.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Implement a recursion depth counter or state lock before CPI calls",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Nested CPI without Depth Guard"
  },
  {
    "sample_id": "SOL_V5_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities through PDA bump seed issues. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke_signed;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn pda_reentrancy_vulnerability(\n        ctx: Context<PDAReentrancy>,\n        bump: u8,\n    ) -> Result<()> {\n        let user_pda = &ctx.accounts.user_pda;\n        let authority = &ctx.accounts.authority;\n        // VULNERABLE: Using bump seed without complete validation\n        let pda_key = Pubkey::find_program_address(\n            &[b\"user\", authority.key.as_ref()],\n            &crate::ID,\n        ).0;\n        require_eq!(user_pda.key(), &pda_key, ProgramError::InvalidArgument);\n        let mut pda_data = user_pda.try_borrow_mut_data()?;\n        let pda_state = PDAState::try_from_slice_mut(&mut pda_data)?;\n        pda_state.balance -= 100;\n        // Invoke with potentially wrong bump\n        let seeds = [b\"user\", authority.key.as_ref(), &[bump]];\n        let signer = [&seeds[..]];\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke_signed(&instruction, &[user_pda.clone()], &signer)?;\n        emit!(PDAUsed { pda: user_pda.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct PDAReentrancy<'info> {\n    #[account(mut)]\n    pub user_pda: AccountInfo<'info>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct PDAState {\n    pub balance: u64,\n}\n\n#[event]\npub struct PDAUsed {\n    pub pda: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (PDA Bump Seed Reentrancy)\nAnalysis: The function uses invoke_signed with a bump seed that isn't fully validated. An incorrect bump seed could allow external programs to manipulate signing, potentially triggering reentrancy-style attacks.\nRisk Level: ðŸŸ  HIGH\nRecommendation: Always use the correct bump from find_program_address in invoke_signed",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "PDA Bump Seed Reentrancy"
  },
  {
    "sample_id": "SOL_V5_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities caused by delayed state updates. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn delayed_effect_vulnerability(\n        ctx: Context<DelayedEffect>,\n        amount: u64,\n    ) -> Result<()> {\n        let user = &ctx.accounts.user;\n        let state = &ctx.accounts.state;\n        // CHECK\n        let state_data = state.try_borrow_data()?;\n        let state_obj = State::try_from_slice(&state_data)?;\n        require!(state_obj.user_balance >= amount, ProgramError::InsufficientFunds);\n        drop(state_data);\n        // INTERACTION\n        let cpi_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&cpi_instruction, &[user.to_account_info()])?;\n        // VULNERABLE: Delay before Effect\n        for _ in 0..100 {\n            // simulate delay\n        }\n        // EFFECT (delayed) - Reentrant call can pass check during delay\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = State::try_from_slice_mut(&mut state_data)?;\n        state_obj.user_balance -= amount;\n        emit!(BalanceUpdated { balance: state_obj.user_balance });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct DelayedEffect<'info> {\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n}\n\n#[account]\npub struct State {\n    pub user_balance: u64,\n}\n\n#[event]\npub struct BalanceUpdated {\n    pub balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (Delayed State Update)\nAnalysis: The Effect (state update) is significantly delayed after the Interaction. A reentrant call during the delay can pass the Check with the same balance, allowing multiple withdrawals from the same balance.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Update state immediately after Check and before Interaction",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Delayed State Update Reentrancy"
  },
  {
    "sample_id": "SOL_V5_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in multi-step atomic transactions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn multi_step_transaction(\n        ctx: Context<MultiStepTransaction>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        let recipient = &ctx.accounts.recipient;\n        // Step 1: Debit sender\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        require!(vault_state.sender_balance >= amount, ProgramError::InsufficientFunds);\n        vault_state.sender_balance -= amount;\n        drop(vault_data);\n        // Step 2: CPI - Reenter here!\n        let transfer_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&transfer_instruction, &[recipient.to_account_info()])?;\n        // Step 3: Credit recipient - Separated from Step 1\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        vault_state.recipient_balance += amount;\n        emit!(TransactionCompleted { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct MultiStepTransaction<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n    pub recipient: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub sender_balance: u64,\n    pub recipient_balance: u64,\n}\n\n#[event]\npub struct TransactionCompleted {\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (Multi-Step Atomic Transaction)\nAnalysis: Multiple Effect steps are separated by a CPI call. Between debit sender and credit recipient, a reentrant call can occur, causing inconsistent state where one side is updated but not the other.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Group all Effects before any Interaction, or use a state lock",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Multi-Step Transaction Reentrancy"
  },
  {
    "sample_id": "SOL_V5_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in batch operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn batch_withdraw_with_reentrancy(\n        ctx: Context<BatchWithdraw>,\n        user_keys: Vec<Pubkey>,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        // VULNERABLE: Withdraw per iteration without atomic state lock\n        for user_key in user_keys.iter() {\n            let mut vault_data = vault.try_borrow_mut_data()?;\n            let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n            let balance = vault_state.balances.get(user_key).copied().unwrap_or(0);\n            if balance > 0 {\n                drop(vault_data);\n                // CPI: Transfer funds - can reenter!\n                let transfer_instruction = Instruction {\n                    program_id: Pubkey::default(),\n                    accounts: vec![],\n                    data: vec![],\n                };\n                invoke(&transfer_instruction, &[])?;\n                let mut vault_data = vault.try_borrow_mut_data()?;\n                let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n                vault_state.balances.remove(user_key);\n            }\n        }\n        emit!(BatchWithdrawalCompleted { count: user_keys.len() as u32 });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BatchWithdraw<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub balances: std::collections::HashMap<Pubkey, u64>,\n}\n\n#[event]\npub struct BatchWithdrawalCompleted {\n    pub count: u32,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (Batch Iteration Reentrancy)\nAnalysis: Batch processing updates per iteration with CPI between read and update. A reentrant call can withdraw again using cached balance values, allowing double withdrawals.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Update all state before CPI or use state lock for batch operations",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Batch Iteration Reentrancy"
  },
  {
    "sample_id": "SOL_V5_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities through account data corruption. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn account_data_corruption_reentrancy(\n        ctx: Context<DataCorruption>,\n    ) -> Result<()> {\n        let state = &ctx.accounts.state;\n        let external_program = &ctx.accounts.external_program;\n        // VULNERABLE: Read value, pass writable account to external program\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = ContractState::try_from_slice_mut(&mut state_data)?;\n        let current_balance = state_obj.balance;\n        drop(state_data);\n        // CPI with writable state\n        let instruction = Instruction {\n            program_id: external_program.key(),\n            accounts: vec![\n                AccountMeta::new(state.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[state.clone(), external_program.clone()])?;\n        // State corrupted by external program, use stale value\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = ContractState::try_from_slice_mut(&mut state_data)?;\n        state_obj.balance = current_balance;\n        emit!(StateUpdated { balance: state_obj.balance });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct DataCorruption<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub external_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct ContractState {\n    pub balance: u64,\n}\n\n#[event]\npub struct StateUpdated {\n    pub balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (Account Data Corruption)\nAnalysis: The function passes the mutable state account to an external program via CPI. The external program can re-enter and modify the state, causing stale or corrupted values to be used.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Pass state as read-only or use state lock before CPI",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Account Data Corruption Reentrancy"
  },
  {
    "sample_id": "SOL_V5_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in conditional logic paths. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn conditional_reentrancy(\n        ctx: Context<ConditionalExecution>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        let recipient = &ctx.accounts.recipient;\n        // CHECK 1\n        let vault_data = vault.try_borrow_data()?;\n        let vault_state = VaultState::try_from_slice(&vault_data)?;\n        require!(vault_state.total >= amount, ProgramError::InsufficientFunds);\n        drop(vault_data);\n        // INTERACTION - can reenter\n        let callback_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&callback_instruction, &[recipient.to_account_info()])?;\n        // CHECK 2 - can be bypassed by reentry\n        let vault_data = vault.try_borrow_data()?;\n        let vault_state = VaultState::try_from_slice(&vault_data)?;\n        if vault_state.total >= amount * 2 {\n            drop(vault_data);\n            let mut vault_data = vault.try_borrow_mut_data()?;\n            let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n            vault_state.total -= amount;\n        }\n        emit!(ConditionalTransfer { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ConditionalExecution<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n    pub recipient: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub total: u64,\n}\n\n#[event]\npub struct ConditionalTransfer {\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (Conditional Path Reentrancy)\nAnalysis: Multiple condition checks are performed before and after CPI. A reentrant call can pass all checks with stale values, allowing the effect to execute with bypassed conditions.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Update state before CPI and avoid re-checking conditions after CPI",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Conditional Path Reentrancy"
  },
  {
    "sample_id": "SOL_V5_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in state machine transitions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_reentrancy {\n    use super::*;\n\n    pub fn state_machine_reentrancy(\n        ctx: Context<StateMachineExecution>,\n    ) -> Result<()> {\n        let state = &ctx.accounts.state;\n        let external = &ctx.accounts.external;\n        // CHECK: Verify state is INITIAL\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = StateMachine::try_from_slice_mut(&mut state_data)?;\n        require!(state_obj.status == 0, ProgramError::InvalidArgument);\n        // EFFECT 1: Transition to PROCESSING\n        state_obj.status = 1;\n        drop(state_data);\n        // INTERACTION - Can reenter and cause invalid transitions\n        let instruction = Instruction {\n            program_id: external.key(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&instruction, &[external.clone()])?;\n        // EFFECT 2: Transition to COMPLETE\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = StateMachine::try_from_slice_mut(&mut state_data)?;\n        state_obj.status = 2;\n        emit!(StateTransitioned { new_status: 2 });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct StateMachineExecution<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub external: AccountInfo<'info>,\n}\n\n#[account]\npub struct StateMachine {\n    pub status: u8,\n}\n\n#[event]\npub struct StateTransitioned {\n    pub new_status: u8,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V5 - Reentrancy Attacks (State Machine Reentrancy)\nAnalysis: State transitions occur across multiple steps without atomic protection. Between PROCESSING and COMPLETE states, a reentrant call can cause invalid state machine transitions or bypass state checks.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Use atomic state lock throughout all state transitions or implement mutex pattern",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "State Machine Reentrancy"
  }
]
[
  {
    "sample_id": "SOL_V5_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities and violations of the Checks-Effects-Interactions (CEI) pattern. Identify if the code properly updates state before making external calls. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn withdraw_safe(\n        ctx: Context<WithdrawSafe>,\n        amount: u64,\n    ) -> Result<()> {\n        let user = &ctx.accounts.user;\n        let vault = &ctx.accounts.vault;\n        // CHECK: Balance check\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        require!(vault_state.balance >= amount, ProgramError::InsufficientFunds);\n        // EFFECT: Update balance IMMEDIATELY (before interaction)\n        vault_state.balance -= amount;\n        drop(vault_data);\n        // INTERACTION: Transfer funds AFTER state update\n        let transfer_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&transfer_instruction, &[user.to_account_info()])?;\n        emit!(WithdrawalCompleted { user: *user.key(), amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawSafe<'info> {\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub balance: u64,\n}\n\n#[event]\npub struct WithdrawalCompleted {\n    pub user: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - CEI Pattern Followed\nAnalysis: The function correctly follows the Checks-Effects-Interactions pattern. Balance is updated BEFORE the external transfer call, preventing reentrancy attacks that would read the original balance.\nRisk Level: âœ… LOW\nValidation: Check â†’ Effect (update balance) â†’ Interaction (external call) in correct order",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Secure CEI Pattern"
  },
  {
    "sample_id": "SOL_V5_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities through shared mutable state. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn transfer_with_callback_safe(\n        ctx: Context<TransferWithCallbackSafe>,\n        amount: u64,\n    ) -> Result<()> {\n        let receiver = &ctx.accounts.receiver;\n        let callback_program = &ctx.accounts.callback_program;\n        // SECURE: Update state BEFORE callback\n        let mut receiver_data = receiver.try_borrow_mut_data()?;\n        let receiver_state = ReceiverState::try_from_slice_mut(&mut receiver_data)?;\n        receiver_state.balance += amount;\n        drop(receiver_data);\n        // Pass receiver as READ-ONLY to prevent modification\n        let callback_instruction = Instruction {\n            program_id: callback_program.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(receiver.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&callback_instruction, &[receiver.clone(), callback_program.clone()])?;\n        emit!(TransferExecutedSafely { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithCallbackSafe<'info> {\n    #[account(mut)]\n    pub receiver: AccountInfo<'info>,\n    pub callback_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct ReceiverState {\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferExecutedSafely {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Mutable State Protected\nAnalysis: State is updated before the callback, and the receiver account is passed as read-only to prevent external modification. Reentrant calls cannot corrupt state or bypass updates.\nRisk Level: âœ… LOW\nValidation: State updated before CPI; external program has read-only access",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Read-Only State in CPI"
  },
  {
    "sample_id": "SOL_V5_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in nested CPI calls. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn nested_cpi_with_guard(\n        ctx: Context<NestedCPIWithGuard>,\n    ) -> Result<()> {\n        let state = &ctx.accounts.state;\n        let external_program1 = &ctx.accounts.external_program1;\n        // SECURE: Implement recursion guard\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = NestedState::try_from_slice_mut(&mut state_data)?;\n        const MAX_DEPTH: u64 = 5;\n        require!(state_obj.call_depth < MAX_DEPTH, ProgramError::Custom(1));\n        state_obj.call_depth += 1;\n        drop(state_data);\n        // CPI calls with depth tracking\n        let instruction1 = Instruction {\n            program_id: external_program1.key(),\n            accounts: vec![],\n            data: vec![1],\n        };\n        invoke(&instruction1, &[external_program1.clone()])?;\n        let instruction2 = Instruction {\n            program_id: external_program1.key(),\n            accounts: vec![],\n            data: vec![2],\n        };\n        invoke(&instruction2, &[external_program1.clone()])?;\n        // Decrement depth after CPIs\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = NestedState::try_from_slice_mut(&mut state_data)?;\n        state_obj.call_depth -= 1;\n        emit!(ExecutionCompletedSafely { depth: state_obj.call_depth });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct NestedCPIWithGuard<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub external_program1: AccountInfo<'info>,\n}\n\n#[account]\npub struct NestedState {\n    pub call_depth: u64,\n}\n\n#[event]\npub struct ExecutionCompletedSafely {\n    pub depth: u64,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Recursion Depth Guard\nAnalysis: A depth counter is incremented before CPI calls and decremented after. Reentrant calls attempting to exceed MAX_DEPTH will be rejected, preventing unbounded recursion.\nRisk Level: âœ… LOW\nValidation: Call depth tracked and limited to maximum value",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Depth Guard Implementation"
  },
  {
    "sample_id": "SOL_V5_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities through PDA bump seed issues. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke_signed;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn pda_reentrancy_safe(\n        ctx: Context<PDAReenantrancySafe>,\n    ) -> Result<()> {\n        let user_pda = &ctx.accounts.user_pda;\n        let authority = &ctx.accounts.authority;\n        // SECURE: Derive correct bump and validate it\n        let (pda_key, bump) = Pubkey::find_program_address(\n            &[b\"user\", authority.key.as_ref()],\n            &crate::ID,\n        );\n        require_eq!(user_pda.key(), &pda_key, ProgramError::InvalidArgument);\n        let mut pda_data = user_pda.try_borrow_mut_data()?;\n        let pda_state = PDAState::try_from_slice_mut(&mut pda_data)?;\n        pda_state.balance -= 100;\n        drop(pda_data);\n        // Use correct bump derived from find_program_address\n        let seeds = [b\"user\", authority.key.as_ref(), &[bump]];\n        let signer = [&seeds[..]];\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke_signed(&instruction, &[user_pda.clone()], &signer)?;\n        emit!(PDAUsedSafely { pda: user_pda.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct PDAReenantrancySafe<'info> {\n    #[account(mut)]\n    pub user_pda: AccountInfo<'info>,\n    pub authority: Signer<'info>,\n}\n\n#[account]\npub struct PDAState {\n    pub balance: u64,\n}\n\n#[event]\npub struct PDAUsedSafely {\n    pub pda: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Correct PDA Derivation\nAnalysis: The correct bump seed is derived from find_program_address and used in invoke_signed. This prevents malicious seed substitution and reentrancy through incorrect signing.\nRisk Level: âœ… LOW\nValidation: Bump seed derived and validated from find_program_address",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Secure PDA Derivation"
  },
  {
    "sample_id": "SOL_V5_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities caused by delayed state updates. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn delayed_effect_safe(\n        ctx: Context<DelayedEffectSafe>,\n        amount: u64,\n    ) -> Result<()> {\n        let user = &ctx.accounts.user;\n        let state = &ctx.accounts.state;\n        // CHECK\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = State::try_from_slice_mut(&mut state_data)?;\n        require!(state_obj.user_balance >= amount, ProgramError::InsufficientFunds);\n        // EFFECT: Immediate update - no delay\n        state_obj.user_balance -= amount;\n        drop(state_data);\n        // INTERACTION: Only after state is updated\n        let cpi_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&cpi_instruction, &[user.to_account_info()])?;\n        emit!(BalanceUpdatedSafely { balance: amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct DelayedEffectSafe<'info> {\n    pub user: Signer<'info>,\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n}\n\n#[account]\npub struct State {\n    pub user_balance: u64,\n}\n\n#[event]\npub struct BalanceUpdatedSafely {\n    pub balance: u64,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Immediate State Update\nAnalysis: State is updated immediately after the check, with no delay before the CPI. Reentrant calls will see the updated balance and cannot exploit timing windows.\nRisk Level: âœ… LOW\nValidation: State updated immediately after Check, before Interaction",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Immediate State Update"
  },
  {
    "sample_id": "SOL_V5_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in multi-step atomic transactions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn multi_step_transaction_safe(\n        ctx: Context<MultiStepTransactionSafe>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        let recipient = &ctx.accounts.recipient;\n        // Atomic: All effects before any interaction\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        require!(vault_state.sender_balance >= amount, ProgramError::InsufficientFunds);\n        // Step 1: Debit sender\n        vault_state.sender_balance -= amount;\n        // Step 2: Credit recipient\n        vault_state.recipient_balance += amount;\n        drop(vault_data);\n        // Step 3: CPI - only after both balance updates\n        let transfer_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&transfer_instruction, &[recipient.to_account_info()])?;\n        emit!(TransactionCompletedSafely { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct MultiStepTransactionSafe<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n    pub recipient: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub sender_balance: u64,\n    pub recipient_balance: u64,\n}\n\n#[event]\npub struct TransactionCompletedSafely {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Atomic State Updates\nAnalysis: Both debit and credit operations are completed before the CPI. The entire transaction is atomic, preventing reentrancy from observing intermediate states.\nRisk Level: âœ… LOW\nValidation: All Effects completed before Interaction",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Atomic Multi-Step Transaction"
  },
  {
    "sample_id": "SOL_V5_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in batch operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn batch_withdraw_safe(\n        ctx: Context<BatchWithdrawSafe>,\n        user_keys: Vec<Pubkey>,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        // SECURE: Update all state BEFORE any CPI\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        for user_key in user_keys.iter() {\n            if let Some(balance) = vault_state.balances.get(user_key) {\n                if *balance > 0 {\n                    vault_state.balances.remove(user_key);\n                }\n            }\n        }\n        drop(vault_data);\n        // THEN: Execute all CPIs after state updates\n        for _ in user_keys.iter() {\n            let transfer_instruction = Instruction {\n                program_id: Pubkey::default(),\n                accounts: vec![],\n                data: vec![],\n            };\n            invoke(&transfer_instruction, &[])?;\n        }\n        emit!(BatchWithdrawalCompletedSafely { count: user_keys.len() as u32 });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BatchWithdrawSafe<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub balances: std::collections::HashMap<Pubkey, u64>,\n}\n\n#[event]\npub struct BatchWithdrawalCompletedSafely {\n    pub count: u32,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Batch State Update Before CPI\nAnalysis: All batch state updates are completed before any CPI call. Reentrant calls cannot observe intermediate states or cause double withdrawals.\nRisk Level: âœ… LOW\nValidation: All state updates completed atomically before CPIs",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Atomic Batch Operations"
  },
  {
    "sample_id": "SOL_V5_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities through account data corruption. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn account_data_corruption_safe(\n        ctx: Context<DataCorruptionSafe>,\n    ) -> Result<()> {\n        let state = &ctx.accounts.state;\n        let external_program = &ctx.accounts.external_program;\n        // SECURE: Cache value and update state before CPI\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = ContractState::try_from_slice_mut(&mut state_data)?;\n        let current_balance = state_obj.balance;\n        state_obj.balance = 0;  // Mark as processed\n        drop(state_data);\n        // CPI with state as READ-ONLY\n        let instruction = Instruction {\n            program_id: external_program.key(),\n            accounts: vec![\n                AccountMeta::new_readonly(state.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[state.clone(), external_program.clone()])?;\n        emit!(StateUpdatedSafely { balance: 0 });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct DataCorruptionSafe<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub external_program: AccountInfo<'info>,\n}\n\n#[account]\npub struct ContractState {\n    pub balance: u64,\n}\n\n#[event]\npub struct StateUpdatedSafely {\n    pub balance: u64,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Protected Mutable State\nAnalysis: State is updated before CPI, and the state account is passed as read-only to prevent external modification. Reentrancy cannot corrupt or cause stale value usage.\nRisk Level: âœ… LOW\nValidation: State updated before CPI; external program has read-only access",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Protected Mutable State"
  },
  {
    "sample_id": "SOL_V5_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in conditional logic paths. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn conditional_safe(\n        ctx: Context<ConditionalExecutionSafe>,\n        amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        let recipient = &ctx.accounts.recipient;\n        // SECURE: Update state before conditional check\n        let mut vault_data = vault.try_borrow_mut_data()?;\n        let vault_state = VaultState::try_from_slice_mut(&mut vault_data)?;\n        require!(vault_state.total >= amount, ProgramError::InsufficientFunds);\n        vault_state.total -= amount;\n        drop(vault_data);\n        // CPI\n        let callback_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&callback_instruction, &[recipient.to_account_info()])?;\n        // No re-checking conditions - state is already updated\n        emit!(ConditionalTransferSafely { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ConditionalExecutionSafe<'info> {\n    #[account(mut)]\n    pub vault: AccountInfo<'info>,\n    pub recipient: AccountInfo<'info>,\n}\n\n#[account]\npub struct VaultState {\n    pub total: u64,\n}\n\n#[event]\npub struct ConditionalTransferSafely {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Single Condition Check\nAnalysis: The condition is checked once and state is updated immediately. No re-checks occur after CPI, preventing reentrancy from bypassing conditions.\nRisk Level: âœ… LOW\nValidation: Condition checked once; state updated before CPI; no re-checks after CPI",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Single Condition Check"
  },
  {
    "sample_id": "SOL_V5_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for reentrancy vulnerabilities in state machine transitions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_reentrancy {\n    use super::*;\n\n    pub fn state_machine_safe(\n        ctx: Context<StateMachineExecutionSafe>,\n    ) -> Result<()> {\n        let state = &ctx.accounts.state;\n        let external = &ctx.accounts.external;\n        // SECURE: Use mutex lock during state machine transitions\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = StateMachine::try_from_slice_mut(&mut state_data)?;\n        require!(state_obj.status == 0, ProgramError::InvalidArgument);\n        // Lock: Set to IN_TRANSITION\n        state_obj.status = 255;  // Locked state\n        drop(state_data);\n        // CPI - protected by lock\n        let instruction = Instruction {\n            program_id: external.key(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&instruction, &[external.clone()])?;\n        // Unlock: Transition to COMPLETE atomically\n        let mut state_data = state.try_borrow_mut_data()?;\n        let state_obj = StateMachine::try_from_slice_mut(&mut state_data)?;\n        state_obj.status = 2;  // COMPLETE\n        emit!(StateTransitionedSafely { new_status: 2 });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct StateMachineExecutionSafe<'info> {\n    #[account(mut)]\n    pub state: AccountInfo<'info>,\n    pub external: AccountInfo<'info>,\n}\n\n#[account]\npub struct StateMachine {\n    pub status: u8,\n}\n\n#[event]\npub struct StateTransitionedSafely {\n    pub new_status: u8,\n}",
    "output": "Status: SAFE\nVulnerability: N/A - Mutex Lock on State Transitions\nAnalysis: A lock state (255) is set before CPI and held throughout. Reentrant calls attempting to transition while locked will be rejected, ensuring atomic state transitions.\nRisk Level: âœ… LOW\nValidation: Mutex lock implemented; state transitions protected from reentrancy",
    "meta_platform": "Solana",
    "meta_vuln_type": "V5 - Reentrancy Attacks",
    "meta_pattern": "Mutex Lock State Machine"
  }
]
