[
  {
    "sample_id": "SOL_V6_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly validates and handles external program calls. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn transfer_without_check(\n        ctx: Context<TransferWithoutCheck>,\n        amount: u64,\n    ) -> Result<()> {\n        let token_program = &ctx.accounts.token_program;\n        let source = &ctx.accounts.source;\n        let destination = &ctx.accounts.destination;\n        // VULNERABLE: CPI result is discarded, execution continues even if transfer fails\n        let transfer_instruction = Instruction {\n            program_id: token_program.key(),\n            accounts: vec![\n                AccountMeta::new(source.key(), false),\n                AccountMeta::new(destination.key(), false),\n            ],\n            data: vec![],\n        };\n        let _ = invoke(&transfer_instruction, &[source.clone(), destination.clone(), token_program.clone()]);\n        // State updated regardless of CPI success/failure\n        emit!(TransferAttempted { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithoutCheck<'info> {\n    pub token_program: AccountInfo<'info>,\n    pub source: AccountInfo<'info>,\n    pub destination: AccountInfo<'info>,\n}\n\n#[event]\npub struct TransferAttempted {\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Unchecked CPI Result)\nAnalysis: The function executes a CPI to transfer tokens but explicitly discards the result using `let _`. If the external Token Program call fails, the program continues execution and emits a success event, creating inconsistent state where the transfer may have failed but the program acts as if it succeeded.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Check CPI result and propagate errors: invoke(&transfer_instruction, ...)?;",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Unchecked CPI Result Handling"
  },
  {
    "sample_id": "SOL_V6_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly validates PDA bump seeds before using them in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke_signed;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn execute_with_invalid_bump(\n        ctx: Context<ExecuteWithInvalidBump>,\n        bump_seed: u8,\n    ) -> Result<()> {\n        let pda_account = &ctx.accounts.pda_account;\n        // VULNERABLE: Using unvalidated bump seed in invoke_signed\n        // Attacker could pass wrong bump seed causing signing failure\n        let seeds = [b\"authority\", &[bump_seed]];\n        let signer_seeds = [&seeds[..]];\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![AccountMeta::new(pda_account.key(), true)],\n            data: vec![],\n        };\n        invoke_signed(&instruction, &[pda_account.clone()], &signer_seeds)?;\n        emit!(ExecutionCompleted { pda: pda_account.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteWithInvalidBump<'info> {\n    pub pda_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct ExecutionCompleted {\n    pub pda: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Missing PDA Verification)\nAnalysis: The function accepts a bump_seed parameter and uses it directly in invoke_signed without verifying it matches the canonical bump derived from find_program_address. An attacker can pass an incorrect bump, causing the PDA signature to fail or allowing malicious program invocation.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Verify bump seed before use: let (_, expected_bump) = Pubkey::find_program_address(...); require_eq!(bump_seed, expected_bump, ...);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing PDA Bump Verification"
  },
  {
    "sample_id": "SOL_V6_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates the target program ID before invoking it. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn call_untrusted_program(\n        ctx: Context<CallUntrustedProgram>,\n    ) -> Result<()> {\n        let target_program = &ctx.accounts.target_program;\n        // VULNERABLE: No validation of target_program ID\n        // Attacker passes malicious program address\n        let instruction = Instruction {\n            program_id: target_program.key(),\n            accounts: vec![],\n            data: vec![1, 2, 3],\n        };\n        invoke(&instruction, &[target_program.clone()])?;\n        emit!(ProgramCalled { target: target_program.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CallUntrustedProgram<'info> {\n    pub target_program: AccountInfo<'info>,\n}\n\n#[event]\npub struct ProgramCalled {\n    pub target: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Unsafe CPI Destination)\nAnalysis: The function accepts a target_program account and invokes it without verifying its address against a list of trusted program IDs. An attacker can pass a malicious program, causing arbitrary code execution with the caller's account context.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Validate program ID: const TRUSTED_PROGRAM: Pubkey = Pubkey::new_from_array(...); require_eq!(target_program.key(), TRUSTED_PROGRAM, ...);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Unsafe CPI Destination"
  },
  {
    "sample_id": "SOL_V6_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly handles external program authority requirements. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn invoke_privileged_action(\n        ctx: Context<InvokePrivilegedAction>,\n    ) -> Result<()> {\n        let admin_account = &ctx.accounts.admin_account;\n        // VULNERABLE: Not checking if admin_account is a signer\n        // External program expects a signer but gets read-only account\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new_readonly(admin_account.key(), true),  // Claims signer but not verified\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[admin_account.clone()])?;\n        emit!(PrivilegedActionExecuted { admin: admin_account.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InvokePrivilegedAction<'info> {\n    pub admin_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct PrivilegedActionExecuted {\n    pub admin: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Missing Signer Validation)\nAnalysis: The function invokes a privileged action and marks the admin_account as a signer in the instruction, but doesn't verify that admin_account is actually a signer. An attacker can pass a non-signer account, causing the external program to fail or allowing unauthorized actions.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Verify signer status: require!(admin_account.is_signer, ProgramError::MissingRequiredSignature);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Authority Validation"
  },
  {
    "sample_id": "SOL_V6_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates mutable account data before passing it to external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn update_external_state(\n        ctx: Context<UpdateExternalState>,\n    ) -> Result<()> {\n        let external_state = &ctx.accounts.external_state;\n        // VULNERABLE: Passing mutable account to external program without data validation\n        // External program could corrupt data or cause unexpected behavior\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(external_state.key(), false),\n            ],\n            data: vec![1],\n        };\n        invoke(&instruction, &[external_state.clone()])?;\n        emit!(StateUpdateAttempted { account: external_state.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UpdateExternalState<'info> {\n    pub external_state: AccountInfo<'info>,\n}\n\n#[event]\npub struct StateUpdateAttempted {\n    pub account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Unverified Account Data)\nAnalysis: The function passes a mutable external_state account to an external program without verifying the account's data format or ownership. The external program could corrupt the account data or behave unexpectedly with malformed data.\nRisk Level: ðŸŸ  HIGH\nRecommendation: Verify account data before CPI: let state = ExternalState::try_from_slice(&external_state.data)?;",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Unverified Account Data in CPI"
  },
  {
    "sample_id": "SOL_V6_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates account ownership before passing to external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn transfer_with_unknown_owner(\n        ctx: Context<TransferWithUnknownOwner>,\n    ) -> Result<()> {\n        let token_account = &ctx.accounts.token_account;\n        // VULNERABLE: Not verifying token_account is owned by Token Program\n        // Could be any account, leading to unexpected behavior\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(token_account.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[token_account.clone()])?;\n        emit!(TransferInitiated { token_account: token_account.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithUnknownOwner<'info> {\n    pub token_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct TransferInitiated {\n    pub token_account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Missing Account Owner Validation)\nAnalysis: The function passes a token_account to an external program without verifying its owner. An attacker can pass an account owned by a different program, causing the external program to operate on incorrect data or fail silently.\nRisk Level: ðŸŸ  HIGH\nRecommendation: Verify account owner: require!(token_account.owner == &spl_token::ID, ProgramError::IncorrectProgramId);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Missing Account Owner Validation"
  },
  {
    "sample_id": "SOL_V6_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly wraps external program calls in helper functions with error handling. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\npub fn external_operation_unhandled(accounts: &[AccountInfo]) -> Result<()> {\n    // Helper function that returns Result but error is not propagated\n    external_helper(accounts);\n    // VULNERABLE: Error from external_helper is discarded\n    Ok(())\n}\n\nfn external_helper(accounts: &[AccountInfo]) -> Result<()> {\n    let instruction = create_instruction();\n    anchor_lang::solana_program::program::invoke(&instruction, accounts)?;\n    Ok(())\n}\n\nfn create_instruction() -> Instruction {\n    Instruction {\n        program_id: Pubkey::default(),\n        accounts: vec![],\n        data: vec![],\n    }\n}\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn execute_with_unhandled_helper(\n        _ctx: Context<ExecuteWithUnhandledHelper>,\n    ) -> Result<()> {\n        external_operation_unhandled(&[])?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteWithUnhandledHelper {}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Error Handling in Helper Function)\nAnalysis: The external_operation_unhandled function calls a helper that returns a Result, but the result is not propagated or checked. If the external call fails, the error is silently discarded and execution continues.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Propagate helper results: external_helper(accounts)?;",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Unhandled Helper Function Result"
  },
  {
    "sample_id": "SOL_V6_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates account rent exemption before passing to external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn create_with_untrusted_payer(\n        ctx: Context<CreateWithUntrustedPayer>,\n    ) -> Result<()> {\n        let payer = &ctx.accounts.payer;\n        let new_account = &ctx.accounts.new_account;\n        // VULNERABLE: Not verifying payer is a signer or has sufficient funds\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(payer.key(), true),\n                AccountMeta::new(new_account.key(), true),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[payer.clone(), new_account.clone()])?;\n        emit!(AccountCreationAttempted { payer: payer.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateWithUntrustedPayer<'info> {\n    pub payer: AccountInfo<'info>,\n    pub new_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct AccountCreationAttempted {\n    pub payer: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Untrusted Payer Account)\nAnalysis: The function passes an arbitrary payer account to an external program for account creation without verifying it's a signer or has sufficient funds. An attacker can pass a non-signer or rent-exempt account, causing the external program to fail or creating security issues.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Verify payer: require!(payer.is_signer, ProgramError::MissingRequiredSignature);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Untrusted Payer in CPI"
  },
  {
    "sample_id": "SOL_V6_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code exposes sensitive error information from external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn execute_exposing_errors(\n        ctx: Context<ExecuteExposingErrors>,\n    ) -> Result<()> {\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        // VULNERABLE: Raw error from external program is propagated\n        // Could leak sensitive information about internal state\n        let result = invoke(&instruction, &[]);\n        result?;\n        emit!(ExecutionCompleted {});\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteExposingErrors {}\n\n#[event]\npub struct ExecutionCompleted {}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Error Information Disclosure)\nAnalysis: The function propagates raw errors from external program execution without masking or sanitizing them. If the external program returns error codes or messages that leak internal state, this information is exposed to the caller, potentially revealing security-sensitive details.\nRisk Level: ðŸŸ  HIGH\nRecommendation: Mask external errors: if result.is_err() { return Err(ProgramError::Custom(100)); }",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Error Information Disclosure"
  },
  {
    "sample_id": "SOL_V6_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly validates mutable accounts passed to external programs with write permissions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_external_calls {\n    use super::*;\n\n    pub fn modify_with_unverified_permissions(\n        ctx: Context<ModifyWithUnverifiedPermissions>,\n    ) -> Result<()> {\n        let config = &ctx.accounts.config;\n        // VULNERABLE: Passing config as writable to external program without owner check\n        // External program could be malicious and modify config incorrectly\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(config.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[config.clone()])?;\n        // Try to read config after external modification\n        let config_data = config.try_borrow_data()?;\n        let parsed_config = ConfigData::try_from_slice(&config_data)?;\n        require!(parsed_config.version > 0, ProgramError::InvalidAccountData);\n        emit!(ConfigModified { config: config.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ModifyWithUnverifiedPermissions<'info> {\n    pub config: AccountInfo<'info>,\n}\n\n#[account]\npub struct ConfigData {\n    pub version: u32,\n}\n\n#[event]\npub struct ConfigModified {\n    pub config: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V6 - Unchecked External Calls (Over-Permissive Mutable Account)\nAnalysis: The function passes the config account as mutable to an external program without verifying the config's owner or format. A malicious external program could corrupt the config data, and the subsequent deserialization might fail or reveal inconsistent state.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Verify account ownership before CPI: require!(config.owner == &crate::ID, ProgramError::IncorrectProgramId);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Over-Permissive Mutable Account"
  }
]
[
  {
    "sample_id": "SOL_V6_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly validates and handles external program calls. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn transfer_with_check(\n        ctx: Context<TransferWithCheck>,\n        amount: u64,\n    ) -> Result<()> {\n        let token_program = &ctx.accounts.token_program;\n        let source = &ctx.accounts.source;\n        let destination = &ctx.accounts.destination;\n        // SECURE: CPI result is checked with ? operator\n        let transfer_instruction = Instruction {\n            program_id: token_program.key(),\n            accounts: vec![\n                AccountMeta::new(source.key(), false),\n                AccountMeta::new(destination.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&transfer_instruction, &[source.clone(), destination.clone(), token_program.clone()])?;\n        // Only update state if CPI succeeded\n        emit!(TransferSucceeded { amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithCheck<'info> {\n    pub token_program: AccountInfo<'info>,\n    pub source: AccountInfo<'info>,\n    pub destination: AccountInfo<'info>,\n}\n\n#[event]\npub struct TransferSucceeded {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The CPI result is properly checked using the `?` operator, ensuring that if the transfer fails, the error is propagated and execution stops immediately.\nRisk Level: âœ… LOW\nValidation: CPI result checked and errors propagated with ?",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Checked CPI Result"
  },
  {
    "sample_id": "SOL_V6_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly validates PDA bump seeds before using them in CPI. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke_signed;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn execute_with_verified_bump(\n        ctx: Context<ExecuteWithVerifiedBump>,\n    ) -> Result<()> {\n        let pda_account = &ctx.accounts.pda_account;\n        // SECURE: Verify bump seed before using in invoke_signed\n        let (expected_pda, expected_bump) = Pubkey::find_program_address(\n            &[b\"authority\"],\n            &crate::ID,\n        );\n        require_eq!(pda_account.key(), &expected_pda, ProgramError::InvalidArgument);\n        let seeds = [b\"authority\", &[expected_bump]];\n        let signer_seeds = [&seeds[..]];\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![AccountMeta::new(pda_account.key(), true)],\n            data: vec![],\n        };\n        invoke_signed(&instruction, &[pda_account.clone()], &signer_seeds)?;\n        emit!(ExecutionCompletedSafely { pda: pda_account.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteWithVerifiedBump<'info> {\n    pub pda_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct ExecutionCompletedSafely {\n    pub pda: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The PDA is derived using find_program_address and verified before use in invoke_signed. The bump seed is obtained from the derivation result, ensuring it's canonical.\nRisk Level: âœ… LOW\nValidation: PDA and bump verified before CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified PDA Derivation"
  },
  {
    "sample_id": "SOL_V6_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates the target program ID before invoking it. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\nconst TRUSTED_PROGRAM_ID: Pubkey = Pubkey::new_from_array([\n    0x06, 0xdd, 0xf6, 0xe1, 0xd7, 0x65, 0xa1, 0x93, 0x16, 0x97, 0x10, 0x58, 0xd3, 0x9f, 0xf4, 0x88,\n    0x52, 0x2f, 0x5d, 0xc5, 0x93, 0x83, 0xc4, 0x52, 0x23, 0xa6, 0xa2, 0xfb, 0x6e, 0x8e, 0xc1, 0x19,\n]);\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn call_trusted_program(\n        ctx: Context<CallTrustedProgram>,\n    ) -> Result<()> {\n        let target_program = &ctx.accounts.target_program;\n        // SECURE: Verify program ID against trusted constant\n        require_eq!(\n            target_program.key(),\n            &TRUSTED_PROGRAM_ID,\n            ProgramError::IncorrectProgramId\n        );\n        let instruction = Instruction {\n            program_id: target_program.key(),\n            accounts: vec![],\n            data: vec![1, 2, 3],\n        };\n        invoke(&instruction, &[target_program.clone()])?;\n        emit!(TrustedProgramCalled { target: target_program.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CallTrustedProgram<'info> {\n    pub target_program: AccountInfo<'info>,\n}\n\n#[event]\npub struct TrustedProgramCalled {\n    pub target: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The program ID is verified against a hardcoded TRUSTED_PROGRAM_ID constant before the CPI is executed. Only trusted programs can be invoked.\nRisk Level: âœ… LOW\nValidation: Program ID whitelist verified before CPI",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Trusted Program ID Validation"
  },
  {
    "sample_id": "SOL_V6_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly handles external program authority requirements. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn invoke_privileged_action_safely(\n        ctx: Context<InvokePrivilegedActionSafely>,\n    ) -> Result<()> {\n        let admin_account = &ctx.accounts.admin_account;\n        // SECURE: Verify admin_account is a signer before marking as signer in CPI\n        require!(admin_account.is_signer, ProgramError::MissingRequiredSignature);\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new_readonly(admin_account.key(), true),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[admin_account.clone()])?;\n        emit!(PrivilegedActionExecutedSafely { admin: admin_account.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InvokePrivilegedActionSafely<'info> {\n    pub admin_account: Signer<'info>,\n}\n\n#[event]\npub struct PrivilegedActionExecutedSafely {\n    pub admin: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The admin_account is marked as a Signer in the Accounts struct, ensuring only valid signers can pass this check. The is_signer check is redundant but defensive.\nRisk Level: âœ… LOW\nValidation: Signer authority verified before CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Signer Authority"
  },
  {
    "sample_id": "SOL_V6_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates mutable account data before passing it to external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn update_external_state_safely(\n        ctx: Context<UpdateExternalStateSafely>,\n    ) -> Result<()> {\n        let external_state = &ctx.accounts.external_state;\n        // SECURE: Verify account data before passing to external program\n        let state_data = external_state.try_borrow_data()?;\n        let parsed_state = ExternalStateData::try_from_slice(&state_data)?;\n        drop(state_data);\n        require!(parsed_state.is_valid(), ProgramError::InvalidAccountData);\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(external_state.key(), false),\n            ],\n            data: vec![1],\n        };\n        invoke(&instruction, &[external_state.clone()])?;\n        emit!(StateUpdateSuccessful { account: external_state.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UpdateExternalStateSafely<'info> {\n    pub external_state: AccountInfo<'info>,\n}\n\n#[account]\npub struct ExternalStateData {\n    pub version: u32,\n}\n\nimpl ExternalStateData {\n    fn is_valid(&self) -> bool {\n        self.version > 0\n    }\n}\n\n#[event]\npub struct StateUpdateSuccessful {\n    pub account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The account data is deserialized and validated before being passed to the external program. This ensures data integrity and prevents malformed data from reaching the external program.\nRisk Level: âœ… LOW\nValidation: Account data verified before CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Account Data"
  },
  {
    "sample_id": "SOL_V6_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates account ownership before passing to external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\nuse spl_token::ID as TOKEN_PROGRAM_ID;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn transfer_verified_token_account(\n        ctx: Context<TransferVerifiedTokenAccount>,\n    ) -> Result<()> {\n        let token_account = &ctx.accounts.token_account;\n        // SECURE: Verify token_account is owned by Token Program\n        require_eq!(\n            token_account.owner,\n            &TOKEN_PROGRAM_ID,\n            ProgramError::IncorrectProgramId\n        );\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(token_account.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[token_account.clone()])?;\n        emit!(VerifiedTokenTransfer { token_account: token_account.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferVerifiedTokenAccount<'info> {\n    pub token_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct VerifiedTokenTransfer {\n    pub token_account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The account ownership is verified against the Token Program ID before the CPI, ensuring only legitimate token accounts are passed to the external program.\nRisk Level: âœ… LOW\nValidation: Account owner verified before CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Account Owner"
  },
  {
    "sample_id": "SOL_V6_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly wraps external program calls in helper functions with error handling. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\npub fn external_operation_handled(accounts: &[AccountInfo]) -> Result<()> {\n    // Helper function that returns Result and errors are propagated\n    external_helper(accounts)?\n    // SECURE: Error from external_helper is propagated with ?\n}\n\nfn external_helper(accounts: &[AccountInfo]) -> Result<()> {\n    let instruction = create_instruction();\n    anchor_lang::solana_program::program::invoke(&instruction, accounts)?;\n    Ok(())\n}\n\nfn create_instruction() -> Instruction {\n    Instruction {\n        program_id: Pubkey::default(),\n        accounts: vec![],\n        data: vec![],\n    }\n}\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn execute_with_handled_helper(\n        _ctx: Context<ExecuteWithHandledHelper>,\n    ) -> Result<()> {\n        external_operation_handled(&[])?;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteWithHandledHelper {}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: All external calls are wrapped in helper functions that properly propagate errors using the `?` operator. Any CPI failure is immediately communicated to the caller.\nRisk Level: âœ… LOW\nValidation: Helper function errors properly propagated",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Handled Helper Function Errors"
  },
  {
    "sample_id": "SOL_V6_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code validates account rent exemption and signer status before passing to external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn create_with_verified_payer(\n        ctx: Context<CreateWithVerifiedPayer>,\n    ) -> Result<()> {\n        let payer = &ctx.accounts.payer;\n        let new_account = &ctx.accounts.new_account;\n        // SECURE: Payer is verified as Signer in Accounts struct\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(payer.key(), true),\n                AccountMeta::new(new_account.key(), true),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[payer.clone(), new_account.clone()])?;\n        emit!(AccountCreatedSuccessfully { payer: payer.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CreateWithVerifiedPayer<'info> {\n    #[account(mut)]\n    pub payer: Signer<'info>,\n    pub new_account: AccountInfo<'info>,\n}\n\n#[event]\npub struct AccountCreatedSuccessfully {\n    pub payer: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The payer is defined as a Signer in the Accounts struct, ensuring only valid signers can be passed. The CPI will only succeed with authorized payers.\nRisk Level: âœ… LOW\nValidation: Payer verified as Signer before CPI execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Payer Authority"
  },
  {
    "sample_id": "SOL_V6_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly masks sensitive error information from external programs. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn execute_masking_errors(\n        ctx: Context<ExecuteMaskingErrors>,\n    ) -> Result<()> {\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        // SECURE: External program errors are masked\n        match invoke(&instruction, &[]) {\n            Ok(()) => {\n                emit!(ExecutionSuccessful {});\n                Ok(())\n            }\n            Err(_) => {\n                // Return generic error instead of exposing external program error\n                Err(ProgramError::Custom(100).into())\n            }\n        }\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteMaskingErrors {}\n\n#[event]\npub struct ExecutionSuccessful {}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The function catches CPI errors and returns a generic error code instead of propagating the raw external program error. This prevents sensitive information leakage.\nRisk Level: âœ… LOW\nValidation: External program errors properly masked",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Masked Error Information"
  },
  {
    "sample_id": "SOL_V6_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for unchecked external calls and CPI validation issues. Identify if the code properly validates mutable accounts passed to external programs with write permissions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_external_calls {\n    use super::*;\n\n    pub fn modify_with_verified_permissions(\n        ctx: Context<ModifyWithVerifiedPermissions>,\n    ) -> Result<()> {\n        let config = &ctx.accounts.config;\n        // SECURE: Config ownership and format verified before CPI\n        require_eq!(\n            config.owner,\n            &crate::ID,\n            ProgramError::IncorrectProgramId\n        );\n        let config_data = config.try_borrow_data()?;\n        let parsed_config = ConfigData::try_from_slice(&config_data)?;\n        drop(config_data);\n        require!(parsed_config.version > 0, ProgramError::InvalidAccountData);\n        let instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![\n                AccountMeta::new(config.key(), false),\n            ],\n            data: vec![],\n        };\n        invoke(&instruction, &[config.clone()])?;\n        emit!(ConfigModifiedSecurely { config: config.key() });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ModifyWithVerifiedPermissions<'info> {\n    pub config: AccountInfo<'info>,\n}\n\n#[account]\npub struct ConfigData {\n    pub version: u32,\n}\n\n#[event]\npub struct ConfigModifiedSecurely {\n    pub config: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability: V6 - Unchecked External Calls\nAnalysis: Safe: The config account ownership and data format are verified before CPI. The account can only be modified by trusted external programs and only in valid states.\nRisk Level: âœ… LOW\nValidation: Account owner and data format verified before CPI",
    "meta_platform": "Solana",
    "meta_vuln_type": "V6 - Unchecked External Calls",
    "meta_pattern": "Verified Mutable Account Permissions"
  }
]
