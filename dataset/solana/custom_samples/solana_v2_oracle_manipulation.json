[
  {
    "sample_id": "SOL_V2_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn borrow_with_oracle(\n        ctx: Context<BorrowWithOracle>,\n        amount: u64,\n    ) -> Result<()> {\n        let oracle_account = &ctx.accounts.oracle;\n        let borrower = &ctx.accounts.borrower;\n        let lending_state = &mut ctx.accounts.lending_state;\n        // Deserialize without validating oracle account ownership\n        let price_data = PriceData::try_from_slice(\n            &oracle_account.data.borrow()\n        )?;\n        let collateral_value = borrower.collateral_amount * price_data.price;\n        let max_borrow = collateral_value / 2;\n        require!(\n            amount <= max_borrow,\n            LendingError::InsufficientCollateral\n        );\n        lending_state.borrowed_amount = amount;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct BorrowWithOracle<'info> {\n    pub oracle: AccountInfo<'info>,\n    #[account(mut)]\n    pub borrower: Account<'info, BorrowerState>,\n    #[account(mut)]\n    pub lending_state: Account<'info, LendingState>,\n}\n\n#[account]\npub struct BorrowerState {\n    pub collateral_amount: u64,\n}\n\n#[account]\npub struct LendingState {\n    pub borrowed_amount: u64,\n}\n\npub struct PriceData {\n    pub price: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Missing Account Owner Check\nDescription: The contract deserializes price data from an oracle account without verifying that the account is owned by a trusted oracle program. An attacker can pass a fake oracle account with arbitrary price data, causing the contract to accept invalid collateral valuations and enabling unauthorized borrowing.\nRisk Level: CRITICAL\nRecommendation: Verify oracle account ownership: require!(oracle.owner == TRUSTED_ORACLE_PROGRAM_ID, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Missing Oracle Account Owner Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn check_liquidation_price(\n        ctx: Context<CheckLiquidation>,\n    ) -> Result<()> {\n        let oracle_feed = &ctx.accounts.oracle_feed;\n        let vault = &mut ctx.accounts.vault;\n        // Load price without checking timestamp freshness\n        let feed_data = OracleFeed::try_from_slice(\n            &oracle_feed.data.borrow()\n        )?;\n        let current_price = feed_data.price;\n        if current_price < vault.liquidation_threshold {\n            vault.is_liquidatable = true;\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CheckLiquidation<'info> {\n    pub oracle_feed: AccountInfo<'info>,\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n}\n\n#[account]\npub struct Vault {\n    pub liquidation_threshold: u64,\n    pub is_liquidatable: bool,\n}\n\npub struct OracleFeed {\n    pub price: u64,\n    pub timestamp: i64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Missing Timestamp Freshness Check\nDescription: The contract reads the oracle price without validating the timestamp. An attacker or compromised oracle can provide stale price data from hours or days ago, causing incorrect liquidation decisions based on outdated prices.\nRisk Level: CRITICAL\nRecommendation: Verify timestamp freshness: require!(now - feed_data.timestamp <= MAX_STALENESS, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Missing Oracle Timestamp Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn calculate_swap_output(\n        ctx: Context<SwapAmm>,\n        amount_in: u64,\n    ) -> Result<()> {\n        let amm_pool = &ctx.accounts.amm_pool;\n        let user = &ctx.accounts.user;\n        // Use spot price directly without protection\n        let reserve_x = amm_pool.reserve_x;\n        let reserve_y = amm_pool.reserve_y;\n        let spot_price = reserve_y / reserve_x;\n        let amount_out = amount_in * spot_price;\n        emit!(SwapExecuted {\n            user: user.key(),\n            amount_in,\n            amount_out,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SwapAmm<'info> {\n    #[account(mut)]\n    pub amm_pool: Account<'info, AmmPool>,\n    #[account(mut)]\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct AmmPool {\n    pub reserve_x: u64,\n    pub reserve_y: u64,\n}\n\n#[event]\npub struct SwapExecuted {\n    pub user: Pubkey,\n    pub amount_in: u64,\n    pub amount_out: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Spot Price Manipulation Vulnerability\nDescription: The contract uses AMM spot price directly for swap calculations without protection. This enables flash loan attacks where an attacker inflates reserves in the same transaction, manipulates the spot price, and extracts value from the pool.\nRisk Level: CRITICAL\nRecommendation: Use TWAP (Time-Weighted Average Price) or external oracle price: let safe_price = calculate_twap(...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Spot Price Flash Loan Vulnerability"
  },
  {
    "sample_id": "SOL_V2_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn execute_liquidation(\n        ctx: Context<ExecuteLiquidation>,\n    ) -> Result<()> {\n        let oracle_data = &ctx.accounts.oracle_data;\n        let vault = &mut ctx.accounts.vault;\n        let liquidator = &ctx.accounts.liquidator;\n        // Parse price without checking confidence interval\n        let oracle_struct = OracleStruct::try_from_slice(\n            &oracle_data.data.borrow()\n        )?;\n        let current_price = oracle_struct.price;\n        if current_price < 100 {\n            vault.is_liquidatable = true;\n            emit!(LiquidationTriggered {\n                vault: vault.key(),\n                price: current_price,\n            });\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteLiquidation<'info> {\n    pub oracle_data: AccountInfo<'info>,\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    pub liquidator: Signer<'info>,\n}\n\n#[account]\npub struct Vault {\n    pub is_liquidatable: bool,\n    pub position_value: u64,\n}\n\npub struct OracleStruct {\n    pub price: u64,\n    pub confidence: u64,\n    pub timestamp: i64,\n}\n\n#[event]\npub struct LiquidationTriggered {\n    pub vault: Pubkey,\n    pub price: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Missing Confidence Interval Check\nDescription: The contract uses the oracle price without validating its confidence interval. During high volatility, the oracle may report a wide confidence range, making the price unreliable for critical operations like liquidations.\nRisk Level: CRITICAL\nRecommendation: Verify confidence interval: require!(oracle_struct.confidence < MAX_ACCEPTABLE_CONFIDENCE, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Missing Oracle Confidence Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst NEW_ORACLE_UPDATE_SEED: &[u8] = b\"update_oracle\";\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn update_oracle_address(\n        ctx: Context<UpdateOracleConfig>,\n        new_oracle_pubkey: Pubkey,\n    ) -> Result<()> {\n        let config = &mut ctx.accounts.config;\n        let updater = &ctx.accounts.updater;\n        // Missing access control - anyone can update oracle\n        config.primary_oracle = new_oracle_pubkey;\n        emit!(OracleAddressUpdated {\n            old_oracle: config.primary_oracle,\n            new_oracle: new_oracle_pubkey,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UpdateOracleConfig<'info> {\n    #[account(mut)]\n    pub config: Account<'info, OracleConfig>,\n    pub updater: Signer<'info>,\n}\n\n#[account]\npub struct OracleConfig {\n    pub primary_oracle: Pubkey,\n    pub backup_oracle: Pubkey,\n    pub admin: Pubkey,\n}\n\n#[event]\npub struct OracleAddressUpdated {\n    pub old_oracle: Pubkey,\n    pub new_oracle: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Missing Access Control on Oracle Update\nDescription: The contract allows anyone to update the oracle address without validation. An attacker can replace the trusted oracle with their own malicious oracle program, gaining complete control over all price feeds used by the contract.\nRisk Level: CRITICAL\nRecommendation: Verify admin authority: require!(updater.key() == config.admin, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Missing Oracle Update Authorization"
  },
  {
    "sample_id": "SOL_V2_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn get_asset_price(\n        ctx: Context<GetAssetPrice>,\n    ) -> Result<u64> {\n        let feed_account = &ctx.accounts.feed;\n        let state = &mut ctx.accounts.state;\n        // Hardcoded decimal assumptions without validation\n        let raw_data = feed_account.data.borrow();\n        let raw_price = u64::from_le_bytes(\n            raw_data[8..16].try_into().unwrap()\n        );\n        // Assumes 6 decimals, unsafe for different feeds\n        let normalized_price = raw_price / 1_000_000;\n        state.cached_price = normalized_price;\n        msg!(\"Price fetched: {}\", normalized_price);\n        Ok(normalized_price)\n    }\n}\n\n#[derive(Accounts)]\npub struct GetAssetPrice<'info> {\n    pub feed: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: Account<'info, PriceState>,\n}\n\n#[account]\npub struct PriceState {\n    pub cached_price: u64,\n    pub last_update: i64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Hardcoded Decimal Assumptions\nDescription: The contract assumes all oracle feeds use 6 decimals without verification. Different oracle sources may use different decimal places, causing extreme mispricing when handling feeds with different precision levels.\nRisk Level: CRITICAL\nRecommendation: Fetch decimals from oracle metadata: let decimals = oracle_feed.decimals; let price = raw_price / 10^decimals",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Incorrect Oracle Decimal Handling"
  },
  {
    "sample_id": "SOL_V2_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn lending_with_unverified_price(\n        ctx: Context<LendingOperation>,\n        amount: u64,\n    ) -> Result<()> {\n        let price_input = &ctx.accounts.price_input;\n        let user = &ctx.accounts.user;\n        let lending_vault = &mut ctx.accounts.vault;\n        // VULNERABLE: Trusts price directly from user-supplied account\n        let user_price = PriceInput::try_from_slice(\n            &price_input.data.borrow()\n        )?;\n        let collateral_value = user.collateral * user_price.price_value;\n        require!(\n            collateral_value >= amount,\n            LendingError::InsufficientCollateral\n        );\n        lending_vault.amount_lent += amount;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct LendingOperation<'info> {\n    pub price_input: AccountInfo<'info>,\n    #[account(mut)]\n    pub user: Account<'info, UserAccount>,\n    #[account(mut)]\n    pub vault: Account<'info, LendingVault>,\n}\n\n#[account]\npub struct UserAccount {\n    pub collateral: u64,\n}\n\n#[account]\npub struct LendingVault {\n    pub amount_lent: u64,\n}\n\npub struct PriceInput {\n    pub price_value: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Unverified User-Supplied Price\nDescription: The contract accepts price data directly from a user-supplied account without verification against any trusted oracle. An attacker can create an account with arbitrary prices and use it to borrow funds with fake collateral valuations.\nRisk Level: CRITICAL\nRecommendation: Only accept prices from trusted oracle accounts: require!(price_input.owner == TRUSTED_ORACLE, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Unverified Oracle Source"
  },
  {
    "sample_id": "SOL_V2_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn complex_oracle_calculation(\n        ctx: Context<ComplexOracleCalc>,\n    ) -> Result<()> {\n        let oracle_info = &ctx.accounts.oracle;\n        let state = &mut ctx.accounts.state;\n        // Deserialize without validating account ownership\n        let oracle_data = OracleData::try_from_slice(\n            &oracle_info.data.borrow()\n        )?;\n        if oracle_data.last_updated < 0 {\n            return Ok(());\n        }\n        let calculated_value = oracle_data.price * 2 + 100;\n        state.value = calculated_value;\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ComplexOracleCalc<'info> {\n    pub oracle: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: Account<'info, State>,\n}\n\n#[account]\npub struct State {\n    pub value: u64,\n}\n\npub struct OracleData {\n    pub price: u64,\n    pub last_updated: i64,\n    pub program_authority: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Missing Account Owner Verification\nDescription: The contract deserializes oracle data without checking if the account is owned by the trusted oracle program. This enables oracle spoofing attacks where an attacker creates a fake oracle account with manipulated data.\nRisk Level: CRITICAL\nRecommendation: Verify oracle program ownership: require!(oracle.owner == ORACLE_PROGRAM_ID, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Oracle Account Owner Not Verified"
  },
  {
    "sample_id": "SOL_V2_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn execute_trade_at_last_price(\n        ctx: Context<ExecuteTrade>,\n        trade_amount: u64,\n    ) -> Result<()> {\n        let pair = &ctx.accounts.trading_pair;\n        let executor = &ctx.accounts.executor;\n        let vault = &mut ctx.accounts.vault;\n        // Use last_trade_price which can be manipulated\n        let current_price = pair.last_trade_price;\n        let output_amount = trade_amount * current_price / 1000;\n        vault.balance += output_amount;\n        emit!(TradeExecuted {\n            executor: executor.key(),\n            amount: trade_amount,\n            price: current_price,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ExecuteTrade<'info> {\n    #[account(mut)]\n    pub trading_pair: Account<'info, TradingPair>,\n    pub executor: Signer<'info>,\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n}\n\n#[account]\npub struct TradingPair {\n    pub last_trade_price: u64,\n    pub reserve_a: u64,\n    pub reserve_b: u64,\n}\n\n#[account]\npub struct Vault {\n    pub balance: u64,\n}\n\n#[event]\npub struct TradeExecuted {\n    pub executor: Pubkey,\n    pub amount: u64,\n    pub price: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Last Trade Price Manipulation\nDescription: The contract uses the last_trade_price which can be manipulated by a single attacker-controlled trade. An attacker can execute a large trade at an artificial price in the same or previous block, then use that price for subsequent operations.\nRisk Level: CRITICAL\nRecommendation: Use TWAP or external oracle price instead: let safe_price = calculate_twap_or_use_external_oracle(...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Last Trade Price Vulnerability"
  },
  {
    "sample_id": "SOL_V2_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_oracle {\n    use super::*;\n\n    pub fn check_and_update_sol_price(\n        ctx: Context<CheckSolPrice>,\n    ) -> Result<()> {\n        let oracle_feed = &ctx.accounts.oracle_feed;\n        let state = &mut ctx.accounts.state;\n        let feed_data = OracleFeed::try_from_slice(\n            &oracle_feed.data.borrow()\n        )?;\n        let now = Clock::get()?.unix_timestamp;\n        // VULNERABLE: 24-hour threshold is too lenient\n        if now - feed_data.timestamp < 86400 {\n            state.current_price = feed_data.price;\n            msg!(\"Price accepted: {}\", feed_data.price);\n        } else {\n            msg!(\"Price too stale\");\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CheckSolPrice<'info> {\n    pub oracle_feed: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: Account<'info, PriceState>,\n}\n\n#[account]\npub struct PriceState {\n    pub current_price: u64,\n    pub last_updated: i64,\n}\n\npub struct OracleFeed {\n    pub price: u64,\n    pub timestamp: i64,\n    pub confidence: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Oracle Validation - Overly Lenient Staleness Threshold\nDescription: The contract allows prices up to 24 hours old before rejecting them. For volatile assets like SOL, a price from 24 hours ago can be drastically different from the current price, making financial decisions based on such stale data extremely risky.\nRisk Level: CRITICAL\nRecommendation: Use stricter timestamp validation: require!(now - feed_data.timestamp <= MAX_STALENESS_SECONDS, ...) where MAX_STALENESS_SECONDS is 60-300",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Excessively Lenient Staleness Threshold"
  }
]
[
  {
    "sample_id": "SOL_V2_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst TRUSTED_ORACLE_PROGRAM: &str = \"11111111111111111111111111111111\";\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn borrow_with_safe_oracle(\n        ctx: Context<SafeBorrowWithOracle>,\n        amount: u64,\n    ) -> Result<()> {\n        let oracle_account = &ctx.accounts.oracle;\n        let borrower = &ctx.accounts.borrower;\n        let lending_state = &mut ctx.accounts.lending_state;\n        // SECURE: Verify oracle account ownership\n        require!(\n            oracle_account.owner == Pubkey::from_str(TRUSTED_ORACLE_PROGRAM)\n                .unwrap(),\n            LendingError::UntrustedOracle\n        );\n        let price_data = PriceData::try_from_slice(\n            &oracle_account.data.borrow()\n        )?;\n        let collateral_value = borrower.collateral_amount * price_data.price;\n        let max_borrow = collateral_value / 2;\n        require!(\n            amount <= max_borrow,\n            LendingError::InsufficientCollateral\n        );\n        lending_state.borrowed_amount = amount;\n        emit!(BorrowApproved {\n            borrower: borrower.key(),\n            amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SafeBorrowWithOracle<'info> {\n    pub oracle: AccountInfo<'info>,\n    #[account(mut)]\n    pub borrower: Account<'info, BorrowerState>,\n    #[account(mut)]\n    pub lending_state: Account<'info, LendingState>,\n}\n\n#[account]\npub struct BorrowerState {\n    pub collateral_amount: u64,\n}\n\n#[account]\npub struct LendingState {\n    pub borrowed_amount: u64,\n}\n\npub struct PriceData {\n    pub price: u64,\n}\n\n#[event]\npub struct BorrowApproved {\n    pub borrower: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Oracle Validation Properly Implemented\nDescription: The contract verifies that the oracle account is owned by a trusted oracle program before deserializing price data. This prevents oracle spoofing attacks where attackers could supply fake oracle accounts.\nRisk Level: LOW\nValidation: Oracle account ownership verified against hardcoded trusted program ID",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Oracle Account Owner Verification"
  },
  {
    "sample_id": "SOL_V2_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_STALENESS_SECONDS: i64 = 60;\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn check_liquidation_with_fresh_price(\n        ctx: Context<SafeCheckLiquidation>,\n    ) -> Result<()> {\n        let oracle_feed = &ctx.accounts.oracle_feed;\n        let vault = &mut ctx.accounts.vault;\n        let feed_data = OracleFeed::try_from_slice(\n            &oracle_feed.data.borrow()\n        )?;\n        let now = Clock::get()?.unix_timestamp;\n        // SECURE: Verify timestamp freshness\n        require!(\n            now - feed_data.timestamp <= MAX_STALENESS_SECONDS,\n            OracleError::StalePrice\n        );\n        let current_price = feed_data.price;\n        if current_price < vault.liquidation_threshold {\n            vault.is_liquidatable = true;\n            emit!(LiquidationApproved {\n                vault: vault.key(),\n                price: current_price,\n            });\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SafeCheckLiquidation<'info> {\n    pub oracle_feed: AccountInfo<'info>,\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n}\n\n#[account]\npub struct Vault {\n    pub liquidation_threshold: u64,\n    pub is_liquidatable: bool,\n}\n\npub struct OracleFeed {\n    pub price: u64,\n    pub timestamp: i64,\n}\n\n#[event]\npub struct LiquidationApproved {\n    pub vault: Pubkey,\n    pub price: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Timestamp Freshness Validated\nDescription: The contract enforces a 60-second maximum staleness threshold, ensuring that only recent price data is accepted for liquidation decisions. This prevents the use of stale price data that could lead to incorrect liquidations.\nRisk Level: LOW\nValidation: Timestamp freshness check enforces MAX_STALENESS_SECONDS limit",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Timestamp Freshness Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn calculate_swap_with_twap(\n        ctx: Context<SafeSwapAmm>,\n        amount_in: u64,\n    ) -> Result<()> {\n        let amm_pool = &ctx.accounts.amm_pool;\n        let user = &ctx.accounts.user;\n        let oracle = &ctx.accounts.oracle;\n        // SECURE: Use TWAP instead of spot price\n        let twap_price = calculate_safe_twap(\n            &amm_pool.observations,\n            1800\n        )?;\n        let amount_out = amount_in * twap_price / 10000;\n        require!(\n            amount_out > 0,\n            SwapError::InsufficientOutput\n        );\n        emit!(SwapExecutedSafely {\n            user: user.key(),\n            amount_in,\n            amount_out,\n            price_used: twap_price,\n        });\n        Ok(())\n    }\n}\n\npub fn calculate_safe_twap(\n    observations: &[PriceObservation],\n    window: u64,\n) -> Result<u64> {\n    require!(!observations.is_empty(), OracleError::NoObservations);\n    let weighted_sum: u128 = observations\n        .iter()\n        .map(|obs| obs.price as u128 * obs.weight as u128)\n        .sum();\n    let total_weight: u128 = observations.iter().map(|o| o.weight as u128).sum();\n    Ok((weighted_sum / total_weight) as u64)\n}\n\n#[derive(Accounts)]\npub struct SafeSwapAmm<'info> {\n    #[account(mut)]\n    pub amm_pool: Account<'info, AmmPool>,\n    pub oracle: AccountInfo<'info>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct AmmPool {\n    pub reserve_x: u64,\n    pub reserve_y: u64,\n    pub observations: Vec<PriceObservation>,\n}\n\npub struct PriceObservation {\n    pub price: u64,\n    pub weight: u64,\n}\n\n#[event]\npub struct SwapExecutedSafely {\n    pub user: Pubkey,\n    pub amount_in: u64,\n    pub amount_out: u64,\n    pub price_used: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - TWAP Price Protection\nDescription: The contract uses Time-Weighted Average Price (TWAP) instead of spot price, protecting against flash loan attacks. The TWAP calculation weights multiple observations over a 30-minute window, making manipulation expensive and impractical.\nRisk Level: LOW\nValidation: Uses weighted average price calculation over observation history",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "TWAP-Based Price Protection"
  },
  {
    "sample_id": "SOL_V2_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_ACCEPTABLE_CONFIDENCE: u64 = 1000; // 1% of price\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn execute_liquidation_safely(\n        ctx: Context<SafeExecuteLiquidation>,\n    ) -> Result<()> {\n        let oracle_data = &ctx.accounts.oracle_data;\n        let vault = &mut ctx.accounts.vault;\n        let liquidator = &ctx.accounts.liquidator;\n        let oracle_struct = OracleStruct::try_from_slice(\n            &oracle_data.data.borrow()\n        )?;\n        let current_price = oracle_struct.price;\n        // SECURE: Verify confidence interval\n        require!(\n            oracle_struct.confidence < MAX_ACCEPTABLE_CONFIDENCE,\n            OracleError::LowConfidence\n        );\n        // SECURE: Verify timestamp freshness\n        let now = Clock::get()?.unix_timestamp;\n        require!(\n            now - oracle_struct.timestamp <= 120,\n            OracleError::StaleData\n        );\n        if current_price < vault.liquidation_threshold {\n            vault.is_liquidatable = true;\n            vault.liquidated_by = liquidator.key();\n            emit!(LiquidationSafelyTriggered {\n                vault: vault.key(),\n                price: current_price,\n                confidence: oracle_struct.confidence,\n            });\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SafeExecuteLiquidation<'info> {\n    pub oracle_data: AccountInfo<'info>,\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n    pub liquidator: Signer<'info>,\n}\n\n#[account]\npub struct Vault {\n    pub is_liquidatable: bool,\n    pub position_value: u64,\n    pub liquidated_by: Pubkey,\n}\n\npub struct OracleStruct {\n    pub price: u64,\n    pub confidence: u64,\n    pub timestamp: i64,\n}\n\n#[event]\npub struct LiquidationSafelyTriggered {\n    pub vault: Pubkey,\n    pub price: u64,\n    pub confidence: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Confidence and Freshness Validated\nDescription: The contract validates both the confidence interval and timestamp freshness before using oracle data. This ensures that price data is not only fresh but also accurate, preventing liquidations based on unreliable or uncertain price information.\nRisk Level: LOW\nValidation: Confidence interval < 1% of price AND timestamp within 2 minutes",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Confidence and Timestamp Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn update_oracle_address_safely(\n        ctx: Context<SafeUpdateOracleConfig>,\n        new_oracle_pubkey: Pubkey,\n    ) -> Result<()> {\n        let config = &mut ctx.accounts.config;\n        let updater = &ctx.accounts.updater;\n        // SECURE: Verify admin authority before updating oracle\n        require!(\n            updater.key() == config.admin,\n            OracleConfigError::UnauthorizedAdmin\n        );\n        require!(\n            updater.is_signer,\n            OracleConfigError::MissingSigner\n        );\n        let old_oracle = config.primary_oracle;\n        config.primary_oracle = new_oracle_pubkey;\n        emit!(OracleAddressUpdatedSecurely {\n            updated_by: updater.key(),\n            old_oracle,\n            new_oracle: new_oracle_pubkey,\n            timestamp: Clock::get()?.unix_timestamp,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SafeUpdateOracleConfig<'info> {\n    #[account(mut)]\n    pub config: Account<'info, OracleConfig>,\n    pub updater: Signer<'info>,\n}\n\n#[account]\npub struct OracleConfig {\n    pub primary_oracle: Pubkey,\n    pub backup_oracle: Pubkey,\n    pub admin: Pubkey,\n}\n\n#[event]\npub struct OracleAddressUpdatedSecurely {\n    pub updated_by: Pubkey,\n    pub old_oracle: Pubkey,\n    pub new_oracle: Pubkey,\n    pub timestamp: i64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Admin Authorization Enforced\nDescription: The contract enforces strict access control on oracle address updates, requiring that only the designated admin can modify the oracle configuration. This prevents attackers from replacing the trusted oracle with a malicious one.\nRisk Level: LOW\nValidation: Admin identity and signer validation required before oracle update",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Admin-Only Oracle Update"
  },
  {
    "sample_id": "SOL_V2_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn get_asset_price_with_decimals(\n        ctx: Context<SafeGetAssetPrice>,\n    ) -> Result<u64> {\n        let feed_account = &ctx.accounts.feed;\n        let state = &mut ctx.accounts.state;\n        // SECURE: Fetch and use actual decimals from oracle\n        let raw_data = feed_account.data.borrow();\n        let raw_price = u64::from_le_bytes(\n            raw_data[8..16].try_into().unwrap()\n        );\n        let decimals = u8::from_le_bytes(\n            raw_data[16..17].try_into().unwrap()\n        );\n        // Use actual decimals instead of hardcoded value\n        let divisor = 10u64.pow(decimals as u32);\n        let normalized_price = raw_price / divisor;\n        state.cached_price = normalized_price;\n        emit!(PriceFetchedWithCorrectDecimals {\n            price: normalized_price,\n            decimals,\n        });\n        Ok(normalized_price)\n    }\n}\n\n#[derive(Accounts)]\npub struct SafeGetAssetPrice<'info> {\n    pub feed: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: Account<'info, PriceState>,\n}\n\n#[account]\npub struct PriceState {\n    pub cached_price: u64,\n    pub last_update: i64,\n}\n\n#[event]\npub struct PriceFetchedWithCorrectDecimals {\n    pub price: u64,\n    pub decimals: u8,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Correct Decimal Handling\nDescription: The contract dynamically fetches the decimal precision from the oracle feed metadata rather than assuming a hardcoded value. This ensures accurate price normalization regardless of the oracle's decimal configuration.\nRisk Level: LOW\nValidation: Decimals fetched from oracle and used for proper price normalization",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Dynamic Decimal Handling"
  },
  {
    "sample_id": "SOL_V2_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst TRUSTED_ORACLE_PROGRAM_ID: &str = \"pythFDtsPrZTTmMoopBTPoVRgDj5NSKmRv6T4YPwT5M\";\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn lending_with_trusted_oracle(\n        ctx: Context<SafeLendingOperation>,\n        amount: u64,\n    ) -> Result<()> {\n        let price_account = &ctx.accounts.price_account;\n        let user = &ctx.accounts.user;\n        let lending_vault = &mut ctx.accounts.vault;\n        // SECURE: Verify oracle account owner before using\n        require!(\n            price_account.owner == Pubkey::from_str(TRUSTED_ORACLE_PROGRAM_ID)\n                .unwrap(),\n            LendingError::InvalidOracleSource\n        );\n        let price = PriceInput::try_from_slice(\n            &price_account.data.borrow()\n        )?;\n        let collateral_value = user.collateral * price.price_value;\n        require!(\n            collateral_value >= amount,\n            LendingError::InsufficientCollateral\n        );\n        lending_vault.amount_lent += amount;\n        emit!(LoanIssuedSafely {\n            user: user.key(),\n            amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SafeLendingOperation<'info> {\n    pub price_account: AccountInfo<'info>,\n    #[account(mut)]\n    pub user: Account<'info, UserAccount>,\n    #[account(mut)]\n    pub vault: Account<'info, LendingVault>,\n}\n\n#[account]\npub struct UserAccount {\n    pub collateral: u64,\n}\n\n#[account]\npub struct LendingVault {\n    pub amount_lent: u64,\n}\n\npub struct PriceInput {\n    pub price_value: u64,\n}\n\n#[event]\npub struct LoanIssuedSafely {\n    pub user: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Trusted Oracle Source Verified\nDescription: The contract verifies that price data comes from a trusted oracle program (Pyth) by checking account ownership. This prevents attacks where users supply fake price accounts with arbitrary values.\nRisk Level: LOW\nValidation: Oracle account owner matches trusted Pyth program ID",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Trusted Oracle Verification"
  },
  {
    "sample_id": "SOL_V2_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn execute_trade_with_price_bounds(\n        ctx: Context<SafeExecuteTrade>,\n        trade_amount: u64,\n    ) -> Result<()> {\n        let pair = &ctx.accounts.trading_pair;\n        let executor = &ctx.accounts.executor;\n        let vault = &mut ctx.accounts.vault;\n        let oracle = &ctx.accounts.oracle;\n        // Get oracle price\n        let oracle_price = fetch_trusted_oracle_price(oracle)?;\n        // Get current price and implement circuit breaker\n        let last_price = pair.last_trade_price;\n        let upper_bound = last_price * 110 / 100;\n        let lower_bound = last_price * 90 / 100;\n        // SECURE: Verify price is within reasonable bounds\n        require!(\n            oracle_price >= lower_bound && oracle_price <= upper_bound,\n            TradeError::SuspiciousPrice\n        );\n        let output_amount = trade_amount * oracle_price / 1000;\n        vault.balance += output_amount;\n        emit!(TradeSafelyExecuted {\n            executor: executor.key(),\n            amount: trade_amount,\n            price: oracle_price,\n        });\n        Ok(())\n    }\n}\n\nfn fetch_trusted_oracle_price(oracle: &AccountInfo) -> Result<u64> {\n    let data = oracle.data.borrow();\n    Ok(u64::from_le_bytes(data[0..8].try_into()?))\n}\n\n#[derive(Accounts)]\npub struct SafeExecuteTrade<'info> {\n    #[account(mut)]\n    pub trading_pair: Account<'info, TradingPair>,\n    pub oracle: AccountInfo<'info>,\n    pub executor: Signer<'info>,\n    #[account(mut)]\n    pub vault: Account<'info, Vault>,\n}\n\n#[account]\npub struct TradingPair {\n    pub last_trade_price: u64,\n    pub reserve_a: u64,\n    pub reserve_b: u64,\n}\n\n#[account]\npub struct Vault {\n    pub balance: u64,\n}\n\n#[event]\npub struct TradeSafelyExecuted {\n    pub executor: Pubkey,\n    pub amount: u64,\n    pub price: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Price Circuit Breaker Implemented\nDescription: The contract uses a price circuit breaker that rejects trades if the oracle price deviates more than 10% from the last trade price. This prevents use of manipulated or flash-loan-influenced prices for critical operations.\nRisk Level: LOW\nValidation: Oracle price checked against Â±10% bounds relative to last trade price",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Price Circuit Breaker"
  },
  {
    "sample_id": "SOL_V2_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn validate_price_with_dual_oracle(\n        ctx: Context<SafeDualOracleValidation>,\n    ) -> Result<()> {\n        let oracle_a = &ctx.accounts.oracle_a;\n        let oracle_b = &ctx.accounts.oracle_b;\n        // SECURE: Use dual-oracle validation\n        let price_a = fetch_oracle_price(oracle_a)?;\n        let price_b = fetch_oracle_price(oracle_b)?;\n        // Verify prices are within acceptable deviation\n        let max_deviation = price_a / 20; // 5% max deviation\n        let price_diff = if price_a > price_b {\n            price_a - price_b\n        } else {\n            price_b - price_a\n        };\n        require!(\n            price_diff <= max_deviation,\n            OracleError::PriceDivergenceTooHigh\n        );\n        // Use average price\n        let consensus_price = (price_a + price_b) / 2;\n        emit!(DualOraclePriceValidated {\n            price_a,\n            price_b,\n            consensus_price,\n        });\n        Ok(())\n    }\n}\n\nfn fetch_oracle_price(oracle: &AccountInfo) -> Result<u64> {\n    let data = oracle.data.borrow();\n    Ok(u64::from_le_bytes(data[0..8].try_into()?))\n}\n\n#[derive(Accounts)]\npub struct SafeDualOracleValidation<'info> {\n    pub oracle_a: AccountInfo<'info>,\n    pub oracle_b: AccountInfo<'info>,\n}\n\n#[event]\npub struct DualOraclePriceValidated {\n    pub price_a: u64,\n    pub price_b: u64,\n    pub consensus_price: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Dual-Oracle Consensus\nDescription: The contract uses two independent oracle sources and verifies that their prices are within 5% of each other. If one oracle is compromised or manipulated, the price divergence check will catch it, providing protection against single-oracle failure.\nRisk Level: LOW\nValidation: Dual-oracle prices must converge within 5% deviation",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Dual-Oracle Consensus Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for oracle manipulation vulnerabilities. Identify if the code properly validates oracle account ownership, data freshness, and confidence intervals. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_STALENESS_SECONDS: i64 = 120;\n\n#[program]\npub mod secure_oracle {\n    use super::*;\n\n    pub fn check_price_with_strict_validation(\n        ctx: Context<SafeCheckPrice>,\n    ) -> Result<()> {\n        let oracle_feed = &ctx.accounts.oracle_feed;\n        let state = &mut ctx.accounts.state;\n        let feed_data = OracleFeed::try_from_slice(\n            &oracle_feed.data.borrow()\n        )?;\n        let now = Clock::get()?.unix_timestamp;\n        // SECURE: Strict timestamp validation (2 minutes max)\n        require!(\n            now - feed_data.timestamp <= MAX_STALENESS_SECONDS,\n            OracleError::StalePrice\n        );\n        // SECURE: Verify confidence interval\n        require!(\n            feed_data.confidence < feed_data.price / 100,\n            OracleError::LowConfidence\n        );\n        state.current_price = feed_data.price;\n        state.last_updated = now;\n        emit!(PriceUpdatedWithStrictValidation {\n            price: feed_data.price,\n            timestamp: now,\n            age_seconds: now - feed_data.timestamp,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct SafeCheckPrice<'info> {\n    pub oracle_feed: AccountInfo<'info>,\n    #[account(mut)]\n    pub state: Account<'info, PriceState>,\n}\n\n#[account]\npub struct PriceState {\n    pub current_price: u64,\n    pub last_updated: i64,\n}\n\npub struct OracleFeed {\n    pub price: u64,\n    pub timestamp: i64,\n    pub confidence: u64,\n}\n\n#[event]\npub struct PriceUpdatedWithStrictValidation {\n    pub price: u64,\n    pub timestamp: i64,\n    pub age_seconds: i64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Strict Staleness and Confidence Validation\nDescription: The contract enforces a strict 2-minute maximum staleness threshold and verifies that the oracle's confidence interval is less than 1% of the reported price. This ensures that only accurate, fresh data is accepted for critical operations.\nRisk Level: LOW\nValidation: Timestamp within 120 seconds AND confidence < 1% of price",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation",
    "meta_pattern": "Strict Staleness and Confidence Validation"
  }
]
