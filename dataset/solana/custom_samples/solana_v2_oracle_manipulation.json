[
  {
    "sample_id": "SOL_V2_VULN_001",
    "instruction": "You are a smart contract security analyzer. Identify vulnerabilities in the provided Rust smart contract.",
    "input": "pub fn borrow_money(ctx: Context<Borrow>, amount: u64) -> Result<()> {\n    let oracle_account = &ctx.accounts.oracle;\n    // VULN: No check that oracle_account.owner == trusted program\n    let price_data = PriceData::try_from_slice(&oracle_account.data.borrow())?;\n    let max_borrow = price_data.price * 50;\n    require!(amount <= max_borrow, CustomError::InsufficientCollateral);\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: The contract deserializes oracle data without verifying the account owner, allowing attackers to pass fake oracle accounts.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_002",
    "instruction": "Analyze the following smart contract for oracle issues.",
    "input": "pub fn check_price(ctx: Context<CheckPrice>) -> Result<()> {\n    let p = load_price_feed_from_account_info(&ctx.accounts.price_feed).unwrap();\n    // VULN: Uses unchecked price; ignores staleness timestamp\n    let current_price = p.get_price_unchecked();\n    msg!(\"Price: {}\", current_price.price);\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Uses 'get_price_unchecked()' without checking oracle timestamp, allowing stale data to be accepted.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_003",
    "instruction": "Analyze the following code.",
    "input": "pub fn swap_tokens(ctx: Context<Swap>, amount_in: u64) -> Result<()> {\n    let rx = ctx.accounts.pool.reserve_x;\n    let ry = ctx.accounts.pool.reserve_y;\n    // VULN: Price = spot ratio; vulnerable to flash loan manipulation\n    let price = ry / rx;\n    let amount_out = amount_in * price;\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Uses AMM spot price directly, enabling flash-loan or sandwich manipulation.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_004",
    "instruction": "Analyze for vulnerabilities.",
    "input": "pub fn liquidate(ctx: Context<Liquidate>) -> Result<()> {\n    let oracle_data = &ctx.accounts.oracle;\n    // VULN: No confidence interval check\n    let price = parse_price(oracle_data)?;\n    if price < 100 { /* liquidate */ }\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Ignores oracle confidence interval; highly inaccurate during volatility.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_005",
    "instruction": "Detect oracle validation issues.",
    "input": "pub fn update_oracle(ctx: Context<UpdateConfig>, new_oracle: Pubkey) -> Result<()> {\n    // VULN: Anyone can update oracle address\n    ctx.accounts.config.oracle_address = new_oracle;\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Missing access control allows attackers to replace the trusted oracle with a malicious one.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_006",
    "instruction": "Analyze the following price code.",
    "input": "pub fn get_asset_price(ctx: Context<GetPrice>) -> Result<u64> {\n    let feed = &ctx.accounts.feed;\n    // VULN: Assumes fixed decimals; unsafe\n    let raw_price = feed.read_u64(8);\n    let price = raw_price / 1000000;\n    Ok(price)\n}",
    "output": "Status: VULNERABLE\nDescription: Incorrect handling of oracle decimals; may cause extreme mispricing.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_007",
    "instruction": "Analyze security of oracle usage.",
    "input": "pub fn lend(ctx: Context<Lend>, amount: u64) -> Result<()> {\n    // VULN: Blindly trusting user-supplied price\n    let price = ctx.accounts.user_input.price;\n    let value = ctx.accounts.user.collateral * price;\n    require!(value > amount, MyError::Undercollateralized);\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Accepts price directly from user input structure without verification against a trusted oracle.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_008",
    "instruction": "Analyze the following oracle code.",
    "input": "pub fn complex_calc(ctx: Context<Calc>) -> Result<()> {\n    let info = &ctx.accounts.oracle;\n    // VULN: No owner check; data may come from fake oracle program\n    let data = OracleStruct::try_from_slice(&info.data.borrow())?;\n    if data.last_updated < 0 { return Ok(()); }\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Does not verify that oracle account is owned by the trusted program, making oracle spoofing possible.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_009",
    "instruction": "Analyze smart contract code for oracle issues.",
    "input": "pub fn execute_trade(ctx: Context<Trade>) -> Result<()> {\n    // VULN: Using last trade price which can be manipulated\n    let price = ctx.accounts.pair.last_trade_price;\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Relies on last trade price which can be manipulated by a small attacker-controlled trade.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_VULN_010",
    "instruction": "Analyze oracle timestamp handling.",
    "input": "pub fn check_sol_price(ctx: Context<Check>) -> Result<()> {\n    let feed = OracleFeed::deserialize(&mut &ctx.accounts.oracle.data.borrow()[..])?;\n    // VULN: 24-hour threshold is unsafe\n    let now = Clock::get()?.unix_timestamp;\n    if now - feed.timestamp < 86400 { msg!(\"Accepted\"); }\n    Ok(())\n}",
    "output": "Status: VULNERABLE\nDescription: Timestamp check allows overly stale (24h old) prices, unsafe for volatile assets.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },

  /* SAFE SAMPLES */

  {
    "sample_id": "SOL_V2_SAFE_001",
    "instruction": "Identify if this code is safe.",
    "input": "pub fn check_price_safe(ctx: Context<CheckPrice>) -> Result<()> {\n    let feed = load_price_feed_from_account_info(&ctx.accounts.oracle).unwrap();\n    let now = Clock::get()?.unix_timestamp;\n    let price = feed.get_price_no_older_than(now, 60);\n    require!(price.is_some(), MyError::StaleOracle);\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Uses 'get_price_no_older_than' ensuring fresh price data within 60 seconds.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_002",
    "instruction": "Analyze code safety.",
    "input": "pub fn use_oracle(ctx: Context<UseOracle>) -> Result<()> {\n    let p = parse_data(&ctx.accounts.oracle)?;\n    let now = Clock::get()?.unix_timestamp;\n    require!(now - p.timestamp <= 30, MyError::StaleData);\n    require!(p.confidence < p.price / 100, MyError::LowConfidence);\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Enforces strict freshness and confidence interval conditions.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_003",
    "instruction": "Check for correctness.",
    "input": "#[account(owner = pyth_program::ID)]\npub oracle_account: AccountInfo<'info>;\n\npub fn execute(ctx: Context<VerifyOracle>) -> Result<()> {\n    let price = fetch_price(&ctx.accounts.oracle_account)?;\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Uses Anchor account constraint to ensure oracle account belongs to trusted Pyth program.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_004",
    "instruction": "Analyze Oracle safety.",
    "input": "pub fn get_switchboard_price(ctx: Context<AccessFeed>) -> Result<()> {\n    let agg = &ctx.accounts.aggregator;\n    let val = agg.get_result()?;\n    let ts = agg.last_updated_round.round_open_timestamp;\n    let now = Clock::get()?.unix_timestamp;\n    require!(now - ts <= 100, MyError::OracleOutdated);\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Implements proper Switchboard oracle timestamp validation.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_005",
    "instruction": "Analyze for safety.",
    "input": "pub fn compare_prices(ctx: Context<Compare>) -> Result<()> {\n    let a = get_price(&ctx.accounts.oracle_a)?;\n    let b = get_price(&ctx.accounts.oracle_b)?;\n    require!((a - b).abs() < a / 20, MyError::PriceDeviationTooHigh);\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Uses dual-oracle validation to prevent manipulation.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_006",
    "instruction": "Analyze this code.",
    "input": "pub fn lending_op(ctx: Context<LendOp>) -> Result<()> {\n    require!(ctx.accounts.oracle.key() == ctx.accounts.config.hardcoded_oracle, MyError::InvalidOracleAddress);\n    let price = read_price(&ctx.accounts.oracle)?;\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Validates that oracle account matches trusted hardcoded address.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_007",
    "instruction": "Identify if this TWAP code is safe.",
    "input": "pub fn safe_twap_calc(ctx: Context<Twap>) -> Result<()> {\n    let obs = ctx.accounts.pool.observe();\n    let twap = calculate_twap(obs, 1800)?;\n    msg!(\"TWAP: {}\", twap);\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Uses TWAP (30min) instead of spot price to avoid flash-loan manipulation.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_008",
    "instruction": "Analyze oracle safety.",
    "input": "pub fn bound_check(ctx: Context<Check>, new_price: u64) -> Result<()> {\n    let last = ctx.accounts.state.last_known_price;\n    let upper = last * 110 / 100;\n    let lower = last * 90 / 100;\n    require!(new_price > lower && new_price < upper, MyError::PriceTooVolatile);\n    ctx.accounts.state.last_known_price = new_price;\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Implements a price circuit breaker rejecting unrealistic jumps.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_009",
    "instruction": "Check this oracle code.",
    "input": "pub fn swap_guard(ctx: Context<Swap>) -> Result<()> {\n    let amm_price = ctx.accounts.pool.get_spot_price();\n    let oracle_price = ctx.accounts.oracle.get_price()?;\n    require!((amm_price - oracle_price).abs() < oracle_price / 50, MyError::PriceManipulation);\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Verifies AMM price against external oracle to detect manipulation.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  },
  {
    "sample_id": "SOL_V2_SAFE_010",
    "instruction": "Analyze Chainlink usage.",
    "input": "pub fn get_chainlink_price(ctx: Context<Access>) -> Result<()> {\n    let feed = &ctx.accounts.chainlink_feed;\n    let round = chainlink::latest_round_data(ctx.accounts.chainlink_program.clone(), feed.clone())?;\n    let decimals = chainlink::decimals(ctx.accounts.chainlink_program.clone(), feed.clone())?;\n    msg!(\"Price: {} decimals: {}\", round.answer, decimals);\n    Ok(())\n}",
    "output": "Status: SAFE\nDescription: Uses verified Chainlink round and decimals data for secure oracle access.",
    "meta_platform": "Solana",
    "meta_vuln_type": "V2 - Oracle Validation"
  }
]
