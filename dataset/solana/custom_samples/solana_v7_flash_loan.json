[
  {
    "sample_id": "SOL_V7_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks and price manipulation vulnerabilities (OWASP V7). Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn unchecked_price_reliance(\n        ctx: Context<UncheckedPriceReliance>,\n    ) -> Result<()> {\n        let oracle = &ctx.accounts.oracle;\n        // VULNERABLE: Single price check at start, no re-verification after swap\n        let price_start = fetch_oracle_price(oracle)?;\n        require!(price_start > MIN_PRICE, ProgramError::InvalidArgument);\n        // Interaction: External swap without price validation\n        let swap_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&swap_instruction, &[])?;\n        // Effect: Grant profit based on old price\n        if price_start > PROFIT_THRESHOLD {\n            grant_arbitrage_profit()?\n        }\n        emit!(PriceCheckCompleted { price: price_start });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UncheckedPriceReliance<'info> {\n    pub oracle: AccountInfo<'info>,\n}\n\nfn fetch_oracle_price(oracle: &AccountInfo) -> Result<u64> {\n    Ok(100)\n}\n\nfn grant_arbitrage_profit() -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct PriceCheckCompleted {\n    pub price: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Single-Block Price Reliance)\nAnalysis: Price fetched once at transaction start but not re-verified after external swap. Attacker executes flash loan, manipulates price via swap, and profits from stale price check. Contract grants profit based on old price without validating current state.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Re-verify price after external interaction using slippage check or TWAP oracle",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Single-Block Price Reliance"
  },
  {
    "sample_id": "SOL_V7_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks and liquidity manipulation vulnerabilities. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn missing_liquidity_check(\n        ctx: Context<MissingLiquidityCheck>,\n        loan_amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        // VULNERABLE: No check if vault has sufficient reserves before granting loan\n        execute_flash_loan(loan_amount)?;\n        // Proceeds with arbitrage without verifying reserves\n        execute_arbitrage(loan_amount)?;\n        emit!(LoanProcessed { amount: loan_amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct MissingLiquidityCheck<'info> {\n    pub vault: AccountInfo<'info>,\n}\n\nfn execute_flash_loan(amount: u64) -> Result<()> {\n    Ok(())\n}\n\nfn execute_arbitrage(amount: u64) -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct LoanProcessed {\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Missing Liquidity Check)\nAnalysis: No verification that vault has sufficient reserves before granting flash loan. Attacker can borrow more than available liquidity, draining the pool without repayment capability. Contract assumes reserves are sufficient without checking.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Assert vault reserves >= loan_amount before processing: require!(vault_balance >= loan_amount, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Missing Liquidity/Solvency Check"
  },
  {
    "sample_id": "SOL_V7_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks and CEI pattern violations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn reentrancy_via_flash_loan(\n        ctx: Context<ReentrancyViaFlashLoan>,\n    ) -> Result<()> {\n        // Step 1: Interaction - Execute external trade\n        let trade_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&trade_instruction, &[])?;\n        // Step 2: Effect - Grant profit BEFORE repayment verification\n        grant_unverified_profit()?;\n        // Step 3: Check - Loan repayment only checked at end\n        verify_loan_repayment()?;\n        emit!(FlashLoanCompleted {});\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ReentrancyViaFlashLoan {}\n\nfn grant_unverified_profit() -> Result<()> {\n    Ok(())\n}\n\nfn verify_loan_repayment() -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct FlashLoanCompleted {}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (CEI Violation in Flash Loan Context)\nAnalysis: Violates CEI pattern: Interaction (trade) â†’ Effect (grant profit) â†’ Check (verify repayment). Attacker executes external trade, receives profit, then escapes without repaying loan. Profit granted before repayment is verified.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Reorder to Check â†’ Effect â†’ Interaction: Verify repayment first, then grant profit",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "CEI Violation (Flash Loan Context)"
  },
  {
    "sample_id": "SOL_V7_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks using insecure oracle patterns. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn reliance_on_spot_price(\n        ctx: Context<RelianceOnSpotPrice>,\n    ) -> Result<()> {\n        let oracle = &ctx.accounts.oracle;\n        // VULNERABLE: Uses volatile spot price instead of TWAP\n        let spot_price = fetch_spot_price(oracle)?;\n        // Logic decision based on easily manipulable spot price\n        if spot_price > TARGET_PRICE {\n            update_collateral(spot_price)?;\n        }\n        emit!(CollateralUpdated { price: spot_price });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct RelianceOnSpotPrice<'info> {\n    pub oracle: AccountInfo<'info>,\n}\n\nfn fetch_spot_price(oracle: &AccountInfo) -> Result<u64> {\n    Ok(150)\n}\n\nfn update_collateral(price: u64) -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct CollateralUpdated {\n    pub price: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Single-Point Oracle Attack)\nAnalysis: Uses volatile spot price for collateral calculation instead of Time-Weighted Average Price (TWAP). Attacker manipulates spot price via flash loan, causing contract to miscalculate collateral values and grant excessive loans.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Use TWAP oracle: let twap_price = fetch_twap_oracle(oracle)?;",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Single-Point Oracle Attack (Spot Price Reliance)"
  },
  {
    "sample_id": "SOL_V7_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with unchecked external fees. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn unchecked_external_fee(\n        ctx: Context<UncheckedExternalFee>,\n    ) -> Result<()> {\n        let fee_service = &ctx.accounts.fee_service;\n        // VULNERABLE: CPI to fee service without validating final amount\n        let fee_instruction = Instruction {\n            program_id: fee_service.key(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&fee_instruction, &[fee_service.clone()])?;\n        // Assumes fee was calculated correctly, no balance verification\n        emit!(FeeProcessed {});\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UncheckedExternalFee<'info> {\n    pub fee_service: AccountInfo<'info>,\n}\n\n#[event]\npub struct FeeProcessed {}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Unchecked External Fee)\nAnalysis: Executes CPI to external fee service without validating final balance or fee amount. Malicious fee service charges arbitrary fee or returns incorrect amount. No balance check after external call allows fee manipulation.\nRisk Level: ðŸŸ  HIGH\nRecommendation: Validate balance before and after: let before = get_balance(); invoke(...)?; let after = get_balance(); assert_eq!(fee, before - after);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Unchecked External Fee"
  },
  {
    "sample_id": "SOL_V7_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with weak slippage control. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn weak_slippage_control(\n        ctx: Context<WeakSlippageControl>,\n        min_out: u64,\n    ) -> Result<()> {\n        // VULNERABLE: Allows 10% slippage, too loose for flash loan protection\n        let actual_out = execute_large_trade()?;\n        // Only checks if output is 90% of minimum, allowing massive manipulation\n        if actual_out < min_out * 90 / 100 {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        emit!(TradeExecuted { output: actual_out });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WeakSlippageControl {}\n\nfn execute_large_trade() -> Result<u64> {\n    Ok(80)\n}\n\n#[event]\npub struct TradeExecuted {\n    pub output: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Weak Slippage Control)\nAnalysis: Slippage tolerance of 10% is too loose to prevent flash loan manipulation. Attacker manipulates price dramatically within flash loan, contract allows execution because output is still 90% of minimum. Loses significant value to manipulation.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Use strict slippage: require!(actual_out >= min_out, SlippageTooHigh);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Weak Slippage Control"
  },
  {
    "sample_id": "SOL_V7_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with asset ID confusion. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn asset_id_confusion(\n        ctx: Context<AssetIdConfusion>,\n        repayment_asset_id: u8,\n    ) -> Result<()> {\n        // VULNERABLE: Doesn't strictly verify repayment asset matches loan asset\n        let loan_asset_id = EXPECTED_ASSET_A;\n        // Logic assumes repayment_asset_id is correct but doesn't enforce it\n        if repayment_asset_id != loan_asset_id {\n            // Still proceeds without returning error\n            repay_loan_with_wrong_asset(repayment_asset_id)?;\n        }\n        emit!(LoanRepaid { asset_id: repayment_asset_id });\n        Ok(())\n    }\n}\n\nconst EXPECTED_ASSET_A: u8 = 1;\n\n#[derive(Accounts)]\npub struct AssetIdConfusion {}\n\nfn repay_loan_with_wrong_asset(asset_id: u8) -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct LoanRepaid {\n    pub asset_id: u8,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Asset ID Confusion)\nAnalysis: Fails to strictly verify that repayment asset matches expected asset. Attacker borrows high-value asset but repays with worthless token. Contract logic allows repayment with wrong or valueless asset ID.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Strict verification: require!(repayment_asset_id == EXPECTED_ASSET_ID, WrongAsset);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Asset ID Confusion in Loan Repayment"
  },
  {
    "sample_id": "SOL_V7_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with volatile state dependency. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn volatile_state_dependency(\n        ctx: Context<VolatileStateDependency>,\n    ) -> Result<()> {\n        let external_state = &ctx.accounts.external_state;\n        // VULNERABLE: Logic depends on volatile external state\n        let volatile_value = fetch_volatile_state(external_state)?;\n        // Attacker can manipulate this value in same block via flash loan\n        if volatile_value > THRESHOLD {\n            execute_high_value_transaction()?;\n        }\n        emit!(StateChecked { value: volatile_value });\n        Ok(())\n    }\n}\n\nconst THRESHOLD: u64 = 100;\n\n#[derive(Accounts)]\npub struct VolatileStateDependency<'info> {\n    pub external_state: AccountInfo<'info>,\n}\n\nfn fetch_volatile_state(state: &AccountInfo) -> Result<u64> {\n    Ok(150)\n}\n\nfn execute_high_value_transaction() -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct StateChecked {\n    pub value: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Logic Dependent on Volatile State)\nAnalysis: Critical logic decision depends on easily manipulable external state variable. Attacker uses flash loan to pump price/liquidity, triggering high-value transaction that executes at manipulated conditions. Contract trusts volatile state without verification.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Use secure state source (TWAP, time-locked data) instead of volatile external state",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Logic Dependent on Volatile State"
  },
  {
    "sample_id": "SOL_V7_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with missing protocol fee check. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn missing_protocol_fee(\n        ctx: Context<MissingProtocolFee>,\n    ) -> Result<()> {\n        // VULNERABLE: Doesn't enforce protocol fee collection from flash loan\n        // Assumes minimum transaction fee is sufficient\n        let profit = calculate_arbitrage_profit()?;\n        // No protocol fee calculation or enforcement\n        grant_profit(profit)?;\n        emit!(ProfitGranted { amount: profit });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct MissingProtocolFee {}\n\nfn calculate_arbitrage_profit() -> Result<u64> {\n    Ok(1000)\n}\n\nfn grant_profit(amount: u64) -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct ProfitGranted {\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Missing Protocol Fee Check)\nAnalysis: Fails to collect or verify mandatory protocol fee from flash loan arbitrage profit. Attacker captures full arbitrage profit without paying required fee. Contract assumes transaction fee is sufficient but doesn't enforce protocol-level fee.\nRisk Level: ðŸŸ  HIGH\nRecommendation: Calculate and enforce fee: let fee_due = profit * PROTOCOL_FEE_PERCENT / 100; require_fee_paid(fee_due);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Missing Protocol Fee Check"
  },
  {
    "sample_id": "SOL_V7_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with final balance miscalculation. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_flash_loan {\n    use super::*;\n\n    pub fn final_balance_miscalculation(\n        ctx: Context<FinalBalanceMiscalculation>,\n    ) -> Result<()> {\n        // VULNERABLE: Doesn't verify final pool solvency after flash loan\n        let final_balance = calculate_final_balance()?;\n        // Only logs but doesn't enforce minimum balance requirement\n        if final_balance < REQUIRED_MINIMUM {\n            // Error not returned, execution continues\n            msg!(\"Warning: Balance below minimum\");\n        }\n        emit!(BalanceCalculated { balance: final_balance });\n        Ok(())\n    }\n}\n\nconst REQUIRED_MINIMUM: u64 = 1000000;\n\n#[derive(Accounts)]\npub struct FinalBalanceMiscalculation {}\n\nfn calculate_final_balance() -> Result<u64> {\n    Ok(500000)\n}\n\n#[event]\npub struct BalanceCalculated {\n    pub balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability: V7 - Flash Loan Attacks (Final Balance Miscalculation)\nAnalysis: Fails to assert that final pool balance meets minimum solvency requirement. Calculates final balance but only logs warning without enforcing check. Flash loan attack can drain pool below minimum, leaving protocol insolvent but transaction succeeds.\nRisk Level: ðŸ”´ CRITICAL\nRecommendation: Assert solvency: require!(final_balance >= REQUIRED_MINIMUM, InsolventPool);",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Final Balance Miscalculation/Solvency Check"
  }
]
[
  {
    "sample_id": "SOL_V7_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks and price manipulation vulnerabilities. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn checked_price_reliance(\n        ctx: Context<CheckedPriceReliance>,\n    ) -> Result<()> {\n        let oracle = &ctx.accounts.oracle;\n        // SECURE: Fetch price at start\n        let price_start = fetch_oracle_price(oracle)?;\n        require!(price_start > MIN_PRICE, ProgramError::InvalidArgument);\n        // Interaction: External swap\n        let swap_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&swap_instruction, &[])?;\n        // SECURE: Re-verify price immediately after interaction\n        let price_end = fetch_oracle_price(oracle)?;\n        // Enforce slippage tolerance\n        let price_diff = price_start.abs_diff(price_end);\n        require!(price_diff < MAX_PRICE_DIFF, SlippageTooHigh);\n        // Effect: Grant profit only if price remained stable\n        if price_start > PROFIT_THRESHOLD {\n            grant_arbitrage_profit()?\n        }\n        emit!(PriceVerified { start: price_start, end: price_end });\n        Ok(())\n    }\n}\n\nconst MAX_PRICE_DIFF: u64 = 5;\n\n#[derive(Accounts)]\npub struct CheckedPriceReliance<'info> {\n    pub oracle: AccountInfo<'info>,\n}\n\nfn fetch_oracle_price(oracle: &AccountInfo) -> Result<u64> {\n    Ok(100)\n}\n\nfn grant_arbitrage_profit() -> Result<()> {\n    Ok(())\n}\n\n#[error_code]\npub enum SlippageTooHigh {\n    SlippageExceeded,\n}\n\n#[event]\npub struct PriceVerified {\n    pub start: u64,\n    pub end: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Implements strict re-verification of price after external swap. Calculates price differential and enforces maximum slippage tolerance, preventing price manipulation via flash loans.\nRisk Level: âœ… LOW\nValidation: Price checked before and after interaction with strict slippage enforcement",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Checked Price Re-verification with Slippage Control"
  },
  {
    "sample_id": "SOL_V7_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks and liquidity safeguards. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn enforced_liquidity_check(\n        ctx: Context<EnforcedLiquidityCheck>,\n        loan_amount: u64,\n    ) -> Result<()> {\n        let vault = &ctx.accounts.vault;\n        // SECURE: Strictly verify sufficient reserves BEFORE granting loan\n        let vault_balance = get_vault_balance(vault)?;\n        require!(\n            vault_balance >= loan_amount,\n            ProgramError::InsufficientFunds\n        );\n        // Interaction: Execute flash loan\n        execute_flash_loan(loan_amount)?;\n        // Effect: Process arbitrage\n        execute_arbitrage(loan_amount)?;\n        emit!(LoanProcessedSafely { amount: loan_amount });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct EnforcedLiquidityCheck<'info> {\n    pub vault: AccountInfo<'info>,\n}\n\nfn get_vault_balance(vault: &AccountInfo) -> Result<u64> {\n    Ok(1000000)\n}\n\nfn execute_flash_loan(amount: u64) -> Result<()> {\n    Ok(())\n}\n\nfn execute_arbitrage(amount: u64) -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct LoanProcessedSafely {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Implements strict solvency check before processing flash loan. Verifies vault has sufficient balance >= loan_amount, preventing liquidity drain attacks.\nRisk Level: âœ… LOW\nValidation: Vault balance verified before loan execution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Enforced Liquidity/Solvency Check"
  },
  {
    "sample_id": "SOL_V7_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with strict repayment verification. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn strict_repayment_verification(\n        ctx: Context<StrictRepaymentVerification>,\n    ) -> Result<()> {\n        // SECURE: Strict CEI enforcement for flash loans\n        // Check: Verify loan repayment BEFORE granting any effects\n        verify_loan_repaid_in_full()?;\n        // Interaction: Execute external trade\n        let trade_instruction = Instruction {\n            program_id: Pubkey::default(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&trade_instruction, &[])?;\n        // Effect: Grant profit only AFTER repayment verified\n        grant_profit()?;\n        emit!(FlashLoanCompletedSafely {});\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct StrictRepaymentVerification {}\n\nfn verify_loan_repaid_in_full() -> Result<()> {\n    Ok(())\n}\n\nfn grant_profit() -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct FlashLoanCompletedSafely {}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Implements strict CEI pattern with Check (repayment verification) before Effect (profit grant). Ensures loan repayment is verified before granting any profits, preventing escape attacks.\nRisk Level: âœ… LOW\nValidation: Loan repayment checked before profit is granted",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Strict CEI with Repayment Check"
  },
  {
    "sample_id": "SOL_V7_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks using secure oracle sources. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn reliance_on_twap_oracle(\n        ctx: Context<RelianceOnTwapOracle>,\n    ) -> Result<()> {\n        let oracle = &ctx.accounts.oracle;\n        // SECURE: Use Time-Weighted Average Price (TWAP) instead of spot\n        let twap_price = fetch_twap_oracle(oracle)?;\n        // TWAP is resistant to single-block price manipulation\n        if twap_price > TARGET_PRICE {\n            update_collateral(twap_price)?\n        }\n        emit!(CollateralUpdatedSafely { price: twap_price });\n        Ok(())\n    }\n}\n\nconst TARGET_PRICE: u64 = 100;\n\n#[derive(Accounts)]\npub struct RelianceOnTwapOracle<'info> {\n    pub oracle: AccountInfo<'info>,\n}\n\nfn fetch_twap_oracle(oracle: &AccountInfo) -> Result<u64> {\n    Ok(100)\n}\n\nfn update_collateral(price: u64) -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct CollateralUpdatedSafely {\n    pub price: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Uses Time-Weighted Average Price (TWAP) oracle instead of volatile spot price. TWAP aggregates prices over time, preventing single-block price manipulation attacks.\nRisk Level: âœ… LOW\nValidation: TWAP oracle prevents flash loan price manipulation",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Secure TWAP Oracle Reliance"
  },
  {
    "sample_id": "SOL_V7_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with validated external fees. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse anchor_lang::solana_program::program::invoke;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn checked_external_fee(\n        ctx: Context<CheckedExternalFee>,\n    ) -> Result<()> {\n        let fee_service = &ctx.accounts.fee_service;\n        // SECURE: Verify balance before and after external call\n        let balance_before = get_balance(fee_service)?;\n        let fee_instruction = Instruction {\n            program_id: fee_service.key(),\n            accounts: vec![],\n            data: vec![],\n        };\n        invoke(&fee_instruction, &[fee_service.clone()])?;\n        let balance_after = get_balance(fee_service)?;\n        // SECURE: Validate fee matches expectation\n        let fee_charged = balance_before.saturating_sub(balance_after);\n        let expected_fee = calculate_expected_fee();\n        require_eq!(fee_charged, expected_fee, InvalidFee);\n        emit!(FeeValidated { amount: fee_charged });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CheckedExternalFee<'info> {\n    pub fee_service: AccountInfo<'info>,\n}\n\nfn get_balance(account: &AccountInfo) -> Result<u64> {\n    Ok(1000)\n}\n\nfn calculate_expected_fee() -> u64 {\n    100\n}\n\n#[error_code]\npub enum InvalidFee {\n    FeeMismatch,\n}\n\n#[event]\npub struct FeeValidated {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Validates balance before and after external fee service call. Ensures fee charged matches expected amount, preventing malicious fee manipulation.\nRisk Level: âœ… LOW\nValidation: Fee amount verified against expected value",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Validated External Fee with Balance Check"
  },
  {
    "sample_id": "SOL_V7_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with strict slippage enforcement. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn strict_slippage_control(\n        ctx: Context<StrictSlippageControl>,\n        min_out: u64,\n    ) -> Result<()> {\n        // SECURE: Enforce strict slippage tolerance\n        let actual_out = execute_large_trade()?;\n        // Require exact minimum output, no loose tolerance\n        require!(\n            actual_out >= min_out,\n            SlippageTooHigh\n        );\n        emit!(TradeExecutedSafely { output: actual_out });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct StrictSlippageControl {}\n\nfn execute_large_trade() -> Result<u64> {\n    Ok(100)\n}\n\n#[error_code]\npub enum SlippageTooHigh {\n    SlippageExceeded,\n}\n\n#[event]\npub struct TradeExecutedSafely {\n    pub output: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Enforces strict slippage tolerance without loose percentage-based margins. Requires actual_out >= min_out precisely, preventing price manipulation via flash loans.\nRisk Level: âœ… LOW\nValidation: Strict slippage check prevents manipulation",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Strict Slippage Control"
  },
  {
    "sample_id": "SOL_V7_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with asset ID verification. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn strict_asset_verification(\n        ctx: Context<StrictAssetVerification>,\n        repayment_asset_id: u8,\n    ) -> Result<()> {\n        // SECURE: Strictly verify repayment asset matches expected\n        let loan_asset_id = EXPECTED_ASSET_A;\n        require_eq!(\n            repayment_asset_id,\n            loan_asset_id,\n            WrongAssetId\n        );\n        // Repay only with correct asset\n        repay_loan(repayment_asset_id)?;\n        emit!(LoanRepaidSafely { asset_id: repayment_asset_id });\n        Ok(())\n    }\n}\n\nconst EXPECTED_ASSET_A: u8 = 1;\n\n#[derive(Accounts)]\npub struct StrictAssetVerification {}\n\nfn repay_loan(asset_id: u8) -> Result<()> {\n    Ok(())\n}\n\n#[error_code]\npub enum WrongAssetId {\n    AssetMismatch,\n}\n\n#[event]\npub struct LoanRepaidSafely {\n    pub asset_id: u8,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Strictly verifies repayment asset ID matches expected asset before accepting repayment. Prevents attacker from repaying with worthless token.\nRisk Level: âœ… LOW\nValidation: Asset ID strictly verified before repayment",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Strict Asset ID Verification"
  },
  {
    "sample_id": "SOL_V7_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with secure state dependency. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn secure_state_dependency(\n        ctx: Context<SecureStateDependency>,\n    ) -> Result<()> {\n        let oracle = &ctx.accounts.oracle;\n        // SECURE: Logic depends on secure, non-volatile TWAP price\n        let secure_price = fetch_twap_oracle(oracle)?;\n        // TWAP cannot be manipulated within single transaction\n        if secure_price > THRESHOLD {\n            execute_high_value_transaction()?;\n        }\n        emit!(TransactionExecutedSafely { price: secure_price });\n        Ok(())\n    }\n}\n\nconst THRESHOLD: u64 = 100;\n\n#[derive(Accounts)]\npub struct SecureStateDependency<'info> {\n    pub oracle: AccountInfo<'info>,\n}\n\nfn fetch_twap_oracle(oracle: &AccountInfo) -> Result<u64> {\n    Ok(150)\n}\n\nfn execute_high_value_transaction() -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct TransactionExecutedSafely {\n    pub price: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Logic depends on secure TWAP price source instead of volatile external state. TWAP prevents single-block manipulation, ensuring decisions are based on reliable historical price data.\nRisk Level: âœ… LOW\nValidation: Logic relies on non-manipulable TWAP oracle",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Secure State Dependency on TWAP"
  },
  {
    "sample_id": "SOL_V7_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with enforced protocol fees. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn enforced_protocol_fee(\n        ctx: Context<EnforcedProtocolFee>,\n    ) -> Result<()> {\n        // SECURE: Calculate and enforce mandatory protocol fee\n        let profit = calculate_arbitrage_profit()?;\n        let fee_due = (profit * PROTOCOL_FEE_PERCENT) / 100;\n        // Strictly enforce fee collection\n        require_fee_paid(fee_due)?;\n        // Grant profit only after fee verified\n        grant_profit(profit)?;\n        emit!(FeeEnforcedSafely { fee: fee_due });\n        Ok(())\n    }\n}\n\nconst PROTOCOL_FEE_PERCENT: u64 = 5;\n\n#[derive(Accounts)]\npub struct EnforcedProtocolFee {}\n\nfn calculate_arbitrage_profit() -> Result<u64> {\n    Ok(1000)\n}\n\nfn require_fee_paid(fee: u64) -> Result<()> {\n    Ok(())\n}\n\nfn grant_profit(amount: u64) -> Result<()> {\n    Ok(())\n}\n\n#[event]\npub struct FeeEnforcedSafely {\n    pub fee: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Calculates and enforces mandatory protocol fee from arbitrage profit. Strictly verifies fee is paid before granting remaining profit to user.\nRisk Level: âœ… LOW\nValidation: Protocol fee calculated and enforced before profit distribution",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Enforced Protocol Fee Collection"
  },
  {
    "sample_id": "SOL_V7_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for Flash Loan Attacks with verified final balance checks. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_flash_loan {\n    use super::*;\n\n    pub fn verified_final_balance(\n        ctx: Context<VerifiedFinalBalance>,\n    ) -> Result<()> {\n        // SECURE: Verify final pool balance meets solvency requirement\n        let final_balance = calculate_final_balance()?;\n        require!(\n            final_balance >= REQUIRED_MINIMUM,\n            InsolventPool\n        );\n        emit!(BalanceVerifiedSafely { balance: final_balance });\n        Ok(())\n    }\n}\n\nconst REQUIRED_MINIMUM: u64 = 1000000;\n\n#[derive(Accounts)]\npub struct VerifiedFinalBalance {}\n\nfn calculate_final_balance() -> Result<u64> {\n    Ok(1000000)\n}\n\n#[error_code]\npub enum InsolventPool {\n    PoolInsolvency,\n}\n\n#[event]\npub struct BalanceVerifiedSafely {\n    pub balance: u64,\n}",
    "output": "Status: SAFE\nVulnerability: V7 - Flash Loan Attacks\nAnalysis: Safe: Strictly asserts final pool balance meets minimum solvency requirement. Prevents flash loan attacks from draining pool below minimum safe threshold.\nRisk Level: âœ… LOW\nValidation: Final balance verified >= required minimum",
    "meta_platform": "Solana",
    "meta_vuln_type": "V7 - Flash Loan Attacks",
    "meta_pattern": "Verified Final Balance Solvency"
  }
]
