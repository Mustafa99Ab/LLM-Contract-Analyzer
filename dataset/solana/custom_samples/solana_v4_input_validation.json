[
  {
    "sample_id": "SOL_V4_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account ownership, data structure integrity, and type safety. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn process_user_config(\n        ctx: Context<ProcessUserConfig>,\n    ) -> Result<()> {\n        let config_account = &ctx.accounts.config_account;\n        let user = &ctx.accounts.user;\n        // VULNERABLE: No owner check - accepts any account passed as config\n        // Attacker could pass system account or unrelated program's account\n        let config_data = config_account.try_borrow_data()?;\n        let user_config = UserConfig::try_from_slice(&config_data)?;\n        user_config.verify_permissions(user.key())?;\n        emit!(ConfigProcessed {\n            config_owner: config_account.key(),\n            processed_by: user.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessUserConfig<'info> {\n    pub config_account: AccountInfo<'info>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct UserConfig {\n    pub owner: Pubkey,\n    pub permissions: u64,\n}\n\nimpl UserConfig {\n    fn verify_permissions(&self, user: &Pubkey) -> Result<()> {\n        require_eq!(self.owner, *user, ProgramError::InvalidArgument);\n        Ok(())\n    }\n}\n\n#[event]\npub struct ConfigProcessed {\n    pub config_owner: Pubkey,\n    pub processed_by: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Missing Account Owner Check\nDescription: The contract deserializes data from any account without verifying the account's owner. An attacker can pass a system account, unrelated program account, or malicious account, causing type confusion and potential logic bypass.\nRisk Level: CRITICAL\nRecommendation: Verify account ownership: require!(config_account.owner == &crate::ID, ProgramError::IncorrectProgramId)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Missing Account Owner Validation"
  },
  {
    "sample_id": "SOL_V4_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account data length and structure integrity. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn initialize_user_account(\n        ctx: Context<InitializeUserAccount>,\n    ) -> Result<()> {\n        let user_account = &ctx.accounts.user_account;\n        let payer = &ctx.accounts.payer;\n        // VULNERABLE: No length check before deserialization\n        // Account could be too small, causing incomplete data reads\n        let expected_size = std::mem::size_of::<UserState>();\n        let account_data = user_account.try_borrow_data()?;\n        let user_state = UserState::try_from_slice(&account_data)?;\n        user_state.validate_state()?;\n        emit!(UserAccountInitialized {\n            account: user_account.key(),\n            owner: payer.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeUserAccount<'info> {\n    #[account(mut)]\n    pub user_account: AccountInfo<'info>,\n    pub payer: Signer<'info>,\n}\n\n#[account]\npub struct UserState {\n    pub bump: u8,\n    pub balance: u64,\n    pub nonce: u32,\n}\n\nimpl UserState {\n    fn validate_state(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct UserAccountInitialized {\n    pub account: Pubkey,\n    pub owner: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Missing Data Length Check\nDescription: The contract attempts to deserialize account data without first verifying that the account buffer is large enough. This can cause incomplete deserialization or buffer underrun vulnerabilities.\nRisk Level: CRITICAL\nRecommendation: Check data length before deserialization: require!(user_account.data_len() >= expected_size, ProgramError::InvalidAccountData)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Missing Data Length Validation"
  },
  {
    "sample_id": "SOL_V4_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account types through discriminators and structure checks. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst EXPECTED_DISCRIMINATOR: [u8; 4] = [0x1a, 0x2b, 0x3c, 0x4d];\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn process_token_config(\n        ctx: Context<ProcessTokenConfig>,\n    ) -> Result<()> {\n        let config_account = &ctx.accounts.config_account;\n        let config_data = config_account.try_borrow_data()?;\n        // VULNERABLE: Only checks discriminator, ignores structure size\n        // Account could have discriminator but be wrong size/type\n        if config_data.len() < 4 || &config_data[..4] != &EXPECTED_DISCRIMINATOR {\n            return Err(ProgramError::InvalidAccountData.into());\n        }\n        let token_config = TokenConfig::try_from_slice(&config_data)?;\n        token_config.process()?;\n        emit!(TokenConfigProcessed {\n            config: config_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessTokenConfig<'info> {\n    pub config_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct TokenConfig {\n    pub mint: Pubkey,\n    pub authority: Pubkey,\n    pub frozen: bool,\n}\n\nimpl TokenConfig {\n    fn process(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct TokenConfigProcessed {\n    pub config: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Incomplete Discriminator Validation\nDescription: The contract checks the discriminator but fails to validate the full structure size. An attacker can create an account with matching discriminator but wrong data layout, causing type confusion during deserialization.\nRisk Level: CRITICAL\nRecommendation: Validate both discriminator and size: require!(config_data.len() >= expected_size && &config_data[..4] == DISCRIMINATOR, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Incomplete Type Validation"
  },
  {
    "sample_id": "SOL_V4_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account initialization status. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn process_user_data(\n        ctx: Context<ProcessUserData>,\n    ) -> Result<()> {\n        let user_account = &ctx.accounts.user_account;\n        // VULNERABLE: No check if account is initialized\n        // Could deserialize uninitialized/garbage data\n        let user_data = user_account.try_borrow_data()?;\n        let user = UserData::try_from_slice(&user_data)?;\n        let total_balance = user.available_balance + user.locked_balance;\n        require!(\n            total_balance > 0,\n            ProgramError::InvalidAccountData\n        );\n        emit!(UserDataProcessed {\n            user: user_account.key(),\n            total: total_balance,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessUserData<'info> {\n    pub user_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct UserData {\n    pub is_initialized: bool,\n    pub owner: Pubkey,\n    pub available_balance: u64,\n    pub locked_balance: u64,\n}\n\n#[event]\npub struct UserDataProcessed {\n    pub user: Pubkey,\n    pub total: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Missing Initialization Check\nDescription: The contract assumes accounts are initialized before processing their data. Uninitialized accounts contain garbage data, which can be deserialized, leading to logic errors and potential security bypasses.\nRisk Level: CRITICAL\nRecommendation: Check initialization flag: require!(user.is_initialized, ProgramError::UninitializedAccount)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Missing Initialization Validation"
  },
  {
    "sample_id": "SOL_V4_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account mutability and ownership together. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn write_program_state(\n        ctx: Context<WriteProgramState>,\n    ) -> Result<()> {\n        let state_account = &ctx.accounts.state_account;\n        // VULNERABLE: Only checks is_writable, missing owner verification\n        // Attacker could pass any writable account owned by another program\n        if !state_account.is_writable {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let mut state_data = state_account.try_borrow_mut_data()?;\n        let state = ProgramState::try_from_slice(&state_data)?;\n        state.validate()?;\n        emit!(StateWritten {\n            account: state_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WriteProgramState<'info> {\n    #[account(mut)]\n    pub state_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct ProgramState {\n    pub version: u32,\n    pub data: [u8; 64],\n}\n\nimpl ProgramState {\n    fn validate(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct StateWritten {\n    pub account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Incomplete Mutability Check\nDescription: The contract only verifies the is_writable flag without checking account ownership. An attacker can pass a writable account owned by another program, bypassing ownership-based access control.\nRisk Level: CRITICAL\nRecommendation: Verify both mutability and ownership: require!(state_account.is_writable && state_account.owner == &crate::ID, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Missing Owner Check with Mutability"
  },
  {
    "sample_id": "SOL_V4_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates numeric type conversions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn access_array_element(\n        ctx: Context<AccessArrayElement>,\n        index: u64,\n    ) -> Result<()> {\n        let data_account = &ctx.accounts.data_account;\n        // VULNERABLE: No range check on u64 before converting to usize\n        // Could cause panic or out-of-bounds access if index is too large\n        let unsafe_index: usize = index as usize;\n        let data = data_account.try_borrow_data()?;\n        let array = DataArray::try_from_slice(&data)?;\n        if unsafe_index >= array.elements.len() {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let element = &array.elements[unsafe_index];\n        emit!(ElementAccessed {\n            account: data_account.key(),\n            index: unsafe_index as u64,\n            value: element.value,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct AccessArrayElement<'info> {\n    pub data_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct DataArray {\n    pub elements: Vec<ArrayElement>,\n}\n\n#[derive(Clone)]\npub struct ArrayElement {\n    pub value: u64,\n}\n\n#[event]\npub struct ElementAccessed {\n    pub account: Pubkey,\n    pub index: u64,\n    pub value: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Unchecked Numeric Type Conversion\nDescription: The contract converts a user-provided u64 to usize without prior range validation. On 32-bit systems or with large inputs, this could cause panic or enable out-of-bounds memory access.\nRisk Level: HIGH\nRecommendation: Validate range before conversion: require!(index < MAX_SAFE_INDEX, ...); let idx = index as usize;",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Unchecked Numeric Conversion"
  },
  {
    "sample_id": "SOL_V4_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account executable status and type. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn verify_account_type(\n        ctx: Context<VerifyAccountType>,\n    ) -> Result<()> {\n        let data_account = &ctx.accounts.data_account;\n        // VULNERABLE: Only checks is_executable, insufficient for type validation\n        // Should also verify owner and data structure\n        if data_account.is_executable() {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let account_data = data_account.try_borrow_data()?;\n        let account_info = AccountInfo::try_from_slice(&account_data)?;\n        account_info.process()?;\n        emit!(AccountTypeVerified {\n            account: data_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct VerifyAccountType<'info> {\n    pub data_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct AccountInfo {\n    pub account_type: u8,\n    pub data: Vec<u8>,\n}\n\nimpl AccountInfo {\n    fn process(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct AccountTypeVerified {\n    pub account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Insufficient Account Type Check\nDescription: The contract only checks the is_executable flag without verifying account ownership or data structure. This allows passing data accounts from other programs, causing type confusion.\nRisk Level: HIGH\nRecommendation: Verify ownership and structure: require!(account.owner == &crate::ID && account.data_len() >= MIN_SIZE, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Insufficient Account Type Validation"
  },
  {
    "sample_id": "SOL_V4_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates string input size and content. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn process_user_name(\n        ctx: Context<ProcessUserName>,\n        name: String,\n    ) -> Result<()> {\n        let user_account = &ctx.accounts.user_account;\n        // VULNERABLE: No length check on string input\n        // Attacker could pass very large string causing DoS\n        if name.contains(\"system\") {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let user_data = user_account.try_borrow_data()?;\n        let mut user = User::try_from_slice(&user_data)?;\n        user.name = name.clone();\n        emit!(UserNameUpdated {\n            user: user_account.key(),\n            name_length: name.len() as u32,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessUserName<'info> {\n    #[account(mut)]\n    pub user_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct User {\n    pub name: String,\n    pub balance: u64,\n}\n\n#[event]\npub struct UserNameUpdated {\n    pub user: Pubkey,\n    pub name_length: u32,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Unchecked String Input\nDescription: The contract accepts user-provided string input without validating its length. An attacker can pass extremely large strings to cause denial of service by exhausting memory or compute resources.\nRisk Level: HIGH\nRecommendation: Validate string length: require!(name.len() <= MAX_NAME_LENGTH, ProgramError::InvalidArgument)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Unchecked String Input"
  },
  {
    "sample_id": "SOL_V4_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates cross-program interaction accounts. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn use_external_token_account(\n        ctx: Context<UseExternalToken>,\n    ) -> Result<()> {\n        let token_account = &ctx.accounts.token_account;\n        // VULNERABLE: Assumes account is Token Program account without owner check\n        // Attacker could pass any account, causing interaction with wrong program\n        if token_account.is_executable() {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let token_data = token_account.try_borrow_data()?;\n        let token_state = TokenAccount::try_from_slice(&token_data)?;\n        token_state.validate()?;\n        emit!(TokenAccountUsed {\n            account: token_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UseExternalToken<'info> {\n    pub token_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct TokenAccount {\n    pub mint: Pubkey,\n    pub owner: Pubkey,\n    pub amount: u64,\n}\n\nimpl TokenAccount {\n    fn validate(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct TokenAccountUsed {\n    pub account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Missing Token Program ID Check\nDescription: The contract assumes an account is a Token Program account without verifying its owner. An attacker can pass an account from a malicious token-like program, bypassing protocol constraints.\nRisk Level: CRITICAL\nRecommendation: Verify token program ownership: require!(token_account.owner == &spl_token::ID, ProgramError::IncorrectProgramId)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Missing Token Program Validation"
  },
  {
    "sample_id": "SOL_V4_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates fixed-size array input content. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_BYTE_VALUE: u8 = 100;\n\n#[program]\npub mod vulnerable_input_validation {\n    use super::*;\n\n    pub fn process_config_bytes(\n        ctx: Context<ProcessConfigBytes>,\n        config: [u8; 32],\n    ) -> Result<()> {\n        let account = &ctx.accounts.account;\n        // VULNERABLE: Only checks first element, ignores rest of array\n        if config[0] > MAX_BYTE_VALUE {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let account_data = account.try_borrow_data()?;\n        let state = ConfigState::try_from_slice(&account_data)?;\n        state.apply_config(&config)?;\n        emit!(ConfigApplied {\n            account: account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessConfigBytes<'info> {\n    #[account(mut)]\n    pub account: AccountInfo<'info>,\n}\n\n#[account]\npub struct ConfigState {\n    pub config: [u8; 32],\n}\n\nimpl ConfigState {\n    fn apply_config(&self, config: &[u8; 32]) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct ConfigApplied {\n    pub account: Pubkey,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Input Validation - Incomplete Array Validation\nDescription: The contract only validates the first element of a 32-byte configuration array. Remaining elements are unchecked, allowing attackers to pass invalid configuration data that could affect program behavior.\nRisk Level: HIGH\nRecommendation: Validate all array elements: for byte in config.iter() { require!(*byte <= MAX_BYTE_VALUE, ...); }",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Incomplete Array Element Validation"
  }
]
[
  {
    "sample_id": "SOL_V4_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account ownership, data structure integrity, and type safety. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"YourProgramIDHere111111111111111111111111111\");\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn process_user_config_safely(\n        ctx: Context<ProcessUserConfigSafely>,\n    ) -> Result<()> {\n        let config_account = &ctx.accounts.config_account;\n        let user = &ctx.accounts.user;\n        // SECURE: Verify account ownership before deserialization\n        require!(\n            config_account.owner == &crate::ID,\n            ProgramError::IncorrectProgramId\n        );\n        let config_data = config_account.try_borrow_data()?;\n        let user_config = UserConfig::try_from_slice(&config_data)?;\n        user_config.verify_permissions(user.key())?;\n        emit!(ConfigProcessedSafely {\n            config_owner: config_account.key(),\n            processed_by: user.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessUserConfigSafely<'info> {\n    pub config_account: AccountInfo<'info>,\n    pub user: Signer<'info>,\n}\n\n#[account]\npub struct UserConfig {\n    pub owner: Pubkey,\n    pub permissions: u64,\n}\n\nimpl UserConfig {\n    fn verify_permissions(&self, user: &Pubkey) -> Result<()> {\n        require_eq!(self.owner, *user, ProgramError::InvalidArgument);\n        Ok(())\n    }\n}\n\n#[event]\npub struct ConfigProcessedSafely {\n    pub config_owner: Pubkey,\n    pub processed_by: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Account Ownership Validated\nDescription: The contract validates account ownership against the program ID before deserializing data. This prevents type confusion by ensuring only accounts owned by this program are processed.\nRisk Level: LOW\nValidation: Account owner checked against &crate::ID",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Verified Account Owner Check"
  },
  {
    "sample_id": "SOL_V4_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account data length and structure integrity. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn initialize_user_account_safely(\n        ctx: Context<InitializeUserAccountSafely>,\n    ) -> Result<()> {\n        let user_account = &ctx.accounts.user_account;\n        let payer = &ctx.accounts.payer;\n        let expected_size = std::mem::size_of::<UserState>();\n        // SECURE: Check account data length before deserialization\n        require!(\n            user_account.data_len() >= expected_size,\n            ProgramError::InvalidAccountData\n        );\n        let account_data = user_account.try_borrow_data()?;\n        let user_state = UserState::try_from_slice(&account_data)?;\n        user_state.validate_state()?;\n        emit!(UserAccountInitializedSafely {\n            account: user_account.key(),\n            owner: payer.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeUserAccountSafely<'info> {\n    #[account(mut)]\n    pub user_account: AccountInfo<'info>,\n    pub payer: Signer<'info>,\n}\n\n#[account]\npub struct UserState {\n    pub bump: u8,\n    pub balance: u64,\n    pub nonce: u32,\n}\n\nimpl UserState {\n    fn validate_state(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct UserAccountInitializedSafely {\n    pub account: Pubkey,\n    pub owner: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Data Length Validated\nDescription: The contract validates the account buffer size before attempting deserialization. This prevents buffer underrun and ensures the account has sufficient space for the expected data structure.\nRisk Level: LOW\nValidation: Account data length checked against expected structure size",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Data Length Validation"
  },
  {
    "sample_id": "SOL_V4_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account types through discriminators and structure checks. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst EXPECTED_DISCRIMINATOR: [u8; 4] = [0x1a, 0x2b, 0x3c, 0x4d];\nconst EXPECTED_SIZE: usize = 41; // 4 (discriminator) + 32 (mint) + 1 (frozen) + 4 (padding)\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn process_token_config_safely(\n        ctx: Context<ProcessTokenConfigSafely>,\n    ) -> Result<()> {\n        let config_account = &ctx.accounts.config_account;\n        let config_data = config_account.try_borrow_data()?;\n        // SECURE: Check both discriminator and full structure size\n        require!(\n            config_data.len() >= EXPECTED_SIZE,\n            ProgramError::InvalidAccountData\n        );\n        require_eq!(\n            &config_data[..4],\n            &EXPECTED_DISCRIMINATOR,\n            ProgramError::InvalidAccountData\n        );\n        let token_config = TokenConfig::try_from_slice(&config_data)?;\n        token_config.process()?;\n        emit!(TokenConfigProcessedSafely {\n            config: config_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessTokenConfigSafely<'info> {\n    pub config_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct TokenConfig {\n    pub mint: Pubkey,\n    pub authority: Pubkey,\n    pub frozen: bool,\n}\n\nimpl TokenConfig {\n    fn process(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct TokenConfigProcessedSafely {\n    pub config: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Complete Type Validation\nDescription: The contract validates both the discriminator and the full structure size. This prevents type confusion by ensuring the account has the correct identifier and sufficient data for the expected structure.\nRisk Level: LOW\nValidation: Both discriminator and structure size verified",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Complete Type Validation"
  },
  {
    "sample_id": "SOL_V4_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account initialization status. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn process_user_data_safely(\n        ctx: Context<ProcessUserDataSafely>,\n    ) -> Result<()> {\n        let user_account = &ctx.accounts.user_account;\n        let user_data = user_account.try_borrow_data()?;\n        let user = UserData::try_from_slice(&user_data)?;\n        // SECURE: Check that account is properly initialized\n        require!(\n            user.is_initialized,\n            ProgramError::UninitializedAccount\n        );\n        let total_balance = user.available_balance + user.locked_balance;\n        require!(\n            total_balance > 0,\n            ProgramError::InvalidAccountData\n        );\n        emit!(UserDataProcessedSafely {\n            user: user_account.key(),\n            total: total_balance,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessUserDataSafely<'info> {\n    pub user_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct UserData {\n    pub is_initialized: bool,\n    pub owner: Pubkey,\n    pub available_balance: u64,\n    pub locked_balance: u64,\n}\n\n#[event]\npub struct UserDataProcessedSafely {\n    pub user: Pubkey,\n    pub total: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Initialization Validated\nDescription: The contract checks the is_initialized flag before processing account data. This ensures that only properly initialized accounts are processed, preventing logic errors from garbage data.\nRisk Level: LOW\nValidation: Initialization flag verified before processing",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Initialization Status Check"
  },
  {
    "sample_id": "SOL_V4_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account mutability and ownership together. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"YourProgramIDHere111111111111111111111111111\");\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn write_program_state_safely(\n        ctx: Context<WriteProgramStateSafely>,\n    ) -> Result<()> {\n        let state_account = &ctx.accounts.state_account;\n        // SECURE: Check both mutability and ownership\n        require!(\n            state_account.is_writable,\n            ProgramError::InvalidArgument\n        );\n        require!(\n            state_account.owner == &crate::ID,\n            ProgramError::IncorrectProgramId\n        );\n        let mut state_data = state_account.try_borrow_mut_data()?;\n        let state = ProgramState::try_from_slice(&state_data)?;\n        state.validate()?;\n        emit!(StateWrittenSafely {\n            account: state_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WriteProgramStateSafely<'info> {\n    #[account(mut)]\n    pub state_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct ProgramState {\n    pub version: u32,\n    pub data: [u8; 64],\n}\n\nimpl ProgramState {\n    fn validate(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct StateWrittenSafely {\n    pub account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Combined Ownership & Mutability Check\nDescription: The contract verifies both the is_writable flag and account ownership. This provides comprehensive access control by ensuring only writable accounts owned by the program can be modified.\nRisk Level: LOW\nValidation: Both is_writable and owner verified",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Dual Validation: Owner & Mutability"
  },
  {
    "sample_id": "SOL_V4_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates numeric type conversions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_SAFE_INDEX: u64 = 1_000_000;\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn access_array_element_safely(\n        ctx: Context<AccessArrayElementSafely>,\n        index: u64,\n    ) -> Result<()> {\n        let data_account = &ctx.accounts.data_account;\n        // SECURE: Validate u64 is within safe range before converting to usize\n        require!(\n            index < MAX_SAFE_INDEX,\n            ProgramError::InvalidArgument\n        );\n        let safe_index: usize = index as usize;\n        let data = data_account.try_borrow_data()?;\n        let array = DataArray::try_from_slice(&data)?;\n        require!(\n            safe_index < array.elements.len(),\n            ProgramError::InvalidArgument\n        );\n        let element = &array.elements[safe_index];\n        emit!(ElementAccessedSafely {\n            account: data_account.key(),\n            index,\n            value: element.value,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct AccessArrayElementSafely<'info> {\n    pub data_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct DataArray {\n    pub elements: Vec<ArrayElement>,\n}\n\n#[derive(Clone)]\npub struct ArrayElement {\n    pub value: u64,\n}\n\n#[event]\npub struct ElementAccessedSafely {\n    pub account: Pubkey,\n    pub index: u64,\n    pub value: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Safe Numeric Conversion\nDescription: The contract validates that the u64 input is within a safe range before converting it to usize. This prevents panic or out-of-bounds access on different system architectures.\nRisk Level: LOW\nValidation: Numeric conversion preceded by range check",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Validated Numeric Conversion"
  },
  {
    "sample_id": "SOL_V4_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates account executable status and type. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\ndeclare_id!(\"YourProgramIDHere111111111111111111111111111\");\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn verify_account_type_safely(\n        ctx: Context<VerifyAccountTypeSafely>,\n    ) -> Result<()> {\n        let data_account = &ctx.accounts.data_account;\n        // SECURE: Check is_executable and verify owner\n        require!(\n            !data_account.is_executable(),\n            ProgramError::InvalidArgument\n        );\n        require!(\n            data_account.owner == &crate::ID,\n            ProgramError::IncorrectProgramId\n        );\n        let account_data = data_account.try_borrow_data()?;\n        let account_info = AccountInfo::try_from_slice(&account_data)?;\n        account_info.process()?;\n        emit!(AccountTypeVerifiedSafely {\n            account: data_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct VerifyAccountTypeSafely<'info> {\n    pub data_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct AccountInfo {\n    pub account_type: u8,\n    pub data: Vec<u8>,\n}\n\nimpl AccountInfo {\n    fn process(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct AccountTypeVerifiedSafely {\n    pub account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Executable & Owner Checked\nDescription: The contract verifies both that the account is not executable AND that it's owned by the program. This comprehensive check prevents type confusion from accounts in other programs.\nRisk Level: LOW\nValidation: is_executable and owner both verified",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Executable & Owner Validation"
  },
  {
    "sample_id": "SOL_V4_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates string input size and content. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_NAME_LENGTH: usize = 64;\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn process_user_name_safely(\n        ctx: Context<ProcessUserNameSafely>,\n        name: String,\n    ) -> Result<()> {\n        let user_account = &ctx.accounts.user_account;\n        // SECURE: Validate string length before processing\n        require!(\n            name.len() <= MAX_NAME_LENGTH,\n            ProgramError::InvalidArgument\n        );\n        if name.contains(\"system\") {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let user_data = user_account.try_borrow_data()?;\n        let mut user = User::try_from_slice(&user_data)?;\n        user.name = name.clone();\n        emit!(UserNameUpdatedSafely {\n            user: user_account.key(),\n            name_length: name.len() as u32,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessUserNameSafely<'info> {\n    #[account(mut)]\n    pub user_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct User {\n    pub name: String,\n    pub balance: u64,\n}\n\n#[event]\npub struct UserNameUpdatedSafely {\n    pub user: Pubkey,\n    pub name_length: u32,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - String Length Validated\nDescription: The contract validates the string length before processing it. This prevents denial of service attacks that attempt to exhaust memory or compute resources with extremely large strings.\nRisk Level: LOW\nValidation: String length checked against maximum limit",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "String Length Validation"
  },
  {
    "sample_id": "SOL_V4_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates cross-program interaction accounts. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\nuse spl_token::ID as TOKEN_PROGRAM_ID;\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn use_external_token_account_safely(\n        ctx: Context<UseExternalTokenSafely>,\n    ) -> Result<()> {\n        let token_account = &ctx.accounts.token_account;\n        // SECURE: Verify account is owned by Token Program\n        require!(\n            token_account.owner == &TOKEN_PROGRAM_ID,\n            ProgramError::IncorrectProgramId\n        );\n        if token_account.is_executable() {\n            return Err(ProgramError::InvalidArgument.into());\n        }\n        let token_data = token_account.try_borrow_data()?;\n        let token_state = TokenAccount::try_from_slice(&token_data)?;\n        token_state.validate()?;\n        emit!(TokenAccountUsedSafely {\n            account: token_account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct UseExternalTokenSafely<'info> {\n    pub token_account: AccountInfo<'info>,\n}\n\n#[account]\npub struct TokenAccount {\n    pub mint: Pubkey,\n    pub owner: Pubkey,\n    pub amount: u64,\n}\n\nimpl TokenAccount {\n    fn validate(&self) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct TokenAccountUsedSafely {\n    pub account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Token Program ID Verified\nDescription: The contract verifies that the account is owned by the official Token Program before processing it. This prevents interaction with malicious token-like programs.\nRisk Level: LOW\nValidation: Account owner verified against spl_token::ID",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Token Program Validation"
  },
  {
    "sample_id": "SOL_V4_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for input validation flaws and type confusion vulnerabilities. Identify if the code properly validates fixed-size array input content. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_BYTE_VALUE: u8 = 100;\n\n#[program]\npub mod secure_input_validation {\n    use super::*;\n\n    pub fn process_config_bytes_safely(\n        ctx: Context<ProcessConfigBytesSafely>,\n        config: [u8; 32],\n    ) -> Result<()> {\n        let account = &ctx.accounts.account;\n        // SECURE: Validate all array elements before use\n        for byte in config.iter() {\n            require!(\n                *byte <= MAX_BYTE_VALUE,\n                ProgramError::InvalidArgument\n            );\n        }\n        let account_data = account.try_borrow_data()?;\n        let state = ConfigState::try_from_slice(&account_data)?;\n        state.apply_config(&config)?;\n        emit!(ConfigAppliedSafely {\n            account: account.key(),\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessConfigBytesSafely<'info> {\n    #[account(mut)]\n    pub account: AccountInfo<'info>,\n}\n\n#[account]\npub struct ConfigState {\n    pub config: [u8; 32],\n}\n\nimpl ConfigState {\n    fn apply_config(&self, config: &[u8; 32]) -> Result<()> {\n        Ok(())\n    }\n}\n\n#[event]\npub struct ConfigAppliedSafely {\n    pub account: Pubkey,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - All Array Elements Validated\nDescription: The contract validates every element of the configuration array against the maximum value. This ensures all configuration data is within acceptable bounds before processing.\nRisk Level: LOW\nValidation: All array elements checked against maximum value",
    "meta_platform": "Solana",
    "meta_vuln_type": "V4 - Lack of Input Validation",
    "meta_pattern": "Complete Array Element Validation"
  }
]
