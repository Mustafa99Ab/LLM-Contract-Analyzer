[
  {
    "sample_id": "SOL_V3_VULN_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify if the code has proper time validation, boundary checks, and correct business logic. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn execute_time_sensitive_action(\n        ctx: Context<TimeSensitiveAction>,\n    ) -> Result<()> {\n        let clock = Clock::get()?;\n        let user_account = &mut ctx.accounts.user_account;\n        // Using slot number for time-critical logic is problematic\n        // Validators can manipulate slot numbers slightly\n        if clock.slot % 100 != 0 {\n            return Err(ProgramError::Custom(1).into());\n        }\n        user_account.last_action_time = clock.slot;\n        emit!(ActionExecuted {\n            user: user_account.key(),\n            slot: clock.slot,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TimeSensitiveAction<'info> {\n    #[account(mut)]\n    pub user_account: Account<'info, UserAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct UserAccount {\n    pub last_action_time: u64,\n}\n\n#[event]\npub struct ActionExecuted {\n    pub user: Pubkey,\n    pub slot: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Time-Dependent Logic\nDescription: The contract uses block slot numbers for critical timing logic. Validators can manipulate slot progression, allowing attackers to bypass or trigger time-based conditions. This enables race conditions and time-of-check-time-of-use (TOCTOU) vulnerabilities.\nRisk Level: CRITICAL\nRecommendation: Use unix_timestamp from Clock instead: require!(clock.unix_timestamp > MIN_TIME, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Time-Dependent Logic with Slot Numbers"
  },
  {
    "sample_id": "SOL_V3_VULN_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify if the code has proper boundary checks and correct mathematical logic. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn transfer_with_allowance(\n        ctx: Context<TransferWithAllowance>,\n        amount: u64,\n    ) -> Result<()> {\n        let user = &mut ctx.accounts.user;\n        let allowance = &mut ctx.accounts.allowance;\n        // Flawed logic: allows transfer if amount <= balance + allowance\n        // Should only allow transfer if amount <= balance OR amount <= allowance\n        if amount > user.balance.saturating_add(allowance.amount) {\n            return Err(ProgramError::Custom(2).into());\n        }\n        user.balance = user.balance.saturating_sub(amount);\n        emit!(TransferProcessed {\n            amount,\n            new_balance: user.balance,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithAllowance<'info> {\n    #[account(mut)]\n    pub user: Account<'info, UserAccount>,\n    #[account(mut)]\n    pub allowance: Account<'info, AllowanceAccount>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[account]\npub struct AllowanceAccount {\n    pub amount: u64,\n}\n\n#[event]\npub struct TransferProcessed {\n    pub amount: u64,\n    pub new_balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Incorrect Balance Validation\nDescription: The contract permits transfers by summing user balance and allowance incorrectly. This allows a user with small balance and small allowance to transfer more than either individually allows, violating authorization semantics.\nRisk Level: CRITICAL\nRecommendation: Validate against actual balance: require!(amount <= user.balance, ...) or require!(amount <= allowance.amount, ...) based on intended logic",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Incorrect Balance Check Logic"
  },
  {
    "sample_id": "SOL_V3_VULN_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify off-by-one errors and boundary condition issues. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn process_batch_items(\n        ctx: Context<ProcessBatch>,\n        items: Vec<u64>,\n    ) -> Result<()> {\n        let batch_processor = &mut ctx.accounts.batch_processor;\n        let items_count = items.len();\n        // Off-by-one error: loop runs one less iteration than needed\n        for i in 0..items_count - 1 {\n            let item = items[i];\n            batch_processor.total += item;\n            batch_processor.item_count += 1;\n        }\n        emit!(BatchProcessed {\n            items_processed: batch_processor.item_count,\n            total: batch_processor.total,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessBatch<'info> {\n    #[account(mut)]\n    pub batch_processor: Account<'info, BatchProcessor>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct BatchProcessor {\n    pub total: u64,\n    pub item_count: u64,\n}\n\n#[event]\npub struct BatchProcessed {\n    pub items_processed: u64,\n    pub total: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Off-by-One Boundary\nDescription: The loop runs from 0 to items_count-1, skipping the last element in the array. This causes incomplete processing of batch data, leading to incorrect totals or missing transactions.\nRisk Level: CRITICAL\nRecommendation: Use correct loop bound: for i in 0..items_count instead of 0..items_count - 1",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Off-by-One Loop Error"
  },
  {
    "sample_id": "SOL_V3_VULN_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify unclear state validation and magic number usage. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst UNINITIALIZED: u8 = 0;\nconst INITIALIZED: u8 = 1;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn initialize_account(\n        ctx: Context<InitializeAccount>,\n    ) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        // Using magic number instead of clear constant\n        if account.status == 0 {\n            account.status = 1;\n            emit!(AccountInitialized {\n                account_key: account.key(),\n                status: 1,\n            });\n        } else {\n            return Err(ProgramError::Custom(3).into());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeAccount<'info> {\n    #[account(mut)]\n    pub account: Account<'info, ManagedAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct ManagedAccount {\n    pub status: u8,\n    pub owner: Pubkey,\n}\n\n#[event]\npub struct AccountInitialized {\n    pub account_key: Pubkey,\n    pub status: u8,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Magic Number State Validation\nDescription: The code uses hardcoded numeric values (0, 1) for state checking instead of clear named constants. This makes the code fragile and prone to misinterpretation, increasing the risk of state machine bugs.\nRisk Level: HIGH\nRecommendation: Use enum-based state: pub enum AccountStatus { Uninitialized = 0, Initialized = 1 } and check account.status == AccountStatus::Uninitialized",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Magic Number State Validation"
  },
  {
    "sample_id": "SOL_V3_VULN_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and arithmetic handling flaws. Identify improper error handling in arithmetic operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn withdraw_funds(\n        ctx: Context<WithdrawFunds>,\n        amount: u64,\n    ) -> Result<()> {\n        let user_account = &mut ctx.accounts.user_account;\n        let current_balance = user_account.balance;\n        // Using unwrap on checked arithmetic causes panic on underflow\n        let new_balance = current_balance.checked_sub(amount)\n            .unwrap_or_else(|| {\n                msg!(\"Withdrawal failed!\");\n                0 // Returns 0 on underflow, hiding the error\n            });\n        user_account.balance = new_balance;\n        emit!(WithdrawalProcessed {\n            amount,\n            new_balance,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawFunds<'info> {\n    #[account(mut)]\n    pub user_account: Account<'info, UserAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[event]\npub struct WithdrawalProcessed {\n    pub amount: u64,\n    pub new_balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Improper Arithmetic Error Handling\nDescription: The code uses unwrap_or_else to silently handle arithmetic underflow by setting balance to 0, masking the error. This allows invalid withdrawals to appear successful while secretly zeroing the balance.\nRisk Level: CRITICAL\nRecommendation: Return explicit error: let new_balance = current_balance.checked_sub(amount).ok_or(ProgramError::ArithmeticOverflow)?",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Improper Arithmetic Error Handling"
  },
  {
    "sample_id": "SOL_V3_VULN_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and boolean logic issues. Identify unclear boolean conditions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn check_permissions(\n        ctx: Context<CheckPermissions>,\n        is_admin: bool,\n        is_approved: bool,\n        is_active: bool,\n    ) -> Result<()> {\n        // Ambiguous boolean logic without parentheses\n        // Precedence: AND before OR, so this evaluates as: is_admin || (is_approved && is_active)\n        if is_admin || is_approved && is_active {\n            emit!(PermissionGranted {\n                reason: \"Logic condition met\".to_string(),\n            });\n        } else {\n            return Err(ProgramError::Custom(4).into());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CheckPermissions<'info> {\n    pub system_program: Program<'info, System>,\n}\n\n#[event]\npub struct PermissionGranted {\n    pub reason: String,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Ambiguous Boolean Logic\nDescription: The code uses boolean operators without explicit parentheses, relying on implicit operator precedence. This can lead to unintended execution paths when the intended logic is misunderstood or precedence rules change.\nRisk Level: HIGH\nRecommendation: Use explicit parentheses: if is_admin || (is_approved && is_active) or if (is_admin || is_approved) && is_active based on actual requirements",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Ambiguous Boolean Logic"
  },
  {
    "sample_id": "SOL_V3_VULN_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and data consistency issues. Identify stale data usage patterns. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn compare_account_states(\n        ctx: Context<CompareStates>,\n    ) -> Result<()> {\n        let account_a = &ctx.accounts.account_a;\n        let account_b = &ctx.accounts.account_b;\n        // Reading account_a data once and holding reference\n        let a_balance = account_a.balance;\n        let a_nonce = account_a.nonce;\n        // Long computation period where account_a could be modified\n        let mut total = 0u64;\n        for i in 0..1000 {\n            total += i;\n        }\n        // Using stale a_balance here without re-reading\n        let account_b = &mut ctx.accounts.account_b;\n        if a_balance > account_b.balance {\n            account_b.balance = a_balance;\n            emit!(BalanceUpdated {\n                new_balance: a_balance,\n            });\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CompareStates<'info> {\n    #[account(mut)]\n    pub account_a: Account<'info, StateAccount>,\n    #[account(mut)]\n    pub account_b: Account<'info, StateAccount>,\n}\n\n#[account]\npub struct StateAccount {\n    pub balance: u64,\n    pub nonce: u64,\n}\n\n#[event]\npub struct BalanceUpdated {\n    pub new_balance: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Stale Data Usage\nDescription: The contract reads account data once and uses it later after long computations without re-verification. In concurrent environments, account state may change, leading to decisions based on outdated information.\nRisk Level: HIGH\nRecommendation: Re-borrow and verify data freshness: let current_a_balance = account_a.reload()?.balance; before making critical decisions",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Stale Data Usage Pattern"
  },
  {
    "sample_id": "SOL_V3_VULN_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and input validation issues. Identify silent input clamping and implicit behavior changes. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_TRANSFER_AMOUNT: u64 = 1_000_000;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn transfer_with_clamping(\n        ctx: Context<TransferWithClamping>,\n        requested_amount: u64,\n    ) -> Result<()> {\n        let user = &mut ctx.accounts.user;\n        let mut actual_amount = requested_amount;\n        // Silent clamping: adjusts input without user knowledge\n        if actual_amount > MAX_TRANSFER_AMOUNT {\n            actual_amount = MAX_TRANSFER_AMOUNT;\n        }\n        user.balance = user.balance.saturating_sub(actual_amount);\n        emit!(TransferExecuted {\n            requested: requested_amount,\n            executed: actual_amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithClamping<'info> {\n    #[account(mut)]\n    pub user: Account<'info, UserAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferExecuted {\n    pub requested: u64,\n    pub executed: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Silent Input Clamping\nDescription: The contract silently clamps user input to a maximum value without returning an error. This causes transactions to execute with different amounts than requested, confusing users and potentially creating arbitrage opportunities.\nRisk Level: HIGH\nRecommendation: Explicitly reject invalid input: if requested_amount > MAX_TRANSFER_AMOUNT { return Err(ProgramError::InvalidArgument); }",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Silent Input Clamping"
  },
  {
    "sample_id": "SOL_V3_VULN_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and efficiency issues. Identify missing edge case handling. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn transfer_between_accounts(\n        ctx: Context<TransferBetweenAccounts>,\n        amount: u64,\n    ) -> Result<()> {\n        let sender = &mut ctx.accounts.sender;\n        let receiver = &mut ctx.accounts.receiver;\n        // Missing check: sender could transfer to themselves\n        // This wastes computation and is logically unnecessary\n        if amount > sender.balance {\n            return Err(ProgramError::Custom(5).into());\n        }\n        sender.balance = sender.balance.saturating_sub(amount);\n        receiver.balance = receiver.balance.saturating_add(amount);\n        emit!(TransferCompleted {\n            from: sender.key(),\n            to: receiver.key(),\n            amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferBetweenAccounts<'info> {\n    #[account(mut)]\n    pub sender: Account<'info, UserAccount>,\n    #[account(mut)]\n    pub receiver: Account<'info, UserAccount>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferCompleted {\n    pub from: Pubkey,\n    pub to: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Missing Self-Transfer Check\nDescription: The contract allows users to transfer funds to themselves, which wastes computation resources without providing any value. This is an inefficiency that should be caught early.\nRisk Level: MEDIUM\nRecommendation: Add early check: if sender.key() == receiver.key() { return Err(ProgramError::Custom(5)); }",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Missing Self-Transfer Check"
  },
  {
    "sample_id": "SOL_V3_VULN_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and comparison logic flaws. Identify inverted or incorrect comparison operators. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MIN_FEE_REQUIRED: u64 = 1000;\nconst MAX_FEE_ALLOWED: u64 = 100_000;\n\n#[program]\npub mod vulnerable_logic {\n    use super::*;\n\n    pub fn process_transaction_with_fee(\n        ctx: Context<ProcessTransaction>,\n        fee: u64,\n    ) -> Result<()> {\n        let transaction = &mut ctx.accounts.transaction;\n        // Inverted logic: checking MIN_FEE but allowing amounts above MAX_FEE\n        if fee < MIN_FEE_REQUIRED {\n            return Err(ProgramError::Custom(6).into());\n        }\n        // Should also check: fee <= MAX_FEE_ALLOWED, but this is missing\n        transaction.fee = fee;\n        emit!(TransactionFeeSet {\n            fee,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessTransaction<'info> {\n    #[account(mut)]\n    pub transaction: Account<'info, TransactionState>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct TransactionState {\n    pub fee: u64,\n}\n\n#[event]\npub struct TransactionFeeSet {\n    pub fee: u64,\n}",
    "output": "Status: VULNERABLE\nVulnerability Type: Logic Error - Inverted Comparison Logic\nDescription: The code checks for minimum fee but fails to enforce maximum fee limits. This allows transactions with excessively high fees to proceed, potentially enabling fee-based denial-of-service or value extraction attacks.\nRisk Level: HIGH\nRecommendation: Add maximum fee validation: require!(fee <= MAX_FEE_ALLOWED, ...)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Incomplete Comparison Logic"
  }
]
[
  {
    "sample_id": "SOL_V3_SAFE_001",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify if the code has proper time validation, boundary checks, and correct business logic. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MIN_TIMESTAMP_THRESHOLD: i64 = 1_700_000_000;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn execute_time_sensitive_action_safely(\n        ctx: Context<TimeSensitiveAction>,\n    ) -> Result<()> {\n        let clock = Clock::get()?;\n        let user_account = &mut ctx.accounts.user_account;\n        // SECURE: Using unix_timestamp instead of slot for time-critical logic\n        // unix_timestamp is more difficult to manipulate and is standardized\n        require!(\n            clock.unix_timestamp >= MIN_TIMESTAMP_THRESHOLD,\n            ProgramError::Custom(1)\n        );\n        user_account.last_action_time = clock.unix_timestamp as u64;\n        emit!(ActionExecutedSafely {\n            user: user_account.key(),\n            timestamp: clock.unix_timestamp,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TimeSensitiveAction<'info> {\n    #[account(mut)]\n    pub user_account: Account<'info, UserAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct UserAccount {\n    pub last_action_time: u64,\n}\n\n#[event]\npub struct ActionExecutedSafely {\n    pub user: Pubkey,\n    pub timestamp: i64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Time Validation Secure\nDescription: The contract uses unix_timestamp from the Clock for time-critical decisions instead of slot numbers. This is more resistant to validator manipulation and provides consistent timing semantics across the network.\nRisk Level: LOW\nValidation: Uses unix_timestamp instead of slot for time-dependent logic",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Secure Time-Dependent Logic"
  },
  {
    "sample_id": "SOL_V3_SAFE_002",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify if the code has proper boundary checks and correct mathematical logic. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn transfer_with_balance_check(\n        ctx: Context<TransferWithBalance>,\n        amount: u64,\n    ) -> Result<()> {\n        let user = &mut ctx.accounts.user;\n        // SECURE: Proper balance check - amount must not exceed actual balance\n        require!(\n            amount <= user.balance,\n            ProgramError::Custom(2)\n        );\n        user.balance = user.balance.saturating_sub(amount);\n        emit!(TransferProcessedSafely {\n            amount,\n            remaining_balance: user.balance,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithBalance<'info> {\n    #[account(mut)]\n    pub user: Account<'info, UserAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferProcessedSafely {\n    pub amount: u64,\n    pub remaining_balance: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Balance Validation Correct\nDescription: The contract correctly validates that the transfer amount does not exceed the user's actual balance. This prevents overdrafts and unauthorized spending.\nRisk Level: LOW\nValidation: Amount checked against actual user balance before transfer",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Correct Balance Validation"
  },
  {
    "sample_id": "SOL_V3_SAFE_003",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify off-by-one errors and boundary condition issues. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn process_all_batch_items(\n        ctx: Context<ProcessBatch>,\n        items: Vec<u64>,\n    ) -> Result<()> {\n        let batch_processor = &mut ctx.accounts.batch_processor;\n        let items_count = items.len();\n        // SECURE: Loop correctly iterates through all items (0 to items_count-1)\n        for i in 0..items_count {\n            let item = items[i];\n            batch_processor.total = batch_processor.total.saturating_add(item);\n            batch_processor.item_count = batch_processor.item_count.saturating_add(1);\n        }\n        emit!(BatchProcessedSafely {\n            items_processed: batch_processor.item_count,\n            total: batch_processor.total,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessBatch<'info> {\n    #[account(mut)]\n    pub batch_processor: Account<'info, BatchProcessor>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct BatchProcessor {\n    pub total: u64,\n    pub item_count: u64,\n}\n\n#[event]\npub struct BatchProcessedSafely {\n    pub items_processed: u64,\n    pub total: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Loop Bounds Correct\nDescription: The contract uses the correct loop boundary (0..items_count) to process all items in the batch without skipping any elements.\nRisk Level: LOW\nValidation: Loop correctly covers all elements from 0 to items_count-1",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Correct Loop Boundaries"
  },
  {
    "sample_id": "SOL_V3_SAFE_004",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and algorithmic flaws. Identify unclear state validation and magic number usage. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[repr(u8)]\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum AccountStatus {\n    Uninitialized = 0,\n    Initialized = 1,\n    Locked = 2,\n}\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn initialize_account_safely(\n        ctx: Context<InitializeAccountSafely>,\n    ) -> Result<()> {\n        let account = &mut ctx.accounts.account;\n        // SECURE: Using clear enum instead of magic numbers\n        require_eq!(\n            account.status,\n            0u8,\n            ProgramError::Custom(3)\n        );\n        account.status = AccountStatus::Initialized as u8;\n        emit!(AccountInitializedSafely {\n            account_key: account.key(),\n            status: AccountStatus::Initialized as u8,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct InitializeAccountSafely<'info> {\n    #[account(mut)]\n    pub account: Account<'info, ManagedAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct ManagedAccount {\n    pub status: u8,\n    pub owner: Pubkey,\n}\n\n#[event]\npub struct AccountInitializedSafely {\n    pub account_key: Pubkey,\n    pub status: u8,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Clear State Validation\nDescription: The contract uses a well-defined enum for account status instead of magic numbers, making the state transitions clear and reducing the risk of state machine errors.\nRisk Level: LOW\nValidation: Uses enum-based status with explicit constants",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Enum-Based State Validation"
  },
  {
    "sample_id": "SOL_V3_SAFE_005",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and arithmetic handling flaws. Identify improper error handling in arithmetic operations. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn withdraw_funds_safely(\n        ctx: Context<WithdrawFundsSafely>,\n        amount: u64,\n    ) -> Result<()> {\n        let user_account = &mut ctx.accounts.user_account;\n        let current_balance = user_account.balance;\n        // SECURE: Using ok_or to return explicit error on arithmetic failure\n        let new_balance = current_balance\n            .checked_sub(amount)\n            .ok_or(ProgramError::InsufficientFunds)?;\n        user_account.balance = new_balance;\n        emit!(WithdrawalProcessedSafely {\n            amount,\n            new_balance,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct WithdrawFundsSafely<'info> {\n    #[account(mut)]\n    pub user_account: Account<'info, UserAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[event]\npub struct WithdrawalProcessedSafely {\n    pub amount: u64,\n    pub new_balance: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Arithmetic Errors Handled Correctly\nDescription: The contract uses ok_or to gracefully handle arithmetic underflow, returning an explicit error instead of silently masking the failure.\nRisk Level: LOW\nValidation: Uses checked_sub with ok_or for proper error propagation",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Graceful Arithmetic Error Handling"
  },
  {
    "sample_id": "SOL_V3_SAFE_006",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and boolean logic issues. Identify unclear boolean conditions. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn check_permissions_safely(\n        ctx: Context<CheckPermissionsSafely>,\n        is_admin: bool,\n        is_approved: bool,\n        is_active: bool,\n    ) -> Result<()> {\n        // SECURE: Using explicit parentheses to enforce intended precedence\n        // Condition: User must be admin OR (both approved AND active)\n        if is_admin || (is_approved && is_active) {\n            emit!(PermissionGrantedSafely {\n                reason: \"User meets permission requirements\".to_string(),\n            });\n        } else {\n            return Err(ProgramError::Custom(4).into());\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CheckPermissionsSafely<'info> {\n    pub system_program: Program<'info, System>,\n}\n\n#[event]\npub struct PermissionGrantedSafely {\n    pub reason: String,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Boolean Logic Clear\nDescription: The contract uses explicit parentheses to make boolean logic unambiguous and clearly express the intended permission model.\nRisk Level: LOW\nValidation: Boolean conditions use explicit parentheses for clarity",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Clear Boolean Logic with Parentheses"
  },
  {
    "sample_id": "SOL_V3_SAFE_007",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and data consistency issues. Identify stale data usage patterns. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn compare_account_states_safely(\n        ctx: Context<CompareStatesSafely>,\n    ) -> Result<()> {\n        let account_a = &ctx.accounts.account_a;\n        let account_b = &mut ctx.accounts.account_b;\n        // SECURE: Minimized scope of borrowed data\n        // All data reading happens within limited scope\n        let a_balance = account_a.balance;\n        // Simple calculation (no long-running computation)\n        if a_balance > account_b.balance {\n            account_b.balance = a_balance;\n            emit!(BalanceUpdatedSafely {\n                new_balance: a_balance,\n            });\n        }\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct CompareStatesSafely<'info> {\n    pub account_a: Account<'info, StateAccount>,\n    #[account(mut)]\n    pub account_b: Account<'info, StateAccount>,\n}\n\n#[account]\npub struct StateAccount {\n    pub balance: u64,\n    pub nonce: u64,\n}\n\n#[event]\npub struct BalanceUpdatedSafely {\n    pub new_balance: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Data Usage Consistent\nDescription: The contract minimizes the time between reading account data and using it, reducing the risk of stale data usage in state comparisons.\nRisk Level: LOW\nValidation: Data reading and usage kept in minimal scope",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Minimal Scope Data Usage"
  },
  {
    "sample_id": "SOL_V3_SAFE_008",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and input validation issues. Identify silent input clamping and implicit behavior changes. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MAX_TRANSFER_AMOUNT: u64 = 1_000_000;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn transfer_with_explicit_validation(\n        ctx: Context<TransferWithValidation>,\n        requested_amount: u64,\n    ) -> Result<()> {\n        let user = &mut ctx.accounts.user;\n        // SECURE: Explicitly reject invalid input instead of silently clamping\n        require!(\n            requested_amount <= MAX_TRANSFER_AMOUNT,\n            ProgramError::InvalidArgument\n        );\n        user.balance = user.balance.saturating_sub(requested_amount);\n        emit!(TransferExecutedSafely {\n            amount: requested_amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferWithValidation<'info> {\n    #[account(mut)]\n    pub user: Account<'info, UserAccount>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferExecutedSafely {\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Input Validation Explicit\nDescription: The contract explicitly rejects input that exceeds safe bounds instead of silently modifying the request. This prevents confusion and ensures transactions behave as expected.\nRisk Level: LOW\nValidation: Explicit error return for invalid input amounts",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Explicit Input Validation"
  },
  {
    "sample_id": "SOL_V3_SAFE_009",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and efficiency issues. Identify missing edge case handling. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn transfer_between_accounts_safely(\n        ctx: Context<TransferBetweenAccountsSafely>,\n        amount: u64,\n    ) -> Result<()> {\n        let sender = &mut ctx.accounts.sender;\n        let receiver = &mut ctx.accounts.receiver;\n        // SECURE: Early check to prevent self-transfers\n        require!(\n            sender.key() != receiver.key(),\n            ProgramError::Custom(5)\n        );\n        require!(\n            amount <= sender.balance,\n            ProgramError::InsufficientFunds\n        );\n        sender.balance = sender.balance.saturating_sub(amount);\n        receiver.balance = receiver.balance.saturating_add(amount);\n        emit!(TransferCompletedSafely {\n            from: sender.key(),\n            to: receiver.key(),\n            amount,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct TransferBetweenAccountsSafely<'info> {\n    #[account(mut)]\n    pub sender: Account<'info, UserAccount>,\n    #[account(mut)]\n    pub receiver: Account<'info, UserAccount>,\n}\n\n#[account]\npub struct UserAccount {\n    pub balance: u64,\n}\n\n#[event]\npub struct TransferCompletedSafely {\n    pub from: Pubkey,\n    pub to: Pubkey,\n    pub amount: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Edge Cases Handled\nDescription: The contract includes a check to prevent self-transfers early in execution, saving computation resources and improving efficiency.\nRisk Level: LOW\nValidation: Self-transfer check prevents unnecessary operations",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Self-Transfer Prevention"
  },
  {
    "sample_id": "SOL_V3_SAFE_010",
    "instruction": "You are a smart contract security analyzer for Solana. Analyze the following Rust/Anchor smart contract code for logic errors and comparison logic flaws. Identify inverted or incorrect comparison operators. Output your assessment.",
    "input": "use anchor_lang::prelude::*;\n\nconst MIN_FEE_REQUIRED: u64 = 1000;\nconst MAX_FEE_ALLOWED: u64 = 100_000;\n\n#[program]\npub mod secure_logic {\n    use super::*;\n\n    pub fn process_transaction_with_fee_safely(\n        ctx: Context<ProcessTransactionSafely>,\n        fee: u64,\n    ) -> Result<()> {\n        let transaction = &mut ctx.accounts.transaction;\n        // SECURE: Both minimum and maximum fee bounds are enforced\n        require!(\n            fee >= MIN_FEE_REQUIRED,\n            ProgramError::Custom(6)\n        );\n        require!(\n            fee <= MAX_FEE_ALLOWED,\n            ProgramError::InvalidArgument\n        );\n        transaction.fee = fee;\n        emit!(TransactionFeeSetSafely {\n            fee,\n        });\n        Ok(())\n    }\n}\n\n#[derive(Accounts)]\npub struct ProcessTransactionSafely<'info> {\n    #[account(mut)]\n    pub transaction: Account<'info, TransactionState>,\n    pub system_program: Program<'info, System>,\n}\n\n#[account]\npub struct TransactionState {\n    pub fee: u64,\n}\n\n#[event]\npub struct TransactionFeeSetSafely {\n    pub fee: u64,\n}",
    "output": "Status: SAFE\nVulnerability Type: N/A - Comparison Logic Complete\nDescription: The contract enforces both minimum and maximum fee boundaries, preventing both underpriced and excessively expensive fee transactions.\nRisk Level: LOW\nValidation: Dual boundary checks on fee (minimum and maximum)",
    "meta_platform": "Solana",
    "meta_vuln_type": "V3 - Logic Errors",
    "meta_pattern": "Complete Boundary Validation"
  }
]
