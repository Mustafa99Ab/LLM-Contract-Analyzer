[
  {
    "id": "ALG_V1_001",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "You are a smart contract security analyzer for Algorand. Analyze the PyTeal code for unauthorized state modifications.",
    "input": "def approval_program():\n    # Admin initialization function - VULNERABLE: No check that contract is being created\n    initialize_admin = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"init\")),\n        # VULN: Anyone can reinitialize and claim admin role\n        App.globalPut(Bytes(\"admin\"), Txn.sender()),\n        App.globalPut(Bytes(\"initialized\"), Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Fund withdrawal - VULNERABLE: No admin check\n    withdraw_funds = Seq([\n        Assert(Len(Txn.application_args[1]) > Int(0)),\n        # VULN: No verification that sender is admin\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.accounts[1],\n            TxnField.amount: Btoi(Txn.application_args[1]),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), initialize_admin],\n        [Txn.application_args[0] == Bytes(\"withdraw\"), withdraw_funds]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Arbitrary Fund Withdrawal\nDescription: The contract allows any caller to initialize the admin role multiple times and withdraw contract funds without verifying if the sender is authorized. An attacker can claim admin privileges and drain the contract balance.\nAffected Lines: Lines with App.globalPut and withdraw_funds function\nImpact: Complete loss of contract funds, unauthorized state manipulation\nCVSS Score: 9.8 (Critical)",
    "remediation": "1. Add check that initialization only occurs when Txn.application_id() == Int(0)\n2. Add Assert(Txn.sender() == App.globalGet(Bytes('admin'))) before fund transfer\n3. Use verified admin address from initialization",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-284: Improper Access Control"
  },
  {
    "id": "ALG_V1_002",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized asset transfers.",
    "input": "def approval_program():\n    # Token minting function - VULNERABLE: No ownership check\n    mint_tokens = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"mint\")),\n        Assert(Len(Txn.application_args[1]) > Int(0)),\n        # VULN: Anyone can mint tokens and assign to arbitrary account\n        App.globalPut(Bytes(\"supply\"), \n            App.globalGet(Bytes(\"supply\")) + Btoi(Txn.application_args[1])),\n        App.localPut(Txn.accounts[1], Bytes(\"balance\"), \n            App.localGet(Txn.accounts[1], Bytes(\"balance\")) + Btoi(Txn.application_args[1])),\n        Return(Int(1))\n    ])\n    \n    # Burn function - VULNERABLE: No authorization\n    burn_tokens = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"burn\")),\n        # VULN: No check that caller owns tokens being burned\n        App.localPut(Txn.accounts[1], Bytes(\"balance\"),\n            App.localGet(Txn.accounts[1], Bytes(\"balance\")) - Btoi(Txn.application_args[1])),\n        App.globalPut(Bytes(\"supply\"),\n            App.globalGet(Bytes(\"supply\")) - Btoi(Txn.application_args[1])),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.application_args[0] == Bytes(\"mint\"), mint_tokens],\n        [Txn.application_args[0] == Bytes(\"burn\"), burn_tokens]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Token Minting and Burning\nDescription: The contract permits arbitrary token creation and destruction without verifying the caller's authorization. An attacker can arbitrarily mint tokens to any account or burn tokens from other users' balances, breaking token supply invariants.\nAffected Lines: mint_tokens and burn_tokens functions lack authorization checks\nImpact: Total compromise of token supply integrity, loss of user funds\nCVSS Score: 10.0 (Critical)",
    "remediation": "1. Store authorized minter address in global state\n2. Add Assert(Txn.sender() == App.globalGet(Bytes('minter'))) in mint_tokens\n3. Add Assert(Txn.sender() == Txn.accounts[1]) in burn_tokens\n4. Implement proper authorization matrix for token operations",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-269: Improper Control of Dynamically-Managed Code Resources"
  },
  {
    "id": "ALG_V1_003",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized application deletion.",
    "input": "def approval_program():\n    # Update contract owner - VULNERABLE: No ownership verification\n    change_owner = Seq([\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Address length check only\n        # VULN: No verification that caller is current owner\n        App.globalPut(Bytes(\"owner\"), Txn.application_args[1]),\n        Return(Int(1))\n    ])\n    \n    # Delete application - VULNERABLE: No access control\n    delete_app = Seq([\n        # VULN: Any user can trigger application deletion\n        Assert(Txn.on_completion() == OnComplete.DeleteApplication),\n        Return(Int(1))\n    ])\n    \n    # Transfer contract balance - VULNERABLE: Not restricted to owner\n    transfer_balance = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"transfer\")),\n        # VULN: Missing sender verification - allows arbitrary balance transfer\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.accounts[1],\n            TxnField.amount: Txn.amount() / Int(2),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.application_args[0] == Bytes(\"change_owner\"), change_owner],\n        [Txn.on_completion() == OnComplete.DeleteApplication, delete_app],\n        [Txn.application_args[0] == Bytes(\"transfer\"), transfer_balance]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Application Deletion and Owner Modification\nDescription: The contract lacks proper access control for critical operations. Any user can change the owner address or trigger application deletion, leading to loss of contract control and funds.\nAffected Lines: change_owner, delete_app, and transfer_balance functions\nImpact: Complete contract takeover, unauthorized fund transfers, application unavailability\nCVSS Score: 9.9 (Critical)",
    "remediation": "1. Add Assert(Txn.sender() == App.globalGet(Bytes('owner'))) to change_owner\n2. Add same ownership check to delete_app function\n3. Add ownership verification to transfer_balance before any state changes\n4. Consider implementing multi-signature for critical operations",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-276: Incorrect Default Permissions"
  },
  {
    "id": "ALG_V1_004",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized escrow operations.",
    "input": "def approval_program():\n    # Create escrow agreement - VULNERABLE: Insufficient validation\n    create_escrow = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"create_escrow\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # buyer address\n        Assert(Len(Txn.application_args[2]) == Int(32)),  # seller address\n        # VULN: No verification that caller is buyer or seller\n        App.globalPut(Bytes(\"buyer\"), Txn.application_args[1]),\n        App.globalPut(Bytes(\"seller\"), Txn.application_args[2]),\n        App.globalPut(Bytes(\"amount\"), Btoi(Txn.application_args[3])),\n        App.globalPut(Bytes(\"status\"), Bytes(\"pending\")),\n        Return(Int(1))\n    ])\n    \n    # Release escrow - VULNERABLE: No authorization\n    release_escrow = Seq([\n        Assert(App.globalGet(Bytes(\"status\")) == Bytes(\"pending\")),\n        # VULN: Anyone can release funds regardless of escrow terms\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: App.globalGet(Bytes(\"seller\")),\n            TxnField.amount: App.globalGet(Bytes(\"amount\")),\n        }),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(Bytes(\"status\"), Bytes(\"released\")),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.application_args[0] == Bytes(\"create_escrow\"), create_escrow],\n        [Txn.application_args[0] == Bytes(\"release\"), release_escrow]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Escrow Release\nDescription: The escrow contract allows anyone to create agreements with arbitrary parties and release funds without proper authorization. An attacker can intercept agreements and redirect funds to unauthorized recipients.\nAffected Lines: create_escrow and release_escrow functions\nImpact: Theft of escrowed funds, unauthorized transaction execution\nCVSS Score: 9.8 (Critical)",
    "remediation": "1. Add Assert(Txn.sender() == Txn.application_args[1]) to verify caller is buyer\n2. Require seller signature in release_escrow function\n3. Implement multi-signature release mechanism\n4. Add timestamp-based dispute resolution",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-437: Incomplete Type Validation"
  },
  {
    "id": "ALG_V1_005",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "HIGH",
    "instruction": "Analyze the PyTeal contract for unauthorized parameter modification.",
    "input": "def approval_program():\n    # Initialize governance parameters\n    init_params = Seq([\n        Assert(Txn.application_id() == Int(0)),\n        App.globalPut(Bytes(\"fee_percent\"), Int(100)),  # 1% fee\n        App.globalPut(Bytes(\"fee_recipient\"), Txn.sender()),\n        App.globalPut(Bytes(\"paused\"), Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Update fee - VULNERABLE: No authorization check\n    update_fee = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"set_fee\")),\n        Assert(Btoi(Txn.application_args[1]) <= Int(10000)),  # Range check only\n        # VULN: No verification that sender is authorized admin\n        App.globalPut(Bytes(\"fee_percent\"), Btoi(Txn.application_args[1])),\n        Return(Int(1))\n    ])\n    \n    # Update fee recipient - VULNERABLE: Not restricted\n    update_recipient = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"set_recipient\")),\n        # VULN: Anyone can change fee recipient address\n        App.globalPut(Bytes(\"fee_recipient\"), Txn.application_args[1]),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), init_params],\n        [Txn.application_args[0] == Bytes(\"set_fee\"), update_fee],\n        [Txn.application_args[0] == Bytes(\"set_recipient\"), update_recipient]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Fee Parameter Modification\nDescription: The contract permits any user to modify critical fee parameters and redirect fee receipts. An attacker can set arbitrary fees or redirect all contract revenue to their address.\nAffected Lines: update_fee and update_recipient functions\nImpact: Loss of protocol revenue, unauthorized fee collection\nCVSS Score: 8.6 (High)",
    "remediation": "1. Store admin address in global state during initialization\n2. Add Assert(Txn.sender() == App.globalGet(Bytes('admin'))) to both functions\n3. Implement multi-step fee changes with time locks\n4. Add event logging for all parameter updates",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-668: Exposure of Resource to Wrong Sphere"
  },
  {
    "id": "ALG_V1_006",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized asset custody operations.",
    "input": "def approval_program():\n    # Multi-asset custody contract\n    deposit_asset = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"deposit\")),\n        Assert(Txn.xfer_asset_amount() > Int(0)),\n        # VULN: No verification that depositor is account owner\n        App.localPut(Txn.sender(), Bytes(\"deposited_amount\"),\n            App.localGet(Txn.sender(), Bytes(\"deposited_amount\")) + Txn.xfer_asset_amount()),\n        Return(Int(1))\n    ])\n    \n    # Withdraw asset - VULNERABLE: Missing sender verification\n    withdraw_asset = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"withdraw\")),\n        Assert(Txn.application_args[1] == Bytes(\"asset_id\")),\n        # VULN: No check that caller is account owner\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.asset_receiver: Txn.accounts[1],\n            TxnField.asset_amount: Btoi(Txn.application_args[2]),\n            TxnField.xfer_asset: Btoi(Txn.application_args[3]),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n    \n    # Update account permission - VULNERABLE: No authorization\n    update_perms = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"set_perms\")),\n        # VULN: Anyone can modify any account's permissions\n        App.localPut(Txn.accounts[1], Bytes(\"can_withdraw\"), Int(1)),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.application_args[0] == Bytes(\"deposit\"), deposit_asset],\n        [Txn.application_args[0] == Bytes(\"withdraw\"), withdraw_asset],\n        [Txn.application_args[0] == Bytes(\"set_perms\"), update_perms]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Asset Custody and Withdrawal\nDescription: The custody contract allows arbitrary asset withdrawal and permission modification without proper authorization. An attacker can withdraw any user's deposited assets or grant withdrawal permissions to unauthorized addresses.\nAffected Lines: withdraw_asset and update_perms functions\nImpact: Complete loss of custody assets, unauthorized permission escalation\nCVSS Score: 10.0 (Critical)",
    "remediation": "1. Add Assert(Txn.sender() == Txn.accounts[1]) to verify caller owns the account\n2. Require explicit permission checking before withdrawals\n3. Implement time-locked withdrawal requests\n4. Use account-based permission checks, not global admin",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-639: Authorization Bypass Through User-Controlled Key"
  },
  {
    "id": "ALG_V1_007",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized voting mechanism.",
    "input": "def approval_program():\n    # Governance voting - VULNERABLE: No voter authorization\n    cast_vote = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"vote\")),\n        Assert(Txn.application_args[1] == Bytes(\"proposal_id\")),\n        Assert(Or(\n            Txn.application_args[2] == Bytes(\"yes\"),\n            Txn.application_args[2] == Bytes(\"no\")\n        )),\n        # VULN: No verification that sender has voting power\n        App.localPut(Txn.sender(), Bytes(\"voted\"), Int(1)),\n        App.localPut(Txn.sender(), Bytes(\"vote_choice\"), Txn.application_args[2]),\n        # VULN: Anyone can vote multiple times\n        If(Txn.application_args[2] == Bytes(\"yes\"),\n            App.globalPut(Bytes(\"yes_votes\"), \n                App.globalGet(Bytes(\"yes_votes\")) + Int(1)),\n            App.globalPut(Bytes(\"no_votes\"),\n                App.globalGet(Bytes(\"no_votes\")) + Int(1))\n        ),\n        Return(Int(1))\n    ])\n    \n    # Execute proposal - VULNERABLE: No authorization\n    execute_proposal = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"execute\")),\n        # VULN: Anyone can execute proposals\n        App.globalPut(Bytes(\"proposal_executed\"), Int(1)),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.application_args[0] == Bytes(\"vote\"), cast_vote],\n        [Txn.application_args[0] == Bytes(\"execute\"), execute_proposal]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Voting and Proposal Execution\nDescription: The governance contract permits any user to vote multiple times and execute proposals without authorization. An attacker can manipulate voting outcomes and trigger unauthorized governance actions.\nAffected Lines: cast_vote and execute_proposal functions\nImpact: Governance takeover, invalid proposal execution, loss of voting integrity\nCVSS Score: 9.9 (Critical)",
    "remediation": "1. Maintain a register of eligible voters with stake/token holdings\n2. Add Assert(App.localGet(Txn.sender(), Bytes('stake')) > Int(0)) to cast_vote\n3. Check vote already cast: Assert(App.localGet(Txn.sender(), Bytes('voted_proposal_id')) != Btoi(Txn.application_args[1]))\n4. Require multi-signature approval for execute_proposal\n5. Implement time-based voting windows",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-284: Improper Access Control"
  },
  {
    "id": "ALG_V1_008",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized financial operation controls.",
    "input": "def approval_program():\n    # Staking contract - VULNERABLE: No staker verification\n    stake_funds = Seq([\n        Assert(Txn.amount() > Int(0)),\n        # VULN: No verification that sender is legitimate staker\n        App.localPut(Txn.accounts[1], Bytes(\"staked_amount\"),\n            App.localGet(Txn.accounts[1], Bytes(\"staked_amount\")) + Txn.amount()),\n        App.localPut(Txn.accounts[1], Bytes(\"stake_time\"), Global.latest_confirmed_block()),\n        Return(Int(1))\n    ])\n    \n    # Claim rewards - VULNERABLE: No authorization\n    claim_rewards = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"claim\")),\n        # VULN: Anyone can claim rewards for any account\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.accounts[1],\n            TxnField.amount: Btoi(Txn.application_args[1]),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n    \n    # Unstake - VULNERABLE: Restricted access\n    unstake_funds = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"unstake\")),\n        # VULN: No check that caller is stake owner\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.accounts[1],\n            TxnField.amount: App.localGet(Txn.accounts[1], Bytes(\"staked_amount\")),\n        }),\n        InnerTxnBuilder.Submit(),\n        App.localDel(Txn.accounts[1], Bytes(\"staked_amount\")),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.on_completion() == OnComplete.NoOp, stake_funds],\n        [Txn.application_args[0] == Bytes(\"claim\"), claim_rewards],\n        [Txn.application_args[0] == Bytes(\"unstake\"), unstake_funds]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Staking and Reward Claim\nDescription: The staking contract lacks proper sender verification, allowing attackers to stake funds for arbitrary accounts, claim unearned rewards, and withdraw stakes belonging to other users.\nAffected Lines: stake_funds, claim_rewards, and unstake_funds functions\nImpact: Loss of staked funds, unauthorized reward distribution, protocol economic breakdown\nCVSS Score: 10.0 (Critical)",
    "remediation": "1. In stake_funds: Assert(Txn.sender() == Txn.accounts[1])\n2. In claim_rewards: Assert(Txn.sender() == Txn.accounts[1]) and verify reward eligibility\n3. In unstake_funds: Assert(Txn.sender() == Txn.accounts[1])\n4. Implement reward calculation based on stake duration\n5. Add withdrawal lock-up periods",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-862: Missing Authorization"
  },
  {
    "id": "ALG_V1_009",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized contract management operations.",
    "input": "def approval_program():\n    # Setup contract - No owner set initially\n    setup = Seq([\n        Assert(Txn.application_id() == Int(0)),\n        App.globalPut(Bytes(\"total_users\"), Int(0)),\n        App.globalPut(Bytes(\"contract_active\"), Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Pause contract - VULNERABLE: No authorization\n    pause_contract = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"pause\")),\n        # VULN: No admin check before pausing\n        App.globalPut(Bytes(\"contract_active\"), Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Resume contract - VULNERABLE: No authorization\n    resume_contract = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"resume\")),\n        # VULN: No admin check before resuming\n        App.globalPut(Bytes(\"contract_active\"), Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Emergency withdrawal - VULNERABLE: No authorization\n    emergency_withdraw = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"emergency\")),\n        # VULN: Anyone can trigger emergency withdrawal\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.accounts[1],\n            TxnField.amount: Global.current_application_address_balance(),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), setup],\n        [Txn.application_args[0] == Bytes(\"pause\"), pause_contract],\n        [Txn.application_args[0] == Bytes(\"resume\"), resume_contract],\n        [Txn.application_args[0] == Bytes(\"emergency\"), emergency_withdraw]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Unauthorized Contract Pause/Resume and Emergency Withdrawal\nDescription: The contract allows any user to pause/resume operations and trigger emergency withdrawals, causing denial of service and fund theft.\nAffected Lines: pause_contract, resume_contract, and emergency_withdraw functions\nImpact: Operational disruption, theft of all contract funds, loss of service availability\nCVSS Score: 10.0 (Critical)",
    "remediation": "1. Store admin address: App.globalPut(Bytes('admin'), Txn.sender()) in setup\n2. Add Assert(Txn.sender() == App.globalGet(Bytes('admin'))) to all control functions\n3. Implement emergency pause with admin + multi-sig requirement\n4. Add time-lock for emergency withdrawals (e.g., 2-day delay)\n5. Log all critical operations for audit",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-640: Weak Password Recovery Mechanism for Forgotten Password"
  },
  {
    "id": "ALG_V1_010",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "severity": "CRITICAL",
    "instruction": "Analyze the PyTeal contract for unauthorized multi-signature operation controls.",
    "input": "def approval_program():\n    # Create transaction proposal - VULNERABLE: No authorization\n    create_proposal = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"propose\")),\n        Assert(Txn.application_args[1] == Bytes(\"action\")),\n        # VULN: No verification that caller is authorized signatory\n        App.globalPut(Bytes(\"proposal_action\"), Txn.application_args[1]),\n        App.globalPut(Bytes(\"proposal_creator\"), Txn.sender()),\n        App.globalPut(Bytes(\"signatures_required\"), Int(2)),\n        App.globalPut(Bytes(\"signatures_received\"), Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Sign proposal - VULNERABLE: No signature tracking\n    sign_proposal = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"sign\")),\n        # VULN: No check if account already signed\n        App.globalPut(Bytes(\"signatures_received\"),\n            App.globalGet(Bytes(\"signatures_received\")) + Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Execute after signatures - VULNERABLE: No proper authorization\n    execute_multisig = Seq([\n        Assert(Txn.application_args[0] == Bytes(\"execute\")),\n        # VULN: Insufficient signature verification\n        If(App.globalGet(Bytes(\"signatures_received\")) >= App.globalGet(Bytes(\"signatures_required\")),\n            Seq([\n                InnerTxnBuilder.Begin(),\n                InnerTxnBuilder.SetFields({\n                    TxnField.type_enum: TxnType.Payment,\n                    TxnField.receiver: Txn.accounts[1],\n                    TxnField.amount: Btoi(Txn.application_args[1]),\n                }),\n                InnerTxnBuilder.Submit(),\n                Return(Int(1))\n            ]),\n            Return(Int(0))\n        )\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), Return(Int(1))],\n        [Txn.application_args[0] == Bytes(\"propose\"), create_proposal],\n        [Txn.application_args[0] == Bytes(\"sign\"), sign_proposal],\n        [Txn.application_args[0] == Bytes(\"execute\"), execute_multisig]\n    )\n    return program",
    "output": "Status: VULNERABLE\nVulnerability: Broken Multi-Signature Authorization\nDescription: The multi-sig contract has critical flaws: (1) No verification that proposers are authorized signatories, (2) Signature counting doesn't verify identity, allowing one account to sign multiple times, (3) No tracking of which accounts signed, enabling bypass.\nAffected Lines: create_proposal, sign_proposal, execute_multisig functions\nImpact: Complete bypass of multi-signature protection, unauthorized fund transfers\nCVSS Score: 10.0 (Critical)",
    "remediation": "1. Maintain list of authorized signatories: Bytes('signers') array in global state\n2. In create_proposal: Assert(includes(authorized_signers, Txn.sender()))\n3. In sign_proposal: Assert(includes(authorized_signers, Txn.sender())) and Assert(NOT App.localGet(Txn.sender(), Bytes('already_signed')))\n4. Track signed accounts: App.localPut(Txn.sender(), Bytes('already_signed'), Int(1))\n5. Verify each signer identity in execute_multisig\n6. Reset signature state after execution",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_cwe": "CWE-1273: Inappropriate Comment about Special Handling of a Requirement"
  }
]
[
  {
    "id": "ALG_SAFE_001",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify that the PyTeal contract properly implements access control for authorized fund withdrawal.",
    "input": "def approval_program():\n    # Initialize with sender as admin - SECURE\n    admin_key = Bytes(\"admin\")\n    initialized_key = Bytes(\"initialized\")\n    \n    handle_creation = Seq([\n        App.globalPut(admin_key, Txn.sender()),\n        App.globalPut(initialized_key, Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Only admin can withdraw funds\n    withdraw_funds = Seq([\n        # SECURE: Verify sender is admin\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"withdraw\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Validate receiver address\n        Assert(Btoi(Txn.application_args[2]) > Int(0)),   # Validate amount\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.application_args[1],\n            TxnField.amount: Btoi(Txn.application_args[2]),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"withdraw\"), withdraw_funds]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Access Control\nDescription: Contract correctly restricts fund withdrawals to the admin address. The admin is set during contract creation (Txn.sender()) and all withdrawal operations verify the caller's identity before executing.\nSecurity Features:\n- Admin address stored and verified on every withdrawal\n- Receiver address length validation (32 bytes)\n- Amount validation (must be > 0)\n- Admin check before any state-changing operation\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. This implementation follows security best practices.",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Proper Authorization Check"
  },
  {
    "id": "ALG_SAFE_002",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify that the token contract properly authorizes minting and burning operations.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    minter_key = Bytes(\"minter\")\n    total_supply_key = Bytes(\"total_supply\")\n    \n    handle_creation = Seq([\n        App.globalPut(admin_key, Txn.sender()),\n        App.globalPut(minter_key, Txn.sender()),  # Admin is default minter\n        App.globalPut(total_supply_key, Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Mint tokens - only authorized minter\n    mint_tokens = Seq([\n        # SECURE: Verify caller is authorized minter\n        Assert(Txn.sender() == App.globalGet(minter_key)),\n        Assert(Txn.application_args[0] == Bytes(\"mint\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Recipient address\n        Assert(Btoi(Txn.application_args[2]) > Int(0)),   # Mint amount\n        # SECURE: Store minted amount in recipient's local state\n        App.localPut(Txn.application_args[1], Bytes(\"balance\"),\n            App.localGet(Txn.application_args[1], Bytes(\"balance\")) + Btoi(Txn.application_args[2])),\n        # SECURE: Update total supply\n        App.globalPut(total_supply_key,\n            App.globalGet(total_supply_key) + Btoi(Txn.application_args[2])),\n        Return(Int(1))\n    ])\n    \n    # Burn tokens - only the token holder\n    burn_tokens = Seq([\n        # SECURE: Verify caller owns tokens being burned\n        Assert(Txn.application_args[0] == Bytes(\"burn\")),\n        Assert(Btoi(Txn.application_args[1]) > Int(0)),   # Burn amount\n        Assert(App.localGet(Txn.sender(), Bytes(\"balance\")) >= Btoi(Txn.application_args[1])),\n        # SECURE: Update caller's balance\n        App.localPut(Txn.sender(), Bytes(\"balance\"),\n            App.localGet(Txn.sender(), Bytes(\"balance\")) - Btoi(Txn.application_args[1])),\n        # SECURE: Reduce total supply\n        App.globalPut(total_supply_key,\n            App.globalGet(total_supply_key) - Btoi(Txn.application_args[1])),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"mint\"), mint_tokens],\n        [Txn.application_args[0] == Bytes(\"burn\"), burn_tokens]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Token Authorization\nDescription: Token contract implements secure minting and burning with proper authorization checks. Minting restricted to authorized minter, burning restricted to token holders.\nSecurity Features:\n- Minting only by authorized minter address\n- Burning only by token holder (Txn.sender())\n- Balance validation before burning\n- Total supply tracking maintained correctly\n- Address length validation\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Consider adding:\n1. Event logging for token operations\n2. Minter address update function (with admin authorization)\n3. Max supply cap enforcement",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Role-Based Authorization"
  },
  {
    "id": "ALG_SAFE_003",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the contract properly controls application lifecycle operations.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    owner_key = Bytes(\"owner\")\n    paused_key = Bytes(\"paused\")\n    \n    handle_creation = Seq([\n        # SECURE: Initialize admin on creation\n        App.globalPut(admin_key, Txn.sender()),\n        App.globalPut(owner_key, Txn.sender()),\n        App.globalPut(paused_key, Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Change owner - admin only\n    change_owner = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"set_owner\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Validate new owner address\n        App.globalPut(owner_key, Txn.application_args[1]),\n        Return(Int(1))\n    ])\n    \n    # Pause contract - admin only\n    pause_contract = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"pause\")),\n        App.globalPut(paused_key, Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Resume contract - admin only\n    resume_contract = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"resume\")),\n        Assert(App.globalGet(paused_key) == Int(1)),  # Only resume if paused\n        App.globalPut(paused_key, Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Delete application - owner only\n    delete_app = Seq([\n        # SECURE: Owner authorization required\n        Assert(Txn.sender() == App.globalGet(owner_key)),\n        Assert(Txn.on_completion() == OnComplete.DeleteApplication),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"set_owner\"), change_owner],\n        [Txn.application_args[0] == Bytes(\"pause\"), pause_contract],\n        [Txn.application_args[0] == Bytes(\"resume\"), resume_contract],\n        [Txn.on_completion() == OnComplete.DeleteApplication, delete_app]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Lifecycle Control\nDescription: Contract correctly implements access control for all lifecycle operations. Admin controls operational state (pause/resume), owner controls deletion.\nSecurity Features:\n- Admin authorization for state management\n- Owner authorization for deletion\n- State validation (only resume if paused)\n- Proper role separation\n- Address validation for owner changes\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Add time-locked pause mechanism\n2. Implement admin update function (with multi-sig)\n3. Add event logging",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Role-Based Authorization with State Validation"
  },
  {
    "id": "ALG_SAFE_004",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the escrow contract properly authorizes fund releases.",
    "input": "def approval_program():\n    buyer_key = Bytes(\"buyer\")\n    seller_key = Bytes(\"seller\")\n    amount_key = Bytes(\"amount\")\n    status_key = Bytes(\"status\")\n    arbiter_key = Bytes(\"arbiter\")\n    \n    handle_creation = Seq([\n        App.globalPut(buyer_key, Bytes(\"\"))   ,\n        App.globalPut(seller_key, Bytes(\"\")),\n        App.globalPut(arbiter_key, Txn.sender()),  # Creator is arbiter\n        App.globalPut(status_key, Bytes(\"open\")),\n        Return(Int(1))\n    ])\n    \n    # Create escrow - buyer and seller must authorize\n    create_escrow = Seq([\n        # SECURE: Buyer must be initiator\n        Assert(Txn.application_args[0] == Bytes(\"create\")),\n        Assert(App.globalGet(buyer_key) == Bytes(\"\")),  # Not already created\n        Assert(Txn.sender() == Txn.application_args[1]),  # Caller must be buyer\n        Assert(Len(Txn.application_args[2]) == Int(32)),  # Seller address\n        Assert(Txn.amount() > Int(0)),  # Escrow amount\n        App.globalPut(buyer_key, Txn.sender()),\n        App.globalPut(seller_key, Txn.application_args[2]),\n        App.globalPut(amount_key, Txn.amount()),\n        Return(Int(1))\n    ])\n    \n    # Release escrow - buyer authorization\n    release_escrow = Seq([\n        # SECURE: Only buyer can release to seller\n        Assert(Txn.application_args[0] == Bytes(\"release\")),\n        Assert(Txn.sender() == App.globalGet(buyer_key)),\n        Assert(App.globalGet(status_key) == Bytes(\"open\")),\n        # SECURE: Send to seller\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: App.globalGet(seller_key),\n            TxnField.amount: App.globalGet(amount_key),\n        }),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(status_key, Bytes(\"released\")),\n        Return(Int(1))\n    ])\n    \n    # Refund - buyer authorization\n    refund_escrow = Seq([\n        # SECURE: Only buyer can refund to themselves\n        Assert(Txn.application_args[0] == Bytes(\"refund\")),\n        Assert(Txn.sender() == App.globalGet(buyer_key)),\n        Assert(App.globalGet(status_key) == Bytes(\"open\")),\n        # SECURE: Refund to buyer\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.sender(),\n            TxnField.amount: App.globalGet(amount_key),\n        }),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(status_key, Bytes(\"refunded\")),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"create\"), create_escrow],\n        [Txn.application_args[0] == Bytes(\"release\"), release_escrow],\n        [Txn.application_args[0] == Bytes(\"refund\"), refund_escrow]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Escrow Authorization\nDescription: Escrow contract implements proper authorization controls. Only buyer can release funds to seller or request refund. State validation ensures proper escrow flow.\nSecurity Features:\n- Buyer authorization required for escrow creation\n- Only buyer can release or refund\n- State validation prevents invalid transitions\n- Correct payment routing (to seller on release, to buyer on refund)\n- Arbiter role established for dispute resolution\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Add arbiter dispute resolution mechanism\n2. Implement time-based refund if not released\n3. Add event logging for audit trail",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Multi-Party Authorization"
  },
  {
    "id": "ALG_SAFE_005",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the contract properly controls fee parameters.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    fee_percent_key = Bytes(\"fee_percent\")\n    fee_recipient_key = Bytes(\"fee_recipient\")\n    \n    handle_creation = Seq([\n        # SECURE: Set admin and initialize fees\n        App.globalPut(admin_key, Txn.sender()),\n        App.globalPut(fee_percent_key, Int(100)),  # 1% in basis points\n        App.globalPut(fee_recipient_key, Txn.sender()),\n        Return(Int(1))\n    ])\n    \n    # Update fee percentage - admin only\n    update_fee = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"set_fee\")),\n        Assert(Btoi(Txn.application_args[1]) >= Int(0)),  # Non-negative\n        Assert(Btoi(Txn.application_args[1]) <= Int(10000)),  # Max 100% in basis points\n        App.globalPut(fee_percent_key, Btoi(Txn.application_args[1])),\n        Return(Int(1))\n    ])\n    \n    # Update fee recipient - admin only\n    update_recipient = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"set_recipient\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Valid address\n        App.globalPut(fee_recipient_key, Txn.application_args[1]),\n        Return(Int(1))\n    ])\n    \n    # Claim accumulated fees - recipient only\n    claim_fees = Seq([\n        # SECURE: Only fee recipient can claim\n        Assert(Txn.sender() == App.globalGet(fee_recipient_key)),\n        Assert(Txn.application_args[0] == Bytes(\"claim_fees\")),\n        Assert(Global.current_application_address_balance() > Int(0)),\n        # SECURE: Send all fees to authorized recipient\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.sender(),\n            TxnField.amount: Global.current_application_address_balance(),\n        }),\n        InnerTxnBuilder.Submit(),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"set_fee\"), update_fee],\n        [Txn.application_args[0] == Bytes(\"set_recipient\"), update_recipient],\n        [Txn.application_args[0] == Bytes(\"claim_fees\"), claim_fees]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Fee Control\nDescription: Contract correctly restricts fee parameter modifications to admin. Fee percentage bounded, recipient address validated, and only recipient can claim fees.\nSecurity Features:\n- Admin-only fee parameter updates\n- Fee percentage bounds (0-100%)\n- Address validation for fee recipient\n- Recipient authorization for fee claims\n- Clear role separation\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Add time-locked fee updates\n2. Implement fee change proposal mechanism\n3. Add event logging for governance",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Parameterized Authorization with Bounds Checking"
  },
  {
    "id": "ALG_SAFE_006",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the asset custody contract properly controls deposits and withdrawals.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    \n    handle_creation = Seq([\n        App.globalPut(admin_key, Txn.sender()),\n        Return(Int(1))\n    ])\n    \n    # User deposits asset - user-controlled local state\n    user_deposit = Seq([\n        # SECURE: User deposits to their own account\n        Assert(Txn.xfer_asset_amount() > Int(0)),\n        # SECURE: Update only caller's balance\n        App.localPut(Txn.sender(), Bytes(\"asset_balance\"),\n            App.localGet(Txn.sender(), Bytes(\"asset_balance\")) + Txn.xfer_asset_amount()),\n        Return(Int(1))\n    ])\n    \n    # User withdraws asset - ownership verified\n    user_withdraw = Seq([\n        # SECURE: Withdraw from caller's own account\n        Assert(Txn.application_args[0] == Bytes(\"withdraw\")),\n        Assert(Txn.sender() == Txn.accounts[1]),  # Caller is account owner\n        Assert(Btoi(Txn.application_args[2]) > Int(0)),  # Withdraw amount\n        Assert(App.localGet(Txn.sender(), Bytes(\"asset_balance\")) >= Btoi(Txn.application_args[2])),\n        # SECURE: Send to account owner\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.AssetTransfer,\n            TxnField.asset_receiver: Txn.sender(),\n            TxnField.asset_amount: Btoi(Txn.application_args[2]),\n            TxnField.xfer_asset: Btoi(Txn.application_args[3]),\n        }),\n        InnerTxnBuilder.Submit(),\n        # SECURE: Update balance\n        App.localPut(Txn.sender(), Bytes(\"asset_balance\"),\n            App.localGet(Txn.sender(), Bytes(\"asset_balance\")) - Btoi(Txn.application_args[2])),\n        Return(Int(1))\n    ])\n    \n    # Admin can set custody limit per user\n    set_custody_limit = Seq([\n        # SECURE: Admin-only operation\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"set_limit\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # User address\n        Assert(Btoi(Txn.application_args[2]) >= Int(0)),  # Limit amount\n        # SECURE: Set user-specific limit\n        App.localPut(Txn.application_args[1], Bytes(\"custody_limit\"),\n            Btoi(Txn.application_args[2])),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.on_completion() == OnComplete.NoOp, user_deposit],\n        [Txn.application_args[0] == Bytes(\"withdraw\"), user_withdraw],\n        [Txn.application_args[0] == Bytes(\"set_limit\"), set_custody_limit]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Asset Custody Control\nDescription: Custody contract correctly restricts asset operations to account owners. Each user can only withdraw from their own balance. Admin can set per-user limits.\nSecurity Features:\n- User controls only their own balance\n- Withdrawal amount validation against user balance\n- Account owner verification (Txn.sender() == Txn.accounts[1])\n- Admin-only limit setting\n- Proper balance updates after withdrawal\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Add custody limit enforcement in deposit\n2. Implement emergency withdrawal mechanism\n3. Add event logging",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "User-Controlled State with Admin Oversight"
  },
  {
    "id": "ALG_SAFE_007",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the governance voting contract properly authorizes voting operations.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    eligible_voters_key = Bytes(\"eligible_voters\")\n    \n    handle_creation = Seq([\n        App.globalPut(admin_key, Txn.sender()),\n        Return(Int(1))\n    ])\n    \n    # Admin registers eligible voter\n    register_voter = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"register_voter\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Voter address\n        # SECURE: Mark address as eligible voter\n        App.localPut(Txn.application_args[1], Bytes(\"is_eligible_voter\"), Int(1)),\n        Return(Int(1))\n    ])\n    \n    # User casts vote - eligibility verified\n    cast_vote = Seq([\n        # SECURE: Check voter is eligible\n        Assert(App.localGet(Txn.sender(), Bytes(\"is_eligible_voter\")) == Int(1)),\n        Assert(Txn.application_args[0] == Bytes(\"vote\")),\n        Assert(Txn.application_args[1] == Bytes(\"proposal_id\")),\n        # SECURE: Check haven't already voted for this proposal\n        Assert(App.localGet(Txn.sender(), Bytes(\"proposal_voted\")) != Txn.application_args[1]),\n        Assert(Or(\n            Txn.application_args[2] == Bytes(\"yes\"),\n            Txn.application_args[2] == Bytes(\"no\")\n        )),\n        # SECURE: Record vote\n        App.localPut(Txn.sender(), Bytes(\"proposal_voted\"), Txn.application_args[1]),\n        If(Txn.application_args[2] == Bytes(\"yes\"),\n            App.globalPut(Bytes(\"yes_votes\"),\n                App.globalGet(Bytes(\"yes_votes\")) + Int(1)),\n            App.globalPut(Bytes(\"no_votes\"),\n                App.globalGet(Bytes(\"no_votes\")) + Int(1))\n        ),\n        Return(Int(1))\n    ])\n    \n    # Execute proposal - admin + vote threshold\n    execute_proposal = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"execute\")),\n        Assert(Txn.application_args[1] == Bytes(\"proposal_id\")),\n        # SECURE: Verify vote threshold met\n        Assert(App.globalGet(Bytes(\"yes_votes\")) > App.globalGet(Bytes(\"no_votes\"))),\n        App.globalPut(Bytes(\"proposal_executed\"), Int(1)),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"register_voter\"), register_voter],\n        [Txn.application_args[0] == Bytes(\"vote\"), cast_vote],\n        [Txn.application_args[0] == Bytes(\"execute\"), execute_proposal]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Governance Voting Control\nDescription: Governance contract correctly restricts voting to eligible voters and prevents double-voting. Proposal execution requires admin authorization and vote threshold verification.\nSecurity Features:\n- Admin-only voter registration\n- Voter eligibility verification\n- Double-vote prevention (per proposal)\n- Vote threshold enforcement\n- Admin-only proposal execution\n- Clear separation of concerns\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Implement time-based voting windows\n2. Add delegate voting mechanism\n3. Implement quorum requirements\n4. Add event logging",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Permission-Based Voting with Multi-Check Authorization"
  },
  {
    "id": "ALG_SAFE_008",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the staking contract properly authorizes stake operations.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    reward_pool_key = Bytes(\"reward_pool\")\n    \n    handle_creation = Seq([\n        App.globalPut(admin_key, Txn.sender()),\n        App.globalPut(reward_pool_key, Int(0)),\n        Return(Int(1))\n    ])\n    \n    # User stakes funds - self-staking only\n    stake_funds = Seq([\n        # SECURE: Verify caller is staking own funds\n        Assert(Txn.amount() > Int(0)),\n        # SECURE: Update only caller's stake\n        App.localPut(Txn.sender(), Bytes(\"staked_amount\"),\n            App.localGet(Txn.sender(), Bytes(\"staked_amount\")) + Txn.amount()),\n        App.localPut(Txn.sender(), Bytes(\"stake_block\"), Global.latest_confirmed_block()),\n        Return(Int(1))\n    ])\n    \n    # User unstakes - self-unstaking only\n    unstake_funds = Seq([\n        # SECURE: Verify caller owns the stake\n        Assert(Txn.application_args[0] == Bytes(\"unstake\")),\n        Assert(Txn.sender() == Txn.accounts[1]),  # Caller is account owner\n        Assert(Btoi(Txn.application_args[1]) > Int(0)),  # Unstake amount\n        Assert(App.localGet(Txn.sender(), Bytes(\"staked_amount\")) >= Btoi(Txn.application_args[1])),\n        # SECURE: Send only to account owner\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.sender(),\n            TxnField.amount: Btoi(Txn.application_args[1]),\n        }),\n        InnerTxnBuilder.Submit(),\n        # SECURE: Update stake\n        App.localPut(Txn.sender(), Bytes(\"staked_amount\"),\n            App.localGet(Txn.sender(), Bytes(\"staked_amount\")) - Btoi(Txn.application_args[1])),\n        Return(Int(1))\n    ])\n    \n    # User claims rewards - self-claiming only\n    claim_rewards = Seq([\n        # SECURE: Verify caller is claimant\n        Assert(Txn.sender() == Txn.accounts[1]),\n        Assert(Txn.application_args[0] == Bytes(\"claim\")),\n        Assert(App.localGet(Txn.sender(), Bytes(\"staked_amount\")) > Int(0)),  # Has stake\n        # SECURE: Calculate based on stake and duration\n        Assert(Btoi(Txn.application_args[1]) > Int(0)),  # Reward amount\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.sender(),\n            TxnField.amount: Btoi(Txn.application_args[1]),\n        }),\n        InnerTxnBuilder.Submit(),\n        App.localPut(Txn.sender(), Bytes(\"last_claim\"), Global.latest_confirmed_block()),\n        Return(Int(1))\n    ])\n    \n    # Admin adds rewards to pool\n    add_rewards = Seq([\n        # SECURE: Admin-only operation\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"add_rewards\")),\n        Assert(Txn.amount() > Int(0)),\n        App.globalPut(reward_pool_key,\n            App.globalGet(reward_pool_key) + Txn.amount()),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.on_completion() == OnComplete.NoOp, stake_funds],\n        [Txn.application_args[0] == Bytes(\"unstake\"), unstake_funds],\n        [Txn.application_args[0] == Bytes(\"claim\"), claim_rewards],\n        [Txn.application_args[0] == Bytes(\"add_rewards\"), add_rewards]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Staking Authorization\nDescription: Staking contract properly restricts stake operations to account owners. Users can only stake, unstake, and claim rewards from their own accounts. Admin manages reward pool.\nSecurity Features:\n- User can only modify own stake\n- Unstake amount validation against balance\n- Rewards claimed only by stake owner\n- Admin-only reward pool management\n- Stake duration tracking for reward calculation\n- Clear role separation\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Implement reward rate calculations\n2. Add lock-up period enforcement\n3. Implement progressive reward scheduling\n4. Add event logging",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "User-Controlled Financial Operations with Admin Oversight"
  },
  {
    "id": "ALG_SAFE_009",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the contract properly controls contract state and emergency operations.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    emergency_contact_key = Bytes(\"emergency_contact\")\n    paused_key = Bytes(\"paused\")\n    active_key = Bytes(\"active\")\n    \n    handle_creation = Seq([\n        # SECURE: Initialize with admin and emergency contact\n        App.globalPut(admin_key, Txn.sender()),\n        App.globalPut(emergency_contact_key, Txn.sender()),\n        App.globalPut(paused_key, Int(0)),\n        App.globalPut(active_key, Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Pause contract - admin only\n    pause_contract = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"pause\")),\n        Assert(App.globalGet(paused_key) == Int(0)),  # Not already paused\n        App.globalPut(paused_key, Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Resume contract - admin only\n    resume_contract = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"resume\")),\n        Assert(App.globalGet(paused_key) == Int(1)),  # Currently paused\n        App.globalPut(paused_key, Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Emergency withdrawal - emergency contact only\n    emergency_withdraw = Seq([\n        # SECURE: Emergency contact authorization required\n        Assert(Txn.sender() == App.globalGet(emergency_contact_key)),\n        Assert(Txn.application_args[0] == Bytes(\"emergency_withdraw\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Recipient address\n        # SECURE: Send balance to authorized recipient\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.application_args[1],\n            TxnField.amount: Global.current_application_address_balance(),\n        }),\n        InnerTxnBuilder.Submit(),\n        App.globalPut(active_key, Int(0)),  # Mark as inactive\n        Return(Int(1))\n    ])\n    \n    # Update emergency contact - admin only\n    update_emergency_contact = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"update_emergency\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # New contact address\n        App.globalPut(emergency_contact_key, Txn.application_args[1]),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"pause\"), pause_contract],\n        [Txn.application_args[0] == Bytes(\"resume\"), resume_contract],\n        [Txn.application_args[0] == Bytes(\"emergency_withdraw\"), emergency_withdraw],\n        [Txn.application_args[0] == Bytes(\"update_emergency\"), update_emergency_contact]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Contract State and Emergency Control\nDescription: Contract correctly implements state control and emergency mechanisms with proper authorization. Admin controls operations, emergency contact handles crisis scenarios.\nSecurity Features:\n- Admin authorization for pause/resume\n- State validation (prevent pause of paused contract)\n- Separate emergency contact role\n- Emergency withdrawal only by authorized contact\n- Admin-only emergency contact updates\n- Active/inactive state tracking\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Add time-lock for emergency withdrawals\n2. Implement multi-sig for emergency operations\n3. Add event logging for all operations\n4. Implement recovery mechanism",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Dual-Role Authorization with State Validation"
  },
  {
    "id": "ALG_SAFE_010",
    "platform": "Algorand",
    "vulnerability_type": "V1 - Access Control",
    "status": "SAFE",
    "instruction": "Verify the multi-signature contract properly authorizes transaction execution.",
    "input": "def approval_program():\n    admin_key = Bytes(\"admin\")\n    signers_count_key = Bytes(\"signers_count\")\n    signatures_required_key = Bytes(\"signatures_required\")\n    \n    # Generate signer key for tracking\n    def signer_key(account):\n        return Concat(Bytes(\"signer_\"), account)\n    \n    handle_creation = Seq([\n        # SECURE: Initialize with admin\n        App.globalPut(admin_key, Txn.sender()),\n        App.globalPut(signers_count_key, Int(0)),\n        App.globalPut(signatures_required_key, Int(2)),  # Default 2-of-N\n        Return(Int(1))\n    ])\n    \n    # Admin adds authorized signer\n    add_signer = Seq([\n        # SECURE: Admin authorization required\n        Assert(Txn.sender() == App.globalGet(admin_key)),\n        Assert(Txn.application_args[0] == Bytes(\"add_signer\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Signer address\n        # SECURE: Mark address as authorized signer\n        App.globalPut(signer_key(Txn.application_args[1]), Int(1)),\n        App.globalPut(signers_count_key,\n            App.globalGet(signers_count_key) + Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Create transaction proposal - authorized signer only\n    create_proposal = Seq([\n        # SECURE: Verify caller is authorized signer\n        Assert(App.globalGet(signer_key(Txn.sender())) == Int(1)),\n        Assert(Txn.application_args[0] == Bytes(\"propose\")),\n        Assert(Txn.application_args[1] == Bytes(\"action\")),  # Action data\n        # SECURE: Record proposer\n        App.globalPut(Bytes(\"proposal_creator\"), Txn.sender()),\n        App.globalPut(Bytes(\"proposal_action\"), Txn.application_args[1]),\n        App.globalPut(Bytes(\"signatures_received\"), Int(0)),\n        Return(Int(1))\n    ])\n    \n    # Sign proposal - authorized signer only, one signature per account\n    sign_proposal = Seq([\n        # SECURE: Verify caller is authorized signer\n        Assert(App.globalGet(signer_key(Txn.sender())) == Int(1)),\n        Assert(Txn.application_args[0] == Bytes(\"sign\")),\n        # SECURE: Verify hasn't already signed this proposal\n        Assert(App.localGet(Txn.sender(), Bytes(\"proposal_signed\")) != Int(1)),\n        # SECURE: Track that this account signed\n        App.localPut(Txn.sender(), Bytes(\"proposal_signed\"), Int(1)),\n        # SECURE: Increment signature counter\n        App.globalPut(Bytes(\"signatures_received\"),\n            App.globalGet(Bytes(\"signatures_received\")) + Int(1)),\n        Return(Int(1))\n    ])\n    \n    # Execute proposal - threshold signatures met\n    execute_multisig = Seq([\n        # SECURE: Verify sufficient signatures\n        Assert(App.globalGet(Bytes(\"signatures_received\")) >= App.globalGet(signatures_required_key)),\n        Assert(Txn.application_args[0] == Bytes(\"execute\")),\n        Assert(Len(Txn.application_args[1]) == Int(32)),  # Recipient address\n        Assert(Btoi(Txn.application_args[2]) > Int(0)),   # Amount\n        # SECURE: Execute authorized transaction\n        InnerTxnBuilder.Begin(),\n        InnerTxnBuilder.SetFields({\n            TxnField.type_enum: TxnType.Payment,\n            TxnField.receiver: Txn.application_args[1],\n            TxnField.amount: Btoi(Txn.application_args[2]),\n        }),\n        InnerTxnBuilder.Submit(),\n        # SECURE: Reset for next proposal\n        App.globalPut(Bytes(\"signatures_received\"), Int(0)),\n        Return(Int(1))\n    ])\n    \n    program = Cond(\n        [Txn.application_id() == Int(0), handle_creation],\n        [Txn.application_args[0] == Bytes(\"add_signer\"), add_signer],\n        [Txn.application_args[0] == Bytes(\"propose\"), create_proposal],\n        [Txn.application_args[0] == Bytes(\"sign\"), sign_proposal],\n        [Txn.application_args[0] == Bytes(\"execute\"), execute_multisig]\n    )\n    return program",
    "output": "Status: SAFE\nCompliance: Proper Multi-Signature Authorization\nDescription: Multi-signature contract correctly implements multi-party authorization. Only registered signers can propose/sign, signature counting prevents double-voting, and threshold is enforced before execution.\nSecurity Features:\n- Admin-only signer registration\n- Authorized signer verification for proposals\n- Double-signature prevention via local state tracking\n- Signature threshold enforcement\n- Unique signer identification per proposal\n- State reset after execution\n- Clear authorization model\nCVSS Score: None (Safe Implementation)",
    "remediation": "No remediation needed. Enhancement suggestions:\n1. Add time-based proposal expiry\n2. Implement proposal cancellation mechanism\n3. Add signer removal function\n4. Add event logging for audit trail\n5. Implement adaptive signature threshold",
    "meta_platform": "Algorand",
    "meta_vuln_type": "V1 - Access Control",
    "meta_security_pattern": "Multi-Party Authorization with Signature Tracking"
  }
]
