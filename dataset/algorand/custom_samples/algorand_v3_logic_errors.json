[
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Using a hardcoded, brittle asset ID check)\n    asset_check = Txn.assets[0] == Int(123456)\n    return Cond([\n        Txn.application_args[0] == Bytes(\"transfer\"),\n        If(asset_check).Then(Return(Int(1)))\n    ])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Hardcoded Asset ID. Using a brittle 'magic number' for an Asset ID instead of retrieving it from a reliable source or state.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Unconditional state write before the access control check)\n    logic = Seq([\n        App.globalPut(Bytes(\"status\"), Int(1)),\n        If(Txn.sender() != Global.creator_address()).Then(Reject()),\n        Return(Int(1))\n    ])\n    return Cond([Txn.application_args[0] == Bytes(\"init\"), logic])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Flawed Order of Operations. Writes to global state unconditionally before checking access control, making the write permanent even if the transaction is rejected.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Grants reward based on transaction amount without verifying the transaction type or asset)\n    logic = If(Txn.amount() >= Int(100)).Then(App.localPut(Txn.sender(), Bytes(\"reward\"), Int(1)))\n    return Cond([Txn.application_args[0] == Bytes(\"claim\"), logic])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Missing Transaction Type Check. Processes logic based on 'amount' without verifying if the transaction is for the correct asset or type (e.g., could be any asset transfer).",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Assumes `AssetHolding.balance` will always succeed without checking `hasValue()`)\n    balance = AssetHolding.balance(Txn.sender(), Int(123)).value()\n    return Cond([Txn.application_args[0] == Bytes(\"check\"), Return(balance)])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Unchecked AssetHolding Value. Calls `.value()` on `AssetHolding.balance` without first checking `hasValue()`, which panics if the account has not opted in.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Logic error in calculating the required fee for an action)\n    required_fee = Div(Int(1000), Txn.group_index())\n    Assert(Txn.fee() >= required_fee)\n    return Cond([Txn.application_args[0] == Bytes(\"action\"), Return(Int(1))])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Division by Unchecked Zero/Index. Division by an index or variable that is not guaranteed to be non-zero (or appropriate for the calculation).",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Assuming that an inner transaction is always Gtxn[1] in the group)\n    logic = If(Gtxn[1].sender() == Global.creator_address()).Then(Return(Int(1)))\n    return Cond([Txn.application_args[0] == Bytes(\"group_check\"), logic])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Absolute Group Indexing. Using absolute indices (Gtxn[1]) instead of relative indexing (`Txn.group_index()` - 1), which is brittle in complex transaction groups.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Fails to enforce a maximum loop limit when processing an array of accounts/args)\n    loop_logic = For(Int(0), Int(0), Btoi(Txn.application_args[1])).Do(Log(Bytes(\"process\")))\n    return Cond([Txn.application_args[0] == Bytes(\"process_list\"), loop_logic])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Unbounded Loop (DoS). Executes a loop where the limit is derived from unchecked user input, risking exhaustion of the compute budget.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Incorrect logical operation, AND instead of OR)\n    logic = If(And(Txn.sender() == Global.creator_address(), Txn.close_remainder_to() == Global.creator_address())).Then(Return(Int(1)))\n    return Cond([Txn.application_args[0] == Bytes(\"admin_or_close\"), logic])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Incorrect Boolean Operator. Uses an AND operation when an OR operation was logically intended, making the condition too restrictive.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Uses a local state variable that hasn't been initialized or checked)\n    balance = App.localGet(Txn.sender(), Bytes(\"count\"))\n    new_balance = Add(balance, Int(1))\n    return Cond([Txn.application_args[0] == Bytes(\"increment\"), App.localPut(Txn.sender(), Bytes(\"count\"), new_balance)])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Uninitialized State Read. Reads a local state variable (`count`) and uses it in a calculation without ensuring it was initialized first, risking `Btoi` failure or reading zero.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (VULN: Flawed logic for calculating percentage, leading to truncation or miscalculation)\n    amount = Btoi(Txn.application_args[1])\n    fee = Div(amount, Int(100)) # Simple division without correct rounding or precision handling\n    return Cond([Txn.application_args[0] == Bytes(\"calc_fee\"), Return(fee)])",
        "output": "Status: VULNERABLE\nVulnerability: V3 - Logic Errors\nAnalysis: Logic Error: Flawed Percentage Calculation. Uses integer division for critical percentage calculations, leading to truncation/rounding errors.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Retrieves the Asset ID from global state for flexibility)\n    asset_check = Txn.assets[0] == App.globalGet(Bytes(\"TARGET_ASSET_ID\"))\n    return Cond([\n        Txn.application_args[0] == Bytes(\"transfer\"),\n        If(asset_check).Then(Return(Int(1)))\n    ])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Dynamic Asset ID. Retrieves the Asset ID from global state, making the logic robust to ID changes.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Access control check happens before any state modification)\n    logic = Seq([\n        If(Txn.sender() != Global.creator_address()).Then(Reject()),\n        App.globalPut(Bytes(\"status\"), Int(1)),\n        Return(Int(1))\n    ])\n    return Cond([Txn.application_args[0] == Bytes(\"init\"), logic])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Correct Order of Operations. Access control is verified before any critical state modification.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Verifies transaction type is a payment before acting on the amount)\n    logic = If(And(Txn.amount() >= Int(100), Txn.type_enum() == TxnType.Payment)).Then(App.localPut(Txn.sender(), Bytes(\"reward\"), Int(1)))\n    return Cond([Txn.application_args[0] == Bytes(\"claim\"), logic])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Explicit Transaction Type Check. Verifies the transaction type to ensure the amount corresponds to the expected asset.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Checks hasValue() before accessing the asset balance)\n    check_balance = AssetHolding.balance(Txn.sender(), Int(123))\n    logic = If(check_balance.hasValue()).Then(Return(check_balance.value()))\n    return Cond([Txn.application_args[0] == Bytes(\"check\"), logic])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Checked AssetHolding Value. Safely checks if the account has opted in to the asset before accessing the balance value.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Ensures the division is only performed if the index is valid)\n    required_fee = If(Txn.group_index() > Int(0)).Then(Div(Int(1000), Txn.group_index())).Else(Int(0))\n    Assert(Txn.fee() >= required_fee)\n    return Cond([Txn.application_args[0] == Bytes(\"action\"), Return(Int(1))])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Checked Division. Explicitly checks the denominator before performing division, preventing potential runtime errors.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Uses relative indexing based on the current transaction's index)\n    logic = If(Gtxn[Txn.group_index() - Int(1)].sender() == Txn.sender()).Then(Return(Int(1)))\n    return Cond([Txn.application_args[0] == Bytes(\"group_check\"), logic])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Relative Group Indexing. Uses relative indexing to reference other transactions in the group safely.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Enforces a maximum loop limit regardless of user input)\n    loop_limit = Btoi(Txn.application_args[1]).min(Int(10))\n    loop_logic = For(Int(0), Int(0), loop_limit).Do(Log(Bytes(\"process\")))\n    return Cond([Txn.application_args[0] == Bytes(\"process_list\"), loop_logic])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Bounded Loop. Explicitly limits the loop iteration count using the `.min()` function.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Correct boolean operator used)\n    logic = If(Or(Txn.sender() == Global.creator_address(), Txn.close_remainder_to() == Global.creator_address())).Then(Return(Int(1)))\n    return Cond([Txn.application_args[0] == Bytes(\"admin_or_close\"), logic])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Correct Boolean Operator. Uses the correct OR operator for the intended inclusive logic.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Checks for initialization and initializes if needed before incrementing)\n    count = App.localGetEx(Txn.sender(), Global.current_application_id(), Bytes(\"count\"))\n    balance = If(count.hasValue()).Then(count.value()).Else(Int(0))\n    new_balance = Add(balance, Int(1))\n    return Cond([Txn.application_args[0] == Bytes(\"increment\"), App.localPut(Txn.sender(), Bytes(\"count\"), new_balance)])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Initialized State Read. Checks if the state variable has a value and initializes it to 0 if not, preventing runtime errors.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    },
    {
        "instruction": "You are a smart contract security analyzer. Your task is to analyze the provided PyTeal code for Algorand and identify Logic Errors (OWASP V3).",
        "input": "def approval_program():\n    # (FIX: Uses multiplication before division to maintain precision in fixed-point math)\n    amount = Btoi(Txn.application_args[1])\n    # Example: 1% fee, calculate (amount * 1) / 100\n    fee = Div(Mul(amount, Int(1)), Int(100))\n    return Cond([Txn.application_args[0] == Bytes(\"calc_fee\"), Return(fee)])",
        "output": "Status: SAFE\nVulnerability: V3 - Logic Errors\nAnalysis: Safe: Correct Percentage Calculation. Uses the fixed-point math principle (Multiply before Divide) to maintain precision.",
        "meta_platform": "Algorand",
        "meta_vuln_type": "V3 - Logic Errors"
    }
]