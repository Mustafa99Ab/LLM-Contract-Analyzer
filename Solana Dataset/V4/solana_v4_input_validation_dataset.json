[
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_initialize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    epoch_fee: Fee,\n    withdrawal_fee: Fee,\n    deposit_fee: Fee,\n    referral_fee: u8,\n    max_validators: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    \n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    \n    stake_pool.epoch_fee = epoch_fee;\n    stake_pool.stake_withdrawal_fee = withdrawal_fee;\n    stake_pool.stake_deposit_fee = deposit_fee;\n    stake_pool.stake_referral_fee = referral_fee;\n    stake_pool.max_validators = max_validators;\n    \n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nHIGH\nThe function accepts fee parameters without validation. Fees with numerator > denominator would exceed 100%, and referral_fee is not checked against maximum. max_validators has no upper bound, potentially causing storage issues.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "pub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    \n    Self::validate_owner(program_id, &source_account.owner, authority_info, account_info_iter.as_slice())?;\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nMEDIUM\nThe transfer function does not validate that amount is greater than zero. Zero-value transfers waste compute resources and could be used to spam the network. While checked arithmetic prevents overflow, the lack of minimum validation enables DoS attacks.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_deposit_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    deposit_lamports: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let from_user_info = next_account_info(account_info_iter)?;\n    let dest_user_pool_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    \n    let new_pool_tokens = stake_pool.calc_pool_tokens_for_deposit(deposit_lamports)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    Self::token_mint_to(\n        stake_pool_info.key,\n        token_program_info.clone(),\n        pool_mint_info.clone(),\n        dest_user_pool_info.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        new_pool_tokens,\n    )?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nHIGH\nThe deposit function lacks input validation: no check for zero deposits, no minimum deposit threshold to prevent dust deposits, and no slippage protection. Attackers could perform sandwich attacks or flood the pool with worthless micro-deposits.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "pub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    // expected_decimals not validated against mint\n\n    match mint.mint_authority {\n        COption::Some(mint_authority) => Self::validate_owner(\n            program_id, &mint_authority, owner_info, account_info_iter.as_slice()\n        )?,\n        COption::None => return Err(TokenError::FixedSupply.into()),\n    }\n\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nMEDIUM\nThe mint_to function does not validate that amount is non-zero, wasting compute for no-op operations. The optional expected_decimals parameter is not validated against the actual mint decimals when provided, which could lead to precision mismatches.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_withdraw_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let stake_split_from = next_account_info(account_info_iter)?;\n    let stake_split_to = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    \n    let withdraw_lamports = stake_pool.calc_lamports_withdraw_amount(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    Self::stake_split(\n        stake_pool_info.key,\n        stake_split_from.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        withdraw_lamports,\n        stake_split_to.clone(),\n    )?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nHIGH\nThe withdrawal function lacks critical input validation: no check for zero pool_tokens, no minimum withdrawal threshold, and no slippage protection. Users could lose value to sandwich attacks or receive dust amounts after fees.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_increase_validator_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    lamports: u64,\n    transient_stake_seed: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let validator_stake_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    stake_pool.check_staker(staker_info)?;\n    \n    \n    Self::stake_split(\n        stake_pool_info.key,\n        reserve_stake_info.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        lamports,\n        validator_stake_info.clone(),\n    )?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nHIGH\nThe increase_validator_stake function does not validate the lamports parameter. Missing checks include: zero amount validation, minimum delegation requirement (could create invalid stake), and reserve balance bounds (could drain reserve below minimum).",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "pub fn process_approve(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let delegate_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n\n    Self::validate_owner(\n        program_id,\n        &source_account.owner,\n        owner_info,\n        account_info_iter.as_slice(),\n    )?;\n\n    // Allows setting delegate with 0 amount (pointless)\n    // No check if amount > account balance (misleading allowance)\n    \n    source_account.delegate = COption::Some(*delegate_info.key);\n    source_account.delegated_amount = amount;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nLOW\nThe approve function allows setting a delegate with zero amount, which is semantically pointless and wastes compute. It also allows setting delegated_amount greater than account balance, creating a misleading allowance that will fail on use.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    new_fee_numerator: u64,\n    new_fee_denominator: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    stake_pool.check_manager(manager_info)?;\n\n    \n    stake_pool.epoch_fee.numerator = new_fee_numerator;\n    stake_pool.epoch_fee.denominator = new_fee_denominator;\n\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nCRITICAL\nThe set_fee function has critical validation gaps: no check for denominator being zero (causing division by zero), no check that numerator <= denominator (allowing fees > 100%), and no rate limiting on fee increases (sudden fee spikes could drain users).",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn _process_initialize_multisig(\n    accounts: &[AccountInfo],\n    m: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let multisig_info = next_account_info(account_info_iter)?;\n    let rent = Rent::get()?;\n\n    let mut multisig = Multisig::unpack_unchecked(&multisig_info.data.borrow())?;\n    if multisig.is_initialized {\n        return Err(TokenError::AlreadyInUse.into());\n    }\n\n    let signer_infos = account_info_iter.as_slice();\n    \n    \n    multisig.m = m;\n    multisig.n = signer_infos.len() as u8;\n    for (i, signer_info) in signer_infos.iter().enumerate() {\n        multisig.signers[i] = *signer_info.key;\n    }\n    multisig.is_initialized = true;\n\n    Multisig::pack(multisig, &mut multisig_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nCRITICAL\nThe multisig initialization lacks critical validation: m could be 0 (allowing operations with no signatures), m could exceed n (making the multisig unusable), and signer count (n) is not validated against MAX_SIGNERS, potentially causing array overflow.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n\n    \n    validator_list.push(ValidatorStakeInfo {\n        status: StakeStatus::Active.into(),\n        vote_account_address: *validator_vote_info.key,\n        active_stake_lamports: 0.into(),\n        transient_stake_lamports: 0.into(),\n        last_update_epoch: 0.into(),\n        transient_seed_suffix: 0.into(),\n        unused: 0.into(),\n        validator_seed_suffix: raw_validator_seed.into(),\n    })?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV4 - Input Validation\nHIGH\nThe add_validator function lacks input validation: no check if validator list is at capacity, no duplicate validator check (same validator could be added multiple times), and vote account is not validated as a legitimate vote account.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_initialize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    epoch_fee: Fee,\n    withdrawal_fee: Fee,\n    deposit_fee: Fee,\n    referral_fee: u8,\n    max_validators: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let rent = Rent::get()?;\n    \n    if epoch_fee.numerator > epoch_fee.denominator\n        || withdrawal_fee.numerator > withdrawal_fee.denominator\n        || deposit_fee.numerator > deposit_fee.denominator\n        || referral_fee > 100u8\n    {\n        return Err(StakePoolError::FeeTooHigh.into());\n    }\n    \n    let expected_max_validators = ValidatorList::calculate_max_validators(validator_list_info.data_len());\n    if expected_max_validators != max_validators as usize || max_validators == 0 {\n        return Err(StakePoolError::UnexpectedValidatorListAccountSize.into());\n    }\n    if max_validators > MAX_VALIDATORS_IN_POOL {\n        return Err(StakePoolError::TooManyValidatorsInPool.into());\n    }\n    \n    if !rent.is_exempt(stake_pool_info.lamports(), stake_pool_info.data_len()) {\n        return Err(ProgramError::AccountNotRentExempt);\n    }\n    \n    let pool_mint_data = pool_mint_info.try_borrow_data()?;\n    let pool_mint = StateWithExtensions::<Mint>::unpack(&pool_mint_data)?;\n    if pool_mint.base.supply != 0 {\n        return Err(StakePoolError::NonZeroPoolTokenSupply.into());\n    }\n    if pool_mint.base.decimals != native_mint::DECIMALS {\n        return Err(StakePoolError::IncorrectMintDecimals.into());\n    }\n    \n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function implements comprehensive input validation: fees are checked against 100% cap, referral_fee <= 100, max_validators is bounded and validated against storage, rent-exemption is verified, and mint state is validated for zero supply and correct decimals.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "pub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let expected_mint_info = if let Some(expected_decimals) = expected_decimals {\n        Some((next_account_info(account_info_iter)?, expected_decimals))\n    } else {\n        None\n    };\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    if source_account.is_frozen() || destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    if !Self::cmp_pubkeys(&source_account.mint, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    if let Some((mint_info, expected_decimals)) = expected_mint_info {\n        if !Self::cmp_pubkeys(mint_info.key, &source_account.mint) {\n            return Err(TokenError::MintMismatch.into());\n        }\n        let mint = Mint::unpack(&mint_info.data.borrow_mut())?;\n        if expected_decimals != mint.decimals {\n            return Err(TokenError::MintDecimalsMismatch.into());\n        }\n    }\n\n    let self_transfer = Self::cmp_pubkeys(source_account_info.key, destination_account_info.key);\n    if self_transfer || amount == 0 {\n        Self::check_account_owner(program_id, source_account_info)?;\n        Self::check_account_owner(program_id, destination_account_info)?;\n    }\n    if self_transfer {\n        return Ok(());\n    }\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function validates: frozen account status, sufficient balance, mint consistency between accounts, optional decimals matching, self-transfer handling, and uses checked arithmetic. Zero-amount transfers are permitted but validated for account ownership.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_deposit_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    deposit_lamports: u64,\n    minimum_pool_tokens_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let from_user_info = next_account_info(account_info_iter)?;\n    let dest_user_pool_info = next_account_info(account_info_iter)?;\n    let manager_fee_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let new_pool_tokens = stake_pool.calc_pool_tokens_for_deposit(deposit_lamports)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let pool_tokens_sol_deposit_fee = stake_pool\n        .calc_pool_tokens_sol_deposit_fee(new_pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let pool_tokens_user = new_pool_tokens\n        .checked_sub(pool_tokens_sol_deposit_fee)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if pool_tokens_user == 0 {\n        return Err(StakePoolError::DepositTooSmall.into());\n    }\n\n    if let Some(minimum_pool_tokens_out) = minimum_pool_tokens_out {\n        if pool_tokens_user < minimum_pool_tokens_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function implements proper input validation: epoch freshness check prevents stale state attacks, minimum output check (pool_tokens_user == 0) prevents dust deposits, and slippage protection via minimum_pool_tokens_out prevents sandwich attacks.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "pub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    if destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if destination_account.is_native() {\n        return Err(TokenError::NativeNotSupported.into());\n    }\n    if !Self::cmp_pubkeys(mint_info.key, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n    if let Some(expected_decimals) = expected_decimals {\n        if expected_decimals != mint.decimals {\n            return Err(TokenError::MintDecimalsMismatch.into());\n        }\n    }\n\n    match mint.mint_authority {\n        COption::Some(mint_authority) => Self::validate_owner(\n            program_id, &mint_authority, owner_info, account_info_iter.as_slice()\n        )?,\n        COption::None => return Err(TokenError::FixedSupply.into()),\n    }\n\n    if amount == 0 {\n        Self::check_account_owner(program_id, mint_info)?;\n        Self::check_account_owner(program_id, destination_account_info)?;\n    }\n\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function validates: frozen status, native token restriction, mint-account consistency, optional decimals verification, fixed supply handling, and zero-amount with ownership verification. Checked arithmetic prevents overflow.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_withdraw_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n    minimum_lamports_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let stake_split_from = next_account_info(account_info_iter)?;\n    let stake_split_to = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let pool_tokens_fee = stake_pool\n        .calc_pool_tokens_stake_withdrawal_fee(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n    let pool_tokens_burnt = pool_tokens\n        .checked_sub(pool_tokens_fee)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let withdraw_lamports = stake_pool\n        .calc_lamports_withdraw_amount(pool_tokens_burnt)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if withdraw_lamports == 0 {\n        return Err(StakePoolError::WithdrawalTooSmall.into());\n    }\n\n    if let Some(minimum_lamports_out) = minimum_lamports_out {\n        if withdraw_lamports < minimum_lamports_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    let stake_minimum_delegation = stake::tools::get_minimum_delegation()?;\n    let stake_state = try_from_slice_unchecked::<stake::state::StakeStateV2>(&stake_split_from.data.borrow())?;\n    let meta = stake_state.meta().ok_or(StakePoolError::WrongStakeStake)?;\n    let required_lamports = minimum_stake_lamports(&meta, stake_minimum_delegation);\n\n    let remaining_lamports = stake_split_from.lamports().saturating_sub(withdraw_lamports);\n    if remaining_lamports < required_lamports {\n        return Err(StakePoolError::StakeLamportsNotEqualToMinimum.into());\n    }\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function implements comprehensive validation: epoch freshness check, minimum withdrawal threshold (withdraw_lamports == 0), slippage protection, stake minimum delegation verification, and remaining balance check to ensure stake account stays above minimum.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    fee: FeeType,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n    stake_pool.check_manager(manager_info)?;\n\n    if fee.can_only_change_next_epoch() && stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    fee.check_too_high()?;\n    stake_pool.update_fee(&fee)?;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function validates: program ownership, pool state validity, manager authorization, epoch-dependent fee change timing, and fee bounds via check_too_high(). The FeeType abstraction encapsulates validation logic for different fee types.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn _process_initialize_multisig(\n    accounts: &[AccountInfo],\n    m: u8,\n    rent_sysvar_account: bool,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let multisig_info = next_account_info(account_info_iter)?;\n    let multisig_info_data_len = multisig_info.data_len();\n    let rent = if rent_sysvar_account {\n        Rent::from_account_info(next_account_info(account_info_iter)?)?\n    } else {\n        Rent::get()?\n    };\n\n    let mut multisig = Multisig::unpack_unchecked(&multisig_info.data.borrow())?;\n    if multisig.is_initialized {\n        return Err(TokenError::AlreadyInUse.into());\n    }\n\n    if !rent.is_exempt(multisig_info.lamports(), multisig_info_data_len) {\n        return Err(TokenError::NotRentExempt.into());\n    }\n\n    let signer_infos = account_info_iter.as_slice();\n    multisig.m = m;\n    multisig.n = signer_infos.len() as u8;\n    \n    if !is_valid_signer_index(multisig.n as usize) {\n        return Err(TokenError::InvalidNumberOfProvidedSigners.into());\n    }\n    if !is_valid_signer_index(multisig.m as usize) {\n        return Err(TokenError::InvalidNumberOfRequiredSigners.into());\n    }\n    \n    for (i, signer_info) in signer_infos.iter().enumerate() {\n        multisig.signers[i] = *signer_info.key;\n    }\n    multisig.is_initialized = true;\n\n    Multisig::pack(multisig, &mut multisig_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function validates: re-initialization prevention, rent-exemption, signer count via is_valid_signer_index (ensures n within bounds), required signers validation (ensures m is valid), and implicitly m <= n through the validation logic.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let stake_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    stake_pool.check_staker(staker_info)?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n    \n    if header.max_validators == validator_list.len() {\n        return Err(ProgramError::AccountDataTooSmall);\n    }\n    if validator_list.len() >= MAX_VALIDATORS_IN_POOL {\n        return Err(StakePoolError::TooManyValidatorsInPool.into());\n    }\n    \n    let maybe_validator = validator_list.find::<ValidatorStakeInfo, _>(|x| {\n        ValidatorStakeInfo::memcmp_pubkey(x, validator_vote_info.key)\n    });\n    if maybe_validator.is_some() {\n        return Err(StakePoolError::ValidatorAlreadyAdded.into());\n    }\n\n    let (stake_address, _) = crate::find_stake_program_address(\n        program_id, validator_vote_info.key, stake_pool_info.key, NonZeroU32::new(raw_validator_seed)\n    );\n    if stake_address != *stake_info.key {\n        return Err(StakePoolError::InvalidStakeAccountAddress.into());\n    }\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function validates: staker authorization, epoch freshness, validator list capacity (both header and global max), duplicate validator prevention, and stake account address derivation verification. Comprehensive input validation prevents all common attack vectors.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "fn process_withdraw_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n    minimum_lamports_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let pool_tokens_fee = stake_pool\n        .calc_pool_tokens_sol_withdrawal_fee(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n    let pool_tokens_burnt = pool_tokens\n        .checked_sub(pool_tokens_fee)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let withdraw_lamports = stake_pool\n        .calc_lamports_withdraw_amount(pool_tokens_burnt)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if withdraw_lamports == 0 {\n        return Err(StakePoolError::WithdrawalTooSmall.into());\n    }\n\n    if let Some(minimum_lamports_out) = minimum_lamports_out {\n        if withdraw_lamports < minimum_lamports_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    let new_reserve_lamports = reserve_stake_info.lamports().saturating_sub(withdraw_lamports);\n    let stake_state = try_from_slice_unchecked::<stake::state::StakeStateV2>(&reserve_stake_info.data.borrow())?;\n    if let stake::state::StakeStateV2::Initialized(meta) = stake_state {\n        let minimum_reserve_lamports = minimum_reserve_lamports(&meta);\n        if new_reserve_lamports < minimum_reserve_lamports {\n            return Err(StakePoolError::SolWithdrawalTooLarge.into());\n        }\n    }\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function implements thorough validation: epoch freshness, minimum withdrawal check, slippage protection, and critically validates that withdrawal won't drain reserve below minimum rent-exempt threshold (SolWithdrawalTooLarge check).",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.",
    "input": "pub fn process_approve(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let expected_mint_info = if let Some(expected_decimals) = expected_decimals {\n        Some((next_account_info(account_info_iter)?, expected_decimals))\n    } else {\n        None\n    };\n    let delegate_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n\n    if source_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n\n    if let Some((mint_info, expected_decimals)) = expected_mint_info {\n        if !Self::cmp_pubkeys(mint_info.key, &source_account.mint) {\n            return Err(TokenError::MintMismatch.into());\n        }\n        let mint = Mint::unpack(&mint_info.data.borrow_mut())?;\n        if expected_decimals != mint.decimals {\n            return Err(TokenError::MintDecimalsMismatch.into());\n        }\n    }\n\n    Self::validate_owner(\n        program_id,\n        &source_account.owner,\n        owner_info,\n        account_info_iter.as_slice(),\n    )?;\n\n    source_account.delegate = COption::Some(*delegate_info.key);\n    source_account.delegated_amount = amount;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV4 - Input Validation - MITIGATED\nThe function validates: frozen account status, optional decimals matching for ApproveChecked variant, mint consistency when decimals provided, and owner authorization. The amount parameter is intentionally flexible as allowances can exceed balance.",
    "label": "SAFE"
  }
]