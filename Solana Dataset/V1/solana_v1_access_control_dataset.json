[
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_set_manager(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let new_manager_info = next_account_info(account_info_iter)?;\n    let new_manager_fee_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    // Missing: stake_pool.check_manager(manager_info)?\n    // Missing: new_manager_info.is_signer check\n    \n    stake_pool.manager = *new_manager_info.key;\n    stake_pool.manager_fee_account = *new_manager_fee_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nCRITICAL\nThe function allows anyone to change the stake pool manager without verifying that the caller is the current manager and without requiring the new manager to sign. An attacker can take over pool management and redirect fees.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n\n    // Missing: validate_owner check for authority_info\n    // Anyone can transfer tokens from any account\n    \n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nCRITICAL\nThe transfer function does not validate that authority_info is the owner of the source account or an authorized delegate. Any user can drain tokens from any account by simply providing an arbitrary authority.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_set_staker(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let set_staker_authority_info = next_account_info(account_info_iter)?;\n    let new_staker_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    // Only checks if caller is signer, not if they are authorized\n    if !set_staker_authority_info.is_signer {\n        return Err(StakePoolError::SignatureMissing.into());\n    }\n    \n    stake_pool.staker = *new_staker_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nCRITICAL\nThe function only verifies that set_staker_authority_info is a signer but does not check if they are the current staker or manager. Any signer can change the staker role, allowing unauthorized control over stake delegation.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    // Missing mint_authority validation\n    // Should check: mint.mint_authority matches owner_info\n    \n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nCRITICAL\nThe mint_to function does not verify that owner_info matches the mint's mint_authority. Anyone can mint unlimited tokens, causing severe inflation and destroying the token's value.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_withdraw_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let destination_lamports_info = next_account_info(account_info_iter)?;\n    let burn_from_pool_info = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    // Missing: stake_pool.check_authority_withdraw verification\n    // Missing: check_account_owner for stake_pool_info\n    \n    let withdraw_lamports = stake_pool.calc_lamports_withdraw_amount(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    Self::stake_withdraw(\n        stake_pool_info.key,\n        reserve_stake_info.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        destination_lamports_info.clone(),\n        withdraw_lamports,\n    )?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nCRITICAL\nThe withdrawal function does not verify the withdraw_authority_info against the stake pool's expected authority. An attacker could provide a fake withdraw authority and drain the reserve stake.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_close_account(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let source_account = Account::unpack(&source_account_info.data.borrow())?;\n    \n    if source_account.amount != 0 {\n        return Err(TokenError::NonNativeHasBalance.into());\n    }\n\n    // Missing owner/close_authority validation\n    // Any signer can close any empty account\n    \n    let destination_starting_lamports = destination_account_info.lamports();\n    **destination_account_info.lamports.borrow_mut() = destination_starting_lamports\n        .checked_add(source_account_info.lamports())\n        .ok_or(TokenError::Overflow)?;\n\n    **source_account_info.lamports.borrow_mut() = 0;\n    delete_account(source_account_info)?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nHIGH\nThe close_account function does not verify that authority_info is the account owner or designated close_authority. Any user can close empty token accounts and receive the rent lamports.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let stake_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    // Missing: stake_pool.check_staker(staker_info)?\n    // Missing: check_account_owner(stake_pool_info, program_id)?\n    \n    let (stake_address, bump_seed) = crate::find_stake_program_address(\n        program_id,\n        validator_vote_info.key,\n        stake_pool_info.key,\n        NonZeroU32::new(seed),\n    );\n    \n    // Continue with validator addition...\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nHIGH\nThe add_validator function does not verify that staker_info is the authorized staker for the pool. An attacker could add malicious validators to dilute staking rewards or manipulate the validator set.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_set_authority(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    authority_type: AuthorityType,\n    new_authority: COption<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut mint = Mint::unpack(&account_info.data.borrow())?;\n    \n    match authority_type {\n        AuthorityType::MintTokens => {\n            // Missing validation that authority_info matches mint.mint_authority\n            // Anyone can change the mint authority\n            mint.mint_authority = new_authority;\n        }\n        AuthorityType::FreezeAccount => {\n            mint.freeze_authority = new_authority;\n        }\n        _ => return Err(TokenError::AuthorityTypeNotSupported.into()),\n    }\n    \n    Mint::pack(mint, &mut account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nCRITICAL\nThe set_authority function does not validate that authority_info is the current mint_authority or freeze_authority. An attacker can take over the mint by setting themselves as the new authority.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    fee: FeeType,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    // Missing: check_account_owner(stake_pool_info, program_id)?\n    // Missing: stake_pool.check_manager(manager_info)?\n    \n    fee.check_too_high()?;\n    stake_pool.update_fee(&fee)?;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nHIGH\nThe set_fee function does not verify that manager_info is the actual pool manager or that stake_pool_info is owned by the program. Anyone can modify pool fees, potentially extracting value from depositors.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_burn(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n\n    // Missing: validate_owner for source_account.owner or delegate\n    // Anyone can burn tokens from any account\n    \n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_sub(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV1 - Access Control\nCRITICAL\nThe burn function does not validate that authority_info is the account owner or an authorized delegate. An attacker can burn any user's tokens, destroying their holdings without permission.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_set_manager(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let new_manager_info = next_account_info(account_info_iter)?;\n    let new_manager_fee_info = next_account_info(account_info_iter)?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    check_account_owner(new_manager_fee_info, &stake_pool.token_program_id)?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    stake_pool.check_manager(manager_info)?;\n    if !new_manager_info.is_signer {\n        msg!(\"New manager signature missing\");\n        return Err(StakePoolError::SignatureMissing.into());\n    }\n\n    stake_pool.check_manager_fee_info(new_manager_fee_info)?;\n\n    stake_pool.manager = *new_manager_info.key;\n    stake_pool.manager_fee_account = *new_manager_fee_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe function implements comprehensive access control: (1) verifies account ownership, (2) validates current manager authorization, (3) requires new manager signature, and (4) validates fee account. Two-party authorization prevents unauthorized manager transfers.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    if source_account.is_frozen() || destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    if !Self::cmp_pubkeys(&source_account.mint, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    match source_account.delegate {\n        COption::Some(ref delegate) if Self::cmp_pubkeys(authority_info.key, delegate) => {\n            Self::validate_owner(program_id, delegate, authority_info, account_info_iter.as_slice())?;\n            if source_account.delegated_amount < amount {\n                return Err(TokenError::InsufficientFunds.into());\n            }\n            source_account.delegated_amount = source_account.delegated_amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n        }\n        _ => Self::validate_owner(program_id, &source_account.owner, authority_info, account_info_iter.as_slice())?,\n    };\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe transfer function properly validates ownership through validate_owner, which checks either the account owner or an authorized delegate. It also verifies frozen status and mint consistency before any transfer.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_set_staker(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let set_staker_authority_info = next_account_info(account_info_iter)?;\n    let new_staker_info = next_account_info(account_info_iter)?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    let staker_signed = stake_pool.check_staker(set_staker_authority_info);\n    let manager_signed = stake_pool.check_manager(set_staker_authority_info);\n    if staker_signed.is_err() && manager_signed.is_err() {\n        return Err(StakePoolError::SignatureMissing.into());\n    }\n    stake_pool.staker = *new_staker_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe function implements dual-authority access control where either the current staker OR the manager can authorize staker changes. This provides operational flexibility while maintaining security through proper authorization checks.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    if destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if destination_account.is_native() {\n        return Err(TokenError::NativeNotSupported.into());\n    }\n    if !Self::cmp_pubkeys(mint_info.key, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    match mint.mint_authority {\n        COption::Some(mint_authority) => Self::validate_owner(\n            program_id,\n            &mint_authority,\n            owner_info,\n            account_info_iter.as_slice(),\n        )?,\n        COption::None => return Err(TokenError::FixedSupply.into()),\n    }\n\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe mint_to function properly validates that owner_info matches the mint's mint_authority through validate_owner. It also handles the fixed supply case and verifies mint consistency with the destination account.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_withdraw_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n    minimum_lamports_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let destination_lamports_info = next_account_info(account_info_iter)?;\n    let manager_fee_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let burn_from_pool_info = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    stake_pool.check_authority_withdraw(withdraw_authority_info.key, program_id, stake_pool_info.key)?;\n    stake_pool.check_reserve_stake(reserve_stake_info)?;\n    stake_pool.check_mint(pool_mint_info)?;\n\n    if stake_pool.manager_fee_account != *manager_fee_info.key {\n        return Err(StakePoolError::InvalidFeeAccount.into());\n    }\n\n    let withdraw_lamports = stake_pool.calc_lamports_withdraw_amount(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if withdraw_lamports == 0 {\n        return Err(StakePoolError::WithdrawalTooSmall.into());\n    }\n\n    if let Some(minimum_lamports_out) = minimum_lamports_out {\n        if withdraw_lamports < minimum_lamports_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    Self::token_burn(token_program_info.clone(), burn_from_pool_info.clone(), pool_mint_info.clone(), user_transfer_authority_info.clone(), pool_tokens)?;\n    Self::stake_withdraw(stake_pool_info.key, reserve_stake_info.clone(), withdraw_authority_info.clone(), AUTHORITY_WITHDRAW, stake_pool.stake_withdraw_bump_seed, destination_lamports_info.clone(), withdraw_lamports)?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe withdrawal function implements comprehensive validation: account ownership, withdraw authority verification, reserve stake validation, fee account validation, and slippage protection. All critical accounts are properly verified before any state changes.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_close_account(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let source_account = Account::unpack(&source_account_info.data.borrow())?;\n\n    if !source_account.is_native() && source_account.amount != 0 {\n        return Err(TokenError::NonNativeHasBalance.into());\n    }\n\n    let authority = source_account.close_authority.unwrap_or(source_account.owner);\n    Self::validate_owner(\n        program_id,\n        &authority,\n        authority_info,\n        account_info_iter.as_slice(),\n    )?;\n\n    let destination_starting_lamports = destination_account_info.lamports();\n    **destination_account_info.lamports.borrow_mut() = destination_starting_lamports\n        .checked_add(source_account_info.lamports())\n        .ok_or(TokenError::Overflow)?;\n\n    **source_account_info.lamports.borrow_mut() = 0;\n    delete_account(source_account_info)?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe close_account function properly validates authority through validate_owner, checking against either the designated close_authority or the account owner. Only authorized parties can close accounts and receive rent lamports.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let stake_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    stake_pool.check_authority_withdraw(withdraw_authority_info.key, program_id, stake_pool_info.key)?;\n    stake_pool.check_staker(staker_info)?;\n    stake_pool.check_reserve_stake(reserve_stake_info)?;\n    stake_pool.check_validator_list(validator_list_info)?;\n\n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    check_account_owner(validator_list_info, program_id)?;\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n    \n    let maybe_validator = validator_list.find::<ValidatorStakeInfo, _>(|x| ValidatorStakeInfo::memcmp_pubkey(x, validator_vote_info.key));\n    if maybe_validator.is_some() {\n        return Err(StakePoolError::ValidatorAlreadyAdded.into());\n    }\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe add_validator function implements thorough access control: verifies program ownership, validates staker authorization, checks withdraw authority, verifies reserve stake and validator list. Prevents duplicate validators and requires fresh epoch data.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_set_authority(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    authority_type: AuthorityType,\n    new_authority: COption<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    if account_info.data_len() == Mint::get_packed_len() {\n        let mut mint = Mint::unpack(&account_info.data.borrow())?;\n        match authority_type {\n            AuthorityType::MintTokens => {\n                let mint_authority = mint.mint_authority\n                    .ok_or(Into::<ProgramError>::into(TokenError::FixedSupply))?;\n                Self::validate_owner(\n                    program_id,\n                    &mint_authority,\n                    authority_info,\n                    account_info_iter.as_slice(),\n                )?;\n                mint.mint_authority = new_authority;\n            }\n            AuthorityType::FreezeAccount => {\n                let freeze_authority = mint.freeze_authority\n                    .ok_or(Into::<ProgramError>::into(TokenError::MintCannotFreeze))?;\n                Self::validate_owner(\n                    program_id,\n                    &freeze_authority,\n                    authority_info,\n                    account_info_iter.as_slice(),\n                )?;\n                mint.freeze_authority = new_authority;\n            }\n            _ => return Err(TokenError::AuthorityTypeNotSupported.into()),\n        }\n        Mint::pack(mint, &mut account_info.data.borrow_mut())?;\n    }\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe set_authority function properly validates that the caller is the current authority through validate_owner before allowing any authority changes. Handles both mint_authority and freeze_authority with appropriate checks for fixed supply mints.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "fn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    fee: FeeType,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n    stake_pool.check_manager(manager_info)?;\n\n    if fee.can_only_change_next_epoch() && stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    fee.check_too_high()?;\n    stake_pool.update_fee(&fee)?;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe set_fee function properly validates program ownership, stake pool state, and manager authorization. Additional protection ensures fees cannot exceed reasonable bounds and epoch-dependent fees require fresh state.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.",
    "input": "pub fn process_burn(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    if source_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if source_account.is_native() {\n        return Err(TokenError::NativeNotSupported.into());\n    }\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    if !Self::cmp_pubkeys(mint_info.key, &source_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    match source_account.delegate {\n        COption::Some(ref delegate) if Self::cmp_pubkeys(authority_info.key, delegate) => {\n            Self::validate_owner(program_id, delegate, authority_info, account_info_iter.as_slice())?;\n            if source_account.delegated_amount < amount {\n                return Err(TokenError::InsufficientFunds.into());\n            }\n            source_account.delegated_amount = source_account.delegated_amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n        }\n        _ => Self::validate_owner(program_id, &source_account.owner, authority_info, account_info_iter.as_slice())?,\n    }\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_sub(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV1 - Access Control - MITIGATED\nThe burn function validates authority through validate_owner, supporting both owner and delegate burning. It checks frozen status, native token restrictions, sufficient funds, mint consistency, and delegate allowance before burning.",
    "label": "SAFE"
  }
]
