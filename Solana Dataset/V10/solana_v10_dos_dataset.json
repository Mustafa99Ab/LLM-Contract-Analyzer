[
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_distribute_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let reward_vault = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let pool = Pool::unpack(&pool_info.data.borrow())?;\n    \n    for staker in pool.stakers.iter() {\n        let reward = calculate_reward(staker)?;\n        \n        let transfer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            reward_vault.key,\n            &staker.reward_account,\n            pool_info.key,\n            &[],\n            reward,\n        )?;\n        \n        invoke_signed(&transfer_ix, &[reward_vault.clone()], &[])?;\n    }\n\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nCRITICAL\nUnbounded iteration over pool.stakers without pagination. If the stakers list grows large, the transaction will exceed Solana's compute budget (200K CU default, 1.4M max). An attacker can add many small stakes to make reward distribution impossible, permanently locking rewards.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_refund_all_bidders(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let auction_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut auction = Auction::unpack(&auction_info.data.borrow())?;\n    \n    if !auction.ended {\n        return Err(AuctionError::NotEnded.into());\n    }\n\n    for bidder in auction.bidders.iter() {\n        if *bidder != auction.winner {\n            refund_bidder(bidder, auction.bid_amounts.get(bidder).unwrap())?;\n        }\n    }\n\n    auction.refunds_completed = true;\n    Auction::pack(auction, &mut auction_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nCRITICAL\nMass refund pattern with unbounded iteration. If any single refund fails (malicious bidder contract, closed account), the entire transaction reverts and no one gets refunded. A single malicious participant can permanently block all refunds. Should use pull-payment pattern instead.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "#[account]\npub struct ValidatorList {\n    pub validators: Vec<ValidatorInfo>,\n}\n\npub fn process_add_validator(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    vote_account: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n\n    let pool = StakePool::unpack(&pool_info.data.borrow())?;\n    let mut validator_list = ValidatorList::unpack(&validator_list_info.data.borrow())?;\n    \n    pool.check_manager(manager_info)?;\n\n    let new_validator = ValidatorInfo {\n        vote_account,\n        stake_lamports: 0,\n        last_update_epoch: Clock::get()?.epoch,\n    };\n    \n    validator_list.validators.push(new_validator);\n    ValidatorList::pack(validator_list, &mut validator_list_info.data.borrow_mut())?;\n\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nHIGH\nNo limit on validator list size. An attacker (or compromised manager) could add validators until: (1) Account data exceeds Solana's 10MB limit. (2) Iteration over validators in other functions exceeds compute budget. (3) Reallocation costs become prohibitive. Should enforce MAX_VALIDATORS limit.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_claim_all_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_info = next_account_info(account_info_iter)?;\n    let user_stakes_info = next_account_info(account_info_iter)?;\n\n    let user_stakes = UserStakes::unpack(&user_stakes_info.data.borrow())?;\n    let mut total_claimed: u64 = 0;\n\n    for stake in user_stakes.active_stakes.iter() {\n        let pool_info = find_pool_account(&stake.pool)?;\n        let pool = Pool::unpack(&pool_info.data.borrow())?;\n        \n        let pending = calculate_pending_rewards(stake, &pool)?;\n        \n        transfer_rewards(user_info, pending)?;\n        total_claimed = total_claimed.checked_add(pending)\n            .ok_or(ProgramError::ArithmeticOverflow)?;\n    }\n\n    msg!(\"Total claimed: {}\", total_claimed);\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nHIGH\nIteration over unbounded active_stakes with CPI calls inside loop. Each stake requires: account lookup, deserialization, calculation, and transfer CPI. If user has many stakes, compute budget is exhausted. Users with many small stakes cannot claim any rewards.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_finalize_governance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n\n    let mut governance = Governance::unpack(&governance_info.data.borrow())?;\n    let proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n\n    if proposal.state != ProposalState::Succeeded {\n        return Err(GovernanceError::InvalidState.into());\n    }\n\n    for instruction in proposal.instructions.iter() {\n        let ix = Instruction {\n            program_id: instruction.program_id,\n            accounts: instruction.accounts.clone(),\n            data: instruction.data.clone(),\n        };\n        invoke(&ix, accounts)?;\n    }\n\n    governance.executed_proposals = governance.executed_proposals\n        .checked_add(1)\n        .ok_or(GovernanceError::Overflow)?;\n    Governance::pack(governance, &mut governance_info.data.borrow_mut())?;\n\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nCRITICAL\nUnbounded proposal instruction execution. A malicious proposal could contain hundreds of instructions, exhausting compute budget and making execution impossible. Even legitimate large proposals become unexecutable. Should limit MAX_INSTRUCTIONS_PER_PROPOSAL.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_update_all_positions(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let market_info = next_account_info(account_info_iter)?;\n    let oracle_info = next_account_info(account_info_iter)?;\n\n    let mut market = Market::unpack(&market_info.data.borrow())?;\n    let oracle_price = get_oracle_price(oracle_info)?;\n\n    for position in market.positions.iter_mut() {\n        position.unrealized_pnl = calculate_pnl(position, oracle_price)?;\n        position.margin_ratio = calculate_margin(position, oracle_price)?;\n        position.last_update = Clock::get()?.unix_timestamp;\n    }\n\n    Market::pack(market, &mut market_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nHIGH\nMass position update without pagination. As positions grow, this function becomes uncallable. Market state (PnL, margins) becomes stale because updates fail. Could lead to incorrect liquidations or allow underwater positions to persist.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub bidder: Signer<'info>,\n}\n\n#[account]\npub struct Auction {\n    pub bids: Vec<Bid>,\n    pub highest_bid: u64,\n    pub end_time: i64,\n}\n\npub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n    let auction = &mut ctx.accounts.auction;\n    let clock = Clock::get()?;\n\n    require!(clock.unix_timestamp < auction.end_time, AuctionError::Ended);\n    require!(amount > auction.highest_bid, AuctionError::BidTooLow);\n\n    auction.bids.push(Bid {\n        bidder: ctx.accounts.bidder.key(),\n        amount,\n        timestamp: clock.unix_timestamp,\n    });\n    \n    auction.highest_bid = amount;\n\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nHIGH\nUnbounded Vec growth for bids. Each bid permanently increases storage. Attack: place many minimum-increment bids to grow the Vec until account reallocation fails or future operations on the auction exceed compute budget. Should only track current highest bid or limit bid history.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_settle_market(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let market_info = next_account_info(account_info_iter)?;\n    let settlement_price_info = next_account_info(account_info_iter)?;\n\n    let mut market = Market::unpack(&market_info.data.borrow())?;\n    let settlement_price = get_settlement_price(settlement_price_info)?;\n\n    for order in market.open_orders.iter() {\n        let pnl = calculate_settlement_pnl(order, settlement_price)?;\n        settle_order(order, pnl)?;\n    }\n\n    market.is_settled = true;\n    Market::pack(market, &mut market_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nCRITICAL\nSettlement requires processing all open orders in one transaction. If market has many orders, settlement becomes impossible. Users cannot receive their settlement proceeds. Market remains in limbo state. Should use claim-based settlement where users settle individually.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_compound_all(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let strategy_info = next_account_info(account_info_iter)?;\n\n    let vault = Vault::unpack(&vault_info.data.borrow())?;\n\n    for depositor in vault.depositors.iter() {\n        let pending_yield = calculate_yield(depositor)?;\n        \n        let new_shares = pending_yield\n            .checked_mul(vault.total_shares)?\n            .checked_div(vault.total_assets)?;\n        \n        update_depositor_shares(depositor, new_shares)?;\n    }\n\n    harvest_strategy(strategy_info)?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nHIGH\nCompounding requires iterating all depositors. As vault grows popular, compound function fails, yield stops accumulating for everyone. Vault becomes economically broken - no one can earn yield. Should compound per-user on interaction (lazy compounding).",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_emergency_withdraw_all(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let admin_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    if !admin_info.is_signer || vault.admin != *admin_info.key {\n        return Err(VaultError::Unauthorized.into());\n    }\n\n    for user in vault.users.iter() {\n        let user_balance = vault.get_balance(&user.pubkey)?;\n        \n        transfer_tokens(\n            token_program,\n            vault_info,\n            &user.token_account,\n            user_balance,\n        )?;\n    }\n\n    vault.is_emergency = true;\n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV10 - Denial of Service\nCRITICAL\nEmergency withdrawal iterates all users with CPI transfers. If vault has many users, emergency withdrawal fails. During actual emergency (hack, exploit), admin cannot rescue funds. Should allow individual emergency claims instead.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) =\n        ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n\n    if !header.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n    if header.max_validators == validator_list.len() {\n        return Err(ProgramError::AccountDataTooSmall);\n    }\n    if validator_list.len() >= MAX_VALIDATORS_IN_POOL {\n        return Err(StakePoolError::TooManyValidatorsInPool.into());\n    }\n    \n    let maybe_validator = validator_list.find::<ValidatorStakeInfo, _>(|x| {\n        ValidatorStakeInfo::memcmp_pubkey(x, validator_vote_info.key)\n    });\n    if maybe_validator.is_some() {\n        return Err(StakePoolError::ValidatorAlreadyAdded.into());\n    }\n\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nThree-layer DoS protection: (1) header.max_validators enforces pool-specific limit. (2) MAX_VALIDATORS_IN_POOL enforces global hard cap. (3) Duplicate check prevents same validator added twice. This ensures UpdateValidatorListBalance stays within compute budget regardless of attack attempts.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_update_validator_list_balance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    start_index: u32,\n    no_merge: bool,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let validator_stake_accounts = account_info_iter.as_slice();\n\n    let stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n\n    let epoch_rewards = EpochRewards::get()?;\n    if epoch_rewards.active {\n        return Err(StakePoolError::EpochRewardDistributionInProgress.into());\n    }\n\n    if validator_stake_accounts.len().checked_rem(2)\n        .ok_or(StakePoolError::CalculationFailure)? != 0 {\n        return Err(StakePoolError::UnexpectedValidatorListAccountSize.into());\n    }\n\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut big_vec) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n    \n    let validator_slice = ValidatorListHeader::deserialize_mut_slice(\n        &mut big_vec,\n        start_index as usize,\n        validator_stake_accounts.len() / 2,\n    )?;\n\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nPaginated processing with start_index allows updating large validator lists across multiple transactions. Epoch rewards check prevents inconsistent state during distribution. Input validation (pairs check) prevents malformed requests. Large pools remain operational via batched updates.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_claim_reward(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n    let user_reward_info = next_account_info(account_info_iter)?;\n    let reward_vault = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let pool = Pool::unpack(&pool_info.data.borrow())?;\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    if user_stake.owner != *user_info.key {\n        return Err(StakingError::InvalidOwner.into());\n    }\n\n    let pending = calculate_pending_rewards(&user_stake, &pool)?;\n    \n    if pending == 0 {\n        return Err(StakingError::NoRewards.into());\n    }\n\n    user_stake.reward_debt = user_stake.amount\n        .checked_mul(pool.acc_reward_per_share)?\n        .checked_div(PRECISION)?;\n    user_stake.last_claim = Clock::get()?.unix_timestamp;\n    \n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n\n    transfer_reward(reward_vault, user_reward_info, pending, token_program)?;\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nPull-payment pattern: each user claims their own rewards individually. No iteration over users, no mass operations. User A's claim cannot affect User B. Compute cost is constant regardless of total stakers. Protocol scales to unlimited users.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_claim_auction_refund(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let auction_info = next_account_info(account_info_iter)?;\n    let bidder_info = next_account_info(account_info_iter)?;\n    let bidder_token_info = next_account_info(account_info_iter)?;\n    let escrow_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let auction = Auction::unpack(&auction_info.data.borrow())?;\n    \n    if !auction.ended {\n        return Err(AuctionError::NotEnded.into());\n    }\n    if *bidder_info.key == auction.winner {\n        return Err(AuctionError::WinnerCannotRefund.into());\n    }\n\n    let bid_amount = auction.get_bid(bidder_info.key)\n        .ok_or(AuctionError::NoBidFound)?;\n    \n    if auction.refunded.contains(bidder_info.key) {\n        return Err(AuctionError::AlreadyRefunded.into());\n    }\n\n    transfer_from_escrow(escrow_info, bidder_token_info, bid_amount, token_program)?;\n    \n    mark_refunded(auction_info, bidder_info.key)?;\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nPull-payment refund pattern: each bidder claims their own refund. One malicious bidder cannot block others. Duplicate refund prevention via refunded set. Auction can end regardless of individual refund status. All operations are O(1) per user.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "#[account]\npub struct Auction {\n    pub highest_bidder: Pubkey,\n    pub highest_bid: u64,\n    pub previous_bidder: Pubkey,\n    pub previous_bid: u64,\n    pub end_time: i64,\n    pub ended: bool,\n}\n\npub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n    let auction = &mut ctx.accounts.auction;\n    let clock = Clock::get()?;\n\n    require!(clock.unix_timestamp < auction.end_time, AuctionError::Ended);\n    require!(amount > auction.highest_bid, AuctionError::BidTooLow);\n\n    auction.previous_bidder = auction.highest_bidder;\n    auction.previous_bid = auction.highest_bid;\n    \n    auction.highest_bidder = ctx.accounts.bidder.key();\n    auction.highest_bid = amount;\n\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nFixed-size storage: only tracks current and previous bid, not all bids. No Vec growth regardless of bid count. Account size remains constant. Auction cannot be bloated by many bids. Previous bidder can claim refund via pull pattern.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_execute_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_index: u16,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n\n    if proposal.state != ProposalState::Succeeded {\n        return Err(GovernanceError::InvalidState.into());\n    }\n    \n    let instruction = proposal.instructions\n        .get(instruction_index as usize)\n        .ok_or(GovernanceError::InvalidInstructionIndex)?;\n    \n    if proposal.executed_instructions.contains(&instruction_index) {\n        return Err(GovernanceError::InstructionAlreadyExecuted.into());\n    }\n\n    let ix = Instruction {\n        program_id: instruction.program_id,\n        accounts: instruction.accounts.clone(),\n        data: instruction.data.clone(),\n    };\n    invoke(&ix, accounts)?;\n\n    proposal.executed_instructions.push(instruction_index);\n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nPer-instruction execution: proposals execute one instruction at a time via instruction_index. Large proposals with many instructions can execute across multiple transactions. Double-execution prevention via executed_instructions tracking. Governance remains operational regardless of proposal complexity.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_settle_position(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let market_info = next_account_info(account_info_iter)?;\n    let position_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let user_token_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let market = Market::unpack(&market_info.data.borrow())?;\n    let mut position = Position::unpack(&position_info.data.borrow())?;\n\n    if !market.is_settled {\n        return Err(MarketError::NotSettled.into());\n    }\n    if position.owner != *user_info.key {\n        return Err(MarketError::InvalidOwner.into());\n    }\n    if position.is_settled {\n        return Err(MarketError::AlreadySettled.into());\n    }\n\n    let pnl = calculate_settlement_pnl(&position, market.settlement_price)?;\n    \n    position.is_settled = true;\n    Position::pack(position, &mut position_info.data.borrow_mut())?;\n\n    if pnl > 0 {\n        transfer_pnl(vault_info, user_token_info, pnl as u64, token_program)?;\n    }\n\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nIndividual settlement: each user settles their own position. Market settlement (setting is_settled flag) is separate from position settlements. No iteration over positions. Market can handle unlimited positions because settlement is O(1) per position.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "const MAX_DEPOSITORS: usize = 1000;\n\n#[account]\npub struct Vault {\n    pub depositors: Vec<Pubkey>,\n    pub balances: Vec<u64>,\n    pub total_deposited: u64,\n}\n\npub fn process_deposit(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    let user_index = vault.depositors.iter().position(|d| d == user_info.key);\n    \n    match user_index {\n        Some(idx) => {\n            vault.balances[idx] = vault.balances[idx]\n                .checked_add(amount)\n                .ok_or(VaultError::Overflow)?;\n        }\n        None => {\n            if vault.depositors.len() >= MAX_DEPOSITORS {\n                return Err(VaultError::MaxDepositorsReached.into());\n            }\n            vault.depositors.push(*user_info.key);\n            vault.balances.push(amount);\n        }\n    }\n    \n    vault.total_deposited = vault.total_deposited\n        .checked_add(amount)\n        .ok_or(VaultError::Overflow)?;\n    \n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nMAX_DEPOSITORS constant limits Vec growth. Duplicate check prevents same user added twice. Account size bounded and predictable. Compute cost for iteration is bounded. Vault operations remain within compute budget.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "pub fn process_emergency_claim(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let user_token_info = next_account_info(account_info_iter)?;\n    let vault_token_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    if !vault.emergency_mode {\n        return Err(VaultError::NotEmergency.into());\n    }\n\n    let user_shares = get_user_shares(&vault, user_info.key)?;\n    if user_shares == 0 {\n        return Err(VaultError::NoShares.into());\n    }\n\n    let claim_amount = user_shares\n        .checked_mul(vault.total_assets)?\n        .checked_div(vault.total_shares)?;\n\n    burn_user_shares(vault_info, user_info.key)?;\n    \n    transfer_tokens(\n        token_program,\n        vault_token_info,\n        user_token_info,\n        claim_amount,\n    )?;\n\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nIndividual emergency claims: users rescue their own funds. Admin only needs to set emergency_mode flag (single operation). No iteration over users required. Vault can have unlimited users and still allow emergency exits. Each claim is O(1).",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.",
    "input": "const MAX_INSTRUCTIONS: usize = 10;\n\npub fn create_proposal(\n    ctx: Context<CreateProposal>,\n    instructions: Vec<ProposalInstruction>,\n) -> Result<()> {\n    let proposal = &mut ctx.accounts.proposal;\n    let governance = &ctx.accounts.governance;\n\n    require!(\n        instructions.len() <= MAX_INSTRUCTIONS,\n        GovernanceError::TooManyInstructions\n    );\n\n    require!(\n        instructions.len() > 0,\n        GovernanceError::NoInstructions\n    );\n\n    proposal.governance = governance.key();\n    proposal.proposer = ctx.accounts.proposer.key();\n    proposal.instructions = instructions;\n    proposal.state = ProposalState::Draft;\n    proposal.executed_count = 0;\n    proposal.created_at = Clock::get()?.unix_timestamp;\n\n    Ok(())\n}",
    "output": "SAFE\nV10 - Denial of Service - MITIGATED\nMAX_INSTRUCTIONS constant limits proposal complexity at creation time. Prevents proposals with hundreds of instructions that would exceed compute budget during execution. Combined with per-instruction execution pattern, governance remains operational for any proposal size up to the limit.",
    "label": "SAFE"
  }
]