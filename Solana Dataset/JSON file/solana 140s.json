[
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_add_to_balance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    if !authority_info.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let mut user_account = UserAccount::unpack(&user_account_info.data.borrow())?;\n    \n    user_account.balance += amount;\n    \n    UserAccount::pack(user_account, &mut user_account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nCRITICAL\nThe balance addition uses the += operator without overflow protection. In Rust release builds, integer overflow wraps around silently. If balance is near u64::MAX and amount is added, the balance wraps to a small value, potentially allowing attackers to manipulate account state or drain funds.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_initialize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    epoch_fee: Fee,\n    withdrawal_fee: Fee,\n    deposit_fee: Fee,\n    referral_fee: u8,\n    max_validators: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    \n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    \n    stake_pool.epoch_fee = epoch_fee;\n    stake_pool.stake_withdrawal_fee = withdrawal_fee;\n    stake_pool.stake_deposit_fee = deposit_fee;\n    stake_pool.stake_referral_fee = referral_fee;\n    stake_pool.max_validators = max_validators;\n    \n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nHIGH\nThe function accepts fee parameters without validation. Fees with numerator > denominator would exceed 100%, and referral_fee is not checked against maximum. max_validators has no upper bound, potentially causing storage issues.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_refund_all_bidders(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let auction_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut auction = Auction::unpack(&auction_info.data.borrow())?;\n    \n    if !auction.ended {\n        return Err(AuctionError::NotEnded.into());\n    }\n\n    for bidder in auction.bidders.iter() {\n        if *bidder != auction.winner {\n            refund_bidder(bidder, auction.bid_amounts.get(bidder).unwrap())?;\n        }\n    }\n\n    auction.refunds_completed = true;\n    Auction::pack(auction, &mut auction_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nCRITICAL\nMass refund pattern with unbounded iteration. If any single refund fails (malicious bidder contract, closed account), the entire transaction reverts and no one gets refunded. A single malicious participant can permanently block all refunds. Should use pull-payment pattern instead.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_create_escrow(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    escrow_bump: u8,\n    vault_bump: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let escrow_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let initializer = next_account_info(account_info_iter)?;\n\n    let escrow_pda = Pubkey::create_program_address(\n        &[b\"escrow\", initializer.key.as_ref(), &[escrow_bump]],\n        program_id,\n    )?;\n    \n    let vault_pda = Pubkey::create_program_address(\n        &[b\"vault\", escrow_info.key.as_ref(), &[vault_bump]],\n        program_id,\n    )?;\n\n    if *escrow_info.key != escrow_pda || *vault_info.key != vault_pda {\n        return Err(EscrowError::InvalidPDA.into());\n    }\n\n    let mut escrow = Escrow::unpack_unchecked(&escrow_info.data.borrow())?;\n    escrow.initializer = *initializer.key;\n    escrow.escrow_bump = escrow_bump;\n    escrow.vault_bump = vault_bump;\n    Escrow::pack(escrow, &mut escrow_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nHIGH\nTwo user-provided bumps are accepted for both escrow and vault PDAs. This doubles the attack surface - an attacker could create multiple escrow/vault combinations with non-canonical bumps, leading to state fragmentation and potential fund isolation attacks.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_emergency_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let destination = next_account_info(account_info_iter)?;\n    let admin = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    if !admin.is_signer || vault.admin != *admin.key {\n        return Err(VaultError::Unauthorized.into());\n    }\n\n    let user_balance = vault.get_user_balance(user_info.key)?;\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        vault_info.key,\n        destination.key,\n        vault_info.key,\n        &[],\n        user_balance,\n    )?;\n    \n    if invoke(&transfer_ix, &[vault_info.clone(), destination.clone()]).is_err() {\n        msg!(\"Transfer failed, continuing anyway\");\n    }\n\n    vault.set_user_balance(user_info.key, 0)?;\n    vault.emergency_withdrawn = true;\n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    \n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nCRITICAL\nThe code explicitly ignores transfer errors with 'if invoke().is_err()' and a log message. User balance is set to 0 regardless of transfer success. Users permanently lose access to their funds: balance shows 0 but tokens never arrived at destination. Emergency withdrawal becomes a fund destruction mechanism.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_swap(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount_in: u64,\n    minimum_out: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let pool_token_a = next_account_info(account_info_iter)?;\n    let pool_token_b = next_account_info(account_info_iter)?;\n    let user_token_a = next_account_info(account_info_iter)?;\n    let user_token_b = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = SwapPool::unpack(&pool_info.data.borrow())?;\n    \n    let amount_out = calculate_output(amount_in, pool.reserve_a, pool.reserve_b)?;\n    \n    if amount_out < minimum_out {\n        return Err(SwapError::SlippageExceeded.into());\n    }\n\n    let transfer_in = spl_token::instruction::transfer(\n        token_program.key,\n        user_token_a.key,\n        pool_token_a.key,\n        user_authority.key,\n        &[],\n        amount_in,\n    )?;\n    invoke(&transfer_in, &[user_token_a.clone(), pool_token_a.clone(), user_authority.clone()])?;\n\n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_out = spl_token::instruction::transfer(\n        token_program.key,\n        pool_token_b.key,\n        user_token_b.key,\n        pool_authority.key,\n        &[],\n        amount_out,\n    )?;\n    invoke_signed(&transfer_out, &[pool_token_b.clone(), user_token_b.clone(), pool_authority.clone()], signer)?;\n\n    pool.reserve_a = pool.reserve_a.checked_add(amount_in).ok_or(SwapError::MathOverflow)?;\n    pool.reserve_b = pool.reserve_b.checked_sub(amount_out).ok_or(SwapError::MathOverflow)?;\n    SwapPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nBoth transfer CPIs use ? for error propagation. If transfer_in fails, user keeps their tokens and pool is unchanged. If transfer_out fails after transfer_in, the entire transaction reverts, returning user's tokens. Pool reserves only update after both CPIs succeed atomically.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\npub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let expected_mint_info = if let Some(expected_decimals) = expected_decimals {\n        Some((next_account_info(account_info_iter)?, expected_decimals))\n    } else {\n        None\n    };\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    if source_account.is_frozen() || destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    if !Self::cmp_pubkeys(&source_account.mint, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    if let Some((mint_info, expected_decimals)) = expected_mint_info {\n        if !Self::cmp_pubkeys(mint_info.key, &source_account.mint) {\n            return Err(TokenError::MintMismatch.into());\n        }\n        let mint = Mint::unpack(&mint_info.data.borrow_mut())?;\n        if expected_decimals != mint.decimals {\n            return Err(TokenError::MintDecimalsMismatch.into());\n        }\n    }\n\n    let self_transfer = Self::cmp_pubkeys(source_account_info.key, destination_account_info.key);\n    if self_transfer || amount == 0 {\n        Self::check_account_owner(program_id, source_account_info)?;\n        Self::check_account_owner(program_id, destination_account_info)?;\n    }\n    if self_transfer {\n        return Ok(());\n    }\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function validates: frozen account status, sufficient balance, mint consistency between accounts, optional decimals matching, self-transfer handling, and uses checked arithmetic. Zero-amount transfers are permitted but validated for account ownership.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\n#[derive(Accounts)]\npub struct InitializeVault<'info> {\n    #[account(\n        init,\n        payer = owner,\n        space = 8 + Vault::LEN,\n        seeds = [b\"vault\", owner.key().as_ref()],\n        bump,\n    )]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\npub fn initialize_vault(ctx: Context<InitializeVault>) -> Result<()> {\n    let vault = &mut ctx.accounts.vault;\n    vault.owner = ctx.accounts.owner.key();\n    vault.bump = ctx.bumps.vault;\n    vault.balance = 0;\n    Ok(())\n}\n\n#[derive(Accounts)]\npub struct Deposit<'info> {\n    #[account(\n        mut,\n        seeds = [b\"vault\", owner.key().as_ref()],\n        bump = vault.bump,\n        has_one = owner,\n    )]\n    pub vault: Account<'info, Vault>,\n    #[account(mut)]\n    pub owner: Signer<'info>,\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nAnchor's seeds constraint with 'bump' (no value) automatically uses find_program_address() to derive the canonical bump. ctx.bumps.vault provides the canonical bump for storage. Subsequent access uses 'bump = vault.bump' to verify against stored canonical value.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_set_staker(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let set_staker_authority_info = next_account_info(account_info_iter)?;\n    let new_staker_info = next_account_info(account_info_iter)?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    let staker_signed = stake_pool.check_staker(set_staker_authority_info);\n    let manager_signed = stake_pool.check_manager(set_staker_authority_info);\n    if staker_signed.is_err() && manager_signed.is_err() {\n        return Err(StakePoolError::SignatureMissing.into());\n    }\n    stake_pool.staker = *new_staker_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe function implements dual-authority access control where either the current staker OR the manager can authorize staker changes. This provides operational flexibility while maintaining security through proper authorization checks.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    let user_balance = vault.get_user_balance(user_info.key)?;\n    \n    if user_balance < amount {\n        return Err(VaultError::InsufficientBalance.into());\n    }\n    \n    let new_balance = user_balance - amount;\n    vault.set_user_balance(user_info.key, new_balance)?;\n    \n    vault.total_deposited -= amount;\n    \n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Underflow\nHIGH\nWhile user_balance is checked before subtraction, total_deposited uses unchecked subtraction with -=. If total_deposited is somehow less than amount (due to rounding, fees, or state corruption), this will underflow and wrap to a large value, corrupting the vault's accounting.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_redeem_nft(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let nft_mint = next_account_info(account_info_iter)?;\n    let nft_token_account = next_account_info(account_info_iter)?;\n    let pool_token_vault = next_account_info(account_info_iter)?;\n    let user_token_account = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = NFTPool::unpack(&pool_info.data.borrow())?;\n    \n    let nft_account = Account::unpack(&nft_token_account.data.borrow())?;\n    if nft_account.amount != 1 || nft_account.owner != *user_authority.key {\n        return Err(NFTError::InvalidNFTOwnership.into());\n    }\n\n    let redemption_value = pool.floor_price;\n\n    let burn_ix = spl_token::instruction::burn(\n        token_program.key,\n        nft_token_account.key,\n        nft_mint.key,\n        user_authority.key,\n        &[],\n        1,\n    )?;\n    invoke(&burn_ix, &[nft_token_account.clone(), nft_mint.clone(), user_authority.clone()])?;\n\n    pool.total_redeemed = pool.total_redeemed.checked_add(1)?;\n    pool.total_value_redeemed = pool.total_value_redeemed.checked_add(redemption_value)?;\n    NFTPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n\n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_token_vault.key,\n        user_token_account.key,\n        pool_authority.key,\n        &[],\n        redemption_value,\n    )?;\n    invoke_signed(&transfer_ix, &[pool_token_vault.clone(), user_token_account.clone(), pool_authority.clone()], signer)?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nThe NFT is burned FIRST before any value transfer. This destroys the redemption authorization immediately. Any reentrancy attempt during the subsequent transfer will fail the ownership check (nft_account.amount != 1) because the NFT no longer exists.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_claim_auction_refund(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let auction_info = next_account_info(account_info_iter)?;\n    let bidder_info = next_account_info(account_info_iter)?;\n    let bidder_token_info = next_account_info(account_info_iter)?;\n    let escrow_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let auction = Auction::unpack(&auction_info.data.borrow())?;\n    \n    if !auction.ended {\n        return Err(AuctionError::NotEnded.into());\n    }\n    if *bidder_info.key == auction.winner {\n        return Err(AuctionError::WinnerCannotRefund.into());\n    }\n\n    let bid_amount = auction.get_bid(bidder_info.key)\n        .ok_or(AuctionError::NoBidFound)?;\n    \n    if auction.refunded.contains(bidder_info.key) {\n        return Err(AuctionError::AlreadyRefunded.into());\n    }\n\n    transfer_from_escrow(escrow_info, bidder_token_info, bid_amount, token_program)?;\n    \n    mark_refunded(auction_info, bidder_info.key)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nPull-payment refund pattern: each bidder claims their own refund. One malicious bidder cannot block others. Duplicate refund prevention via refunded set. Auction can end regardless of individual refund status. All operations are O(1) per user.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_initialize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    epoch_fee: Fee,\n    withdrawal_fee: Fee,\n    deposit_fee: Fee,\n    referral_fee: u8,\n    max_validators: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let rent = Rent::get()?;\n    \n    if epoch_fee.numerator > epoch_fee.denominator\n        || withdrawal_fee.numerator > withdrawal_fee.denominator\n        || deposit_fee.numerator > deposit_fee.denominator\n        || referral_fee > 100u8\n    {\n        return Err(StakePoolError::FeeTooHigh.into());\n    }\n    \n    let expected_max_validators = ValidatorList::calculate_max_validators(validator_list_info.data_len());\n    if expected_max_validators != max_validators as usize || max_validators == 0 {\n        return Err(StakePoolError::UnexpectedValidatorListAccountSize.into());\n    }\n    if max_validators > MAX_VALIDATORS_IN_POOL {\n        return Err(StakePoolError::TooManyValidatorsInPool.into());\n    }\n    \n    if !rent.is_exempt(stake_pool_info.lamports(), stake_pool_info.data_len()) {\n        return Err(ProgramError::AccountNotRentExempt);\n    }\n    \n    let pool_mint_data = pool_mint_info.try_borrow_data()?;\n    let pool_mint = StateWithExtensions::<Mint>::unpack(&pool_mint_data)?;\n    if pool_mint.base.supply != 0 {\n        return Err(StakePoolError::NonZeroPoolTokenSupply.into());\n    }\n    if pool_mint.base.decimals != native_mint::DECIMALS {\n        return Err(StakePoolError::IncorrectMintDecimals.into());\n    }\n    \n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function implements comprehensive input validation: fees are checked against 100% cap, referral_fee <= 100, max_validators is bounded and validated against storage, rent-exemption is verified, and mint state is validated for zero supply and correct decimals.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn calculate_rewards(\n    staked_amount: u64,\n    reward_rate: u64,\n    time_elapsed: u64,\n) -> Result<u64, ProgramError> {\n    let rewards = staked_amount * reward_rate * time_elapsed / SECONDS_PER_YEAR;\n    Ok(rewards)\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nCRITICAL\nThe multiplication chain (staked_amount * reward_rate * time_elapsed) can easily overflow u64. For example: 1_000_000_000_000 * 1000 * 31536000 far exceeds u64::MAX. The result wraps to a small or zero value, causing users to receive incorrect (likely zero) rewards.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub struct InitArgs {\n    pub mint_end_slot: Slot,\n    pub decide_end_slot: Slot,\n    pub bump_seed: u8,\n}\n\npub fn process_init(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    args: InitArgs,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let authority = Pubkey::create_program_address(\n        &[&pool_info.key.to_bytes()[..32], &[args.bump_seed]],\n        program_id,\n    ).map_err(|_| PoolError::InvalidAuthorityData)?;\n\n    if *authority_info.key != authority {\n        return Err(PoolError::InvalidAuthorityAccount.into());\n    }\n\n    let mut pool = Pool::try_from_slice(&pool_info.data.borrow())?;\n    pool.bump_seed = args.bump_seed;\n    pool.mint_end_slot = args.mint_end_slot;\n    pool.decide_end_slot = args.decide_end_slot;\n    \n    borsh::to_writer(&mut pool_info.data.borrow_mut()[..], &pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nHIGH\nThe InitArgs struct accepts bump_seed from instruction data (user-controlled). This pattern from binary-oracle-pair stores whatever bump the user provides without verifying it's canonical. Should derive bump using find_program_address() during initialization.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_stake_with_authority(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    authority_bump: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n\n    let pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    \n    let seeds = &[\n        AUTHORITY_WITHDRAW,\n        stake_pool_info.key.as_ref(),\n        &[authority_bump],\n    ];\n    \n    let expected = Pubkey::create_program_address(seeds, program_id)?;\n    if *authority_info.key != expected {\n        return Err(StakePoolError::InvalidAuthority.into());\n    }\n    \n    if authority_bump != pool.stake_withdraw_bump_seed {\n        return Err(StakePoolError::InvalidBump.into());\n    }\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nMEDIUM\nAlthough there's a check against stored bump (authority_bump != pool.stake_withdraw_bump_seed), the original stake_withdraw_bump_seed may not be canonical. Additionally, accepting bump as instruction parameter creates unnecessary attack surface. The stored bump should be used directly without user input.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\n#[derive(Accounts)]\npub struct ClaimRewards<'info> {\n    #[account(\n        seeds = [b\"pool\", pool.authority.as_ref()],\n        bump = pool.bump,\n    )]\n    pub pool: Account<'info, StakingPool>,\n    #[account(\n        mut,\n        seeds = [b\"user_stake\", pool.key().as_ref(), user.key().as_ref()],\n        bump = user_stake.bump,\n    )]\n    pub user_stake: Account<'info, UserStake>,\n    #[account(\n        mut,\n        seeds = [b\"reward_vault\", pool.key().as_ref()],\n        bump = pool.reward_vault_bump,\n    )]\n    pub reward_vault: Account<'info, TokenAccount>,\n    pub user: Signer<'info>,\n    pub token_program: Program<'info, Token>,\n}\n\npub fn claim_rewards(ctx: Context<ClaimRewards>) -> Result<()> {\n    let user_stake = &mut ctx.accounts.user_stake;\n    let pool = &ctx.accounts.pool;\n    \n    let pending = calculate_rewards(user_stake, pool)?;\n    user_stake.last_claim = Clock::get()?.unix_timestamp;\n    \n    let seeds = &[\n        b\"reward_vault\",\n        pool.key().as_ref(),\n        &[pool.reward_vault_bump],\n    ];\n    \n    token::transfer(\n        CpiContext::new_with_signer(\n            ctx.accounts.token_program.to_account_info(),\n            Transfer {\n                from: ctx.accounts.reward_vault.to_account_info(),\n                to: ctx.accounts.user.to_account_info(),\n                authority: ctx.accounts.reward_vault.to_account_info(),\n            },\n            &[seeds],\n        ),\n        pending,\n    )?;\n    \n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nAll PDAs use Anchor's seeds constraint with stored bumps (pool.bump, user_stake.bump, pool.reward_vault_bump). These bumps were canonically derived during initialization via ctx.bumps. The seeds constraints verify addresses match expected PDAs with stored canonical bumps.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_execute_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    proposal_id: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n    let treasury_info = next_account_info(account_info_iter)?;\n    let recipient_info = next_account_info(account_info_iter)?;\n    let governance_authority = next_account_info(account_info_iter)?;\n\n    let governance = Governance::unpack(&governance_info.data.borrow())?;\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    \n    if proposal.status != ProposalStatus::Approved {\n        return Err(GovernanceError::ProposalNotApproved.into());\n    }\n    if proposal.executed {\n        return Err(GovernanceError::AlreadyExecuted.into());\n    }\n\n    proposal.executed = true;\n    proposal.execution_timestamp = Clock::get()?.unix_timestamp;\n    proposal.executor = Some(*governance_authority.key);\n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n\n    let seeds = &[b\"governance\", governance_info.key.as_ref(), &[governance.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = system_instruction::transfer(\n        treasury_info.key,\n        recipient_info.key,\n        proposal.amount,\n    );\n    invoke_signed(&transfer_ix, &[treasury_info.clone(), recipient_info.clone(), governance_authority.clone()], signer)?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nThe executed flag is set to true BEFORE the treasury transfer CPI. Any reentrancy attempt during the transfer callback will fail the 'if proposal.executed' check immediately, preventing double execution of the same proposal.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_withdraw_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n    minimum_lamports_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let pool_tokens_fee = stake_pool\n        .calc_pool_tokens_sol_withdrawal_fee(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n    let pool_tokens_burnt = pool_tokens\n        .checked_sub(pool_tokens_fee)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let withdraw_lamports = stake_pool\n        .calc_lamports_withdraw_amount(pool_tokens_burnt)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if withdraw_lamports == 0 {\n        return Err(StakePoolError::WithdrawalTooSmall.into());\n    }\n\n    if let Some(minimum_lamports_out) = minimum_lamports_out {\n        if withdraw_lamports < minimum_lamports_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    let new_reserve_lamports = reserve_stake_info.lamports().saturating_sub(withdraw_lamports);\n    let stake_state = try_from_slice_unchecked::<stake::state::StakeStateV2>(&reserve_stake_info.data.borrow())?;\n    if let stake::state::StakeStateV2::Initialized(meta) = stake_state {\n        let minimum_reserve_lamports = minimum_reserve_lamports(&meta);\n        if new_reserve_lamports < minimum_reserve_lamports {\n            return Err(StakePoolError::SolWithdrawalTooLarge.into());\n        }\n    }\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function implements thorough validation: epoch freshness, minimum withdrawal check, slippage protection, and critically validates that withdrawal won't drain reserve below minimum rent-exempt threshold (SolWithdrawalTooLarge check).<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_update_all_positions(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let market_info = next_account_info(account_info_iter)?;\n    let oracle_info = next_account_info(account_info_iter)?;\n\n    let mut market = Market::unpack(&market_info.data.borrow())?;\n    let oracle_price = get_oracle_price(oracle_info)?;\n\n    for position in market.positions.iter_mut() {\n        position.unrealized_pnl = calculate_pnl(position, oracle_price)?;\n        position.margin_ratio = calculate_margin(position, oracle_price)?;\n        position.last_update = Clock::get()?.unix_timestamp;\n    }\n\n    Market::pack(market, &mut market_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nHIGH\nMass position update without pagination. As positions grow, this function becomes uncallable. Market state (PnL, margins) becomes stale because updates fail. Could lead to incorrect liquidations or allow underwater positions to persist.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_execute_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_index: u16,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n\n    if proposal.state != ProposalState::Succeeded {\n        return Err(GovernanceError::InvalidState.into());\n    }\n    \n    let instruction = proposal.instructions\n        .get(instruction_index as usize)\n        .ok_or(GovernanceError::InvalidInstructionIndex)?;\n    \n    if proposal.executed_instructions.contains(&instruction_index) {\n        return Err(GovernanceError::InstructionAlreadyExecuted.into());\n    }\n\n    let ix = Instruction {\n        program_id: instruction.program_id,\n        accounts: instruction.accounts.clone(),\n        data: instruction.data.clone(),\n    };\n    invoke(&ix, accounts)?;\n\n    proposal.executed_instructions.push(instruction_index);\n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nPer-instruction execution: proposals execute one instruction at a time via instruction_index. Large proposals with many instructions can execute across multiple transactions. Double-execution prevention via executed_instructions tracking. Governance remains operational regardless of proposal complexity.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_withdraw_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n    minimum_lamports_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let destination_lamports_info = next_account_info(account_info_iter)?;\n    let manager_fee_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let burn_from_pool_info = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    stake_pool.check_authority_withdraw(withdraw_authority_info.key, program_id, stake_pool_info.key)?;\n    stake_pool.check_reserve_stake(reserve_stake_info)?;\n    stake_pool.check_mint(pool_mint_info)?;\n\n    if stake_pool.manager_fee_account != *manager_fee_info.key {\n        return Err(StakePoolError::InvalidFeeAccount.into());\n    }\n\n    let withdraw_lamports = stake_pool.calc_lamports_withdraw_amount(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if withdraw_lamports == 0 {\n        return Err(StakePoolError::WithdrawalTooSmall.into());\n    }\n\n    if let Some(minimum_lamports_out) = minimum_lamports_out {\n        if withdraw_lamports < minimum_lamports_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    Self::token_burn(token_program_info.clone(), burn_from_pool_info.clone(), pool_mint_info.clone(), user_transfer_authority_info.clone(), pool_tokens)?;\n    Self::stake_withdraw(stake_pool_info.key, reserve_stake_info.clone(), withdraw_authority_info.clone(), AUTHORITY_WITHDRAW, stake_pool.stake_withdraw_bump_seed, destination_lamports_info.clone(), withdraw_lamports)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe withdrawal function implements comprehensive validation: account ownership, withdraw authority verification, reserve stake validation, fee account validation, and slippage protection. All critical accounts are properly verified before any state changes.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_claim_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n    let reward_vault = next_account_info(account_info_iter)?;\n    let user_reward_account = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let pool = StakingPool::unpack(&pool_info.data.borrow())?;\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    let pending_rewards = calculate_rewards(&pool, &user_stake, clock.unix_timestamp)?;\n    \n    if pending_rewards == 0 {\n        return Err(StakingError::NoRewardsToClaim.into());\n    }\n\n    user_stake.reward_debt = user_stake.reward_debt.checked_add(pending_rewards)?;\n    user_stake.last_claim_time = clock.unix_timestamp;\n    user_stake.total_claimed = user_stake.total_claimed.checked_add(pending_rewards)?;\n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n\n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        reward_vault.key,\n        user_reward_account.key,\n        pool_authority.key,\n        &[],\n        pending_rewards,\n    )?;\n    invoke_signed(&transfer_ix, &[reward_vault.clone(), user_reward_account.clone(), pool_authority.clone()], signer)?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nCorrect CEI pattern: reward_debt, last_claim_time, and total_claimed are all updated BEFORE the transfer CPI. If an attacker triggers a callback during the transfer, calculate_rewards() will return 0 (or a much smaller value) because reward_debt has already been incremented.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_liquidate_and_seize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    repay_amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let obligation_info = next_account_info(account_info_iter)?;\n    let repay_reserve = next_account_info(account_info_iter)?;\n    let collateral_reserve = next_account_info(account_info_iter)?;\n    let liquidator_repay = next_account_info(account_info_iter)?;\n    let liquidator_receive = next_account_info(account_info_iter)?;\n    let lending_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut obligation = Obligation::unpack(&obligation_info.data.borrow())?;\n    \n    let health = calculate_health_factor(&obligation)?;\n    if health >= LIQUIDATION_THRESHOLD {\n        return Err(LendingError::HealthyPosition.into());\n    }\n\n    let collateral_to_seize = calculate_liquidation_amount(repay_amount)?;\n\n    let repay_ix = spl_token::instruction::transfer(\n        token_program.key,\n        liquidator_repay.key,\n        repay_reserve.key,\n        liquidator_repay.key,\n        &[],\n        repay_amount,\n    )?;\n    invoke(&repay_ix, &[liquidator_repay.clone(), repay_reserve.clone()])?;\n\n    let seeds = &[b\"lending_authority\", &[authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let seize_ix = spl_token::instruction::transfer(\n        token_program.key,\n        collateral_reserve.key,\n        liquidator_receive.key,\n        lending_authority.key,\n        &[],\n        collateral_to_seize,\n    )?;\n    invoke_signed(&seize_ix, &[collateral_reserve.clone(), liquidator_receive.clone(), lending_authority.clone()], signer)?;\n\n    obligation.borrowed_amount = obligation.borrowed_amount\n        .checked_sub(repay_amount)\n        .ok_or(LendingError::MathOverflow)?;\n    obligation.collateral_amount = obligation.collateral_amount\n        .checked_sub(collateral_to_seize)\n        .ok_or(LendingError::MathOverflow)?;\n    \n    Obligation::pack(obligation, &mut obligation_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nBoth repay invoke() and seize invoke_signed() use ? for error propagation. The liquidation is atomic: if repay fails, seize never happens; if seize fails after repay, the entire transaction reverts. Obligation state only updates after both CPIs succeed, maintaining protocol integrity.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_emergency_withdraw_all(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let admin_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    if !admin_info.is_signer || vault.admin != *admin_info.key {\n        return Err(VaultError::Unauthorized.into());\n    }\n\n    for user in vault.users.iter() {\n        let user_balance = vault.get_balance(&user.pubkey)?;\n        \n        transfer_tokens(\n            token_program,\n            vault_info,\n            &user.token_account,\n            user_balance,\n        )?;\n    }\n\n    vault.is_emergency = true;\n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nCRITICAL\nEmergency withdrawal iterates all users with CPI transfers. If vault has many users, emergency withdrawal fails. During actual emergency (hack, exploit), admin cannot rescue funds. Should allow individual emergency claims instead.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn calculate_pool_tokens(\n    deposit_lamports: u64,\n    total_lamports: u64,\n    pool_token_supply: u64,\n) -> Result<u64, ProgramError> {\n    if total_lamports == 0 || pool_token_supply == 0 {\n        return Ok(deposit_lamports);\n    }\n    \n    let pool_tokens = deposit_lamports * pool_token_supply / total_lamports;\n    Ok(pool_tokens)\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nHIGH\nThe multiplication deposit_lamports * pool_token_supply can overflow before division. For a large stake pool with billions of lamports and tokens, this multiplication exceeds u64::MAX, wrapping to an incorrect small value and minting wrong token amounts to depositors.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_flash_loan(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    loan_amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let pool_vault_info = next_account_info(account_info_iter)?;\n    let borrower_token_info = next_account_info(account_info_iter)?;\n    let borrower_program_info = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = FlashLoanPool::unpack(&pool_info.data.borrow())?;\n    \n    let fee = loan_amount.checked_mul(pool.fee_bps as u64)\n        .ok_or(FlashError::MathOverflow)?\n        .checked_div(10000)\n        .ok_or(FlashError::MathOverflow)?;\n    \n    let vault_balance_before = get_token_balance(pool_vault_info)?;\n    \n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let loan_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_vault_info.key,\n        borrower_token_info.key,\n        pool_authority.key,\n        &[],\n        loan_amount,\n    )?;\n    invoke_signed(&loan_ix, &[pool_vault_info.clone(), borrower_token_info.clone(), pool_authority.clone()], signer)?;\n\n    let callback_ix = Instruction {\n        program_id: *borrower_program_info.key,\n        accounts: vec![],\n        data: vec![],\n    };\n    invoke(&callback_ix, &[borrower_program_info.clone()])?;\n\n    let vault_balance_after = get_token_balance(pool_vault_info)?;\n    let expected_balance = vault_balance_before.checked_add(fee)\n        .ok_or(FlashError::MathOverflow)?;\n    \n    if vault_balance_after < expected_balance {\n        return Err(FlashError::InsufficientRepayment.into());\n    }\n\n    pool.total_loans = pool.total_loans.checked_add(1).ok_or(FlashError::MathOverflow)?;\n    pool.total_fees_collected = pool.total_fees_collected.checked_add(fee)\n        .ok_or(FlashError::MathOverflow)?;\n    \n    FlashLoanPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nCRITICAL\nThe flash loan CPI sends funds to borrower, then invokes borrower's callback. The borrower can call flash_loan() recursively before repaying. Each nested call captures vault_balance_before after previous loans depleted the vault. Final repayment check only validates the outermost call, enabling theft of pool funds.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_execute_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let proposal_info = next_account_info(account_info_iter)?;\n    let executor_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    \n    if proposal.status != ProposalStatus::Approved {\n        return Err(GovernanceError::NotApproved.into());\n    }\n\n    for instruction in proposal.instructions.iter() {\n        let ix = solana_program::instruction::Instruction {\n            program_id: instruction.program_id,\n            accounts: instruction.accounts.clone(),\n            data: instruction.data.clone(),\n        };\n        \n        invoke(&ix, accounts);\n    }\n    \n    proposal.status = ProposalStatus::Executed;\n    proposal.executed_at = Some(Clock::get()?.unix_timestamp);\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nCRITICAL\nThe invoke() call inside the loop lacks error propagation. If any proposal instruction fails, execution continues and proposal.status is set to Executed anyway. This creates a critical inconsistency: governance records show successful execution while actual on-chain actions failed partially or completely.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_distribute_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    reward_amounts: Vec<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let reward_vault = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let recipients: Vec<&AccountInfo> = account_info_iter.collect();\n    \n    if recipients.len() != reward_amounts.len() {\n        return Err(ProgramError::InvalidArgument);\n    }\n\n    let mut total_distributed: u64 = 0;\n    \n    for (i, recipient) in recipients.iter().enumerate() {\n        let transfer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            reward_vault.key,\n            recipient.key,\n            authority_info.key,\n            &[],\n            reward_amounts[i],\n        )?;\n        \n        let _ = invoke(&transfer_ix, &[\n            reward_vault.clone(),\n            (*recipient).clone(),\n            authority_info.clone(),\n        ]);\n        \n        total_distributed += reward_amounts[i];\n    }\n\n    msg!(\"Total distributed: {}\", total_distributed);\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nCRITICAL\nThe invoke() result is explicitly discarded with 'let _ = invoke(...)'. Failed transfers are completely ignored, but total_distributed still counts them. Users may believe they received rewards while transfers actually failed. This enables silent fund loss and accounting discrepancies.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n\n    let mut pool = StakingPool::unpack(&pool_info.data.borrow())?;\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    pool.total_staked += amount;\n    user_stake.staked_amount += amount;\n    user_stake.reward_debt = user_stake.staked_amount * pool.acc_reward_per_share / PRECISION;\n    \n    StakingPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nHIGH\nThree overflow risks: (1) pool.total_staked += amount can overflow with many stakers. (2) user_stake.staked_amount += amount can overflow. (3) The reward_debt calculation multiplies staked_amount by acc_reward_per_share, which can overflow even before division. All use unchecked arithmetic.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\nfn token_mint_to<'a>(\n    stake_pool: &Pubkey,\n    token_program: AccountInfo<'a>,\n    mint: AccountInfo<'a>,\n    destination: AccountInfo<'a>,\n    authority: AccountInfo<'a>,\n    authority_type: &[u8],\n    bump_seed: u8,\n    amount: u64,\n) -> Result<(), ProgramError> {\n    let authority_signature_seeds = [stake_pool.as_ref(), authority_type, &[bump_seed]];\n    let signers = &[&authority_signature_seeds[..]];\n\n    let ix = spl_token::instruction::mint_to(\n        token_program.key,\n        mint.key,\n        destination.key,\n        authority.key,\n        &[],\n        amount,\n    )?;\n\n    invoke_signed(&ix, &[mint, destination, authority], signers)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nThe invoke_signed() call properly uses the ? operator for error propagation. Any mint failure (supply overflow, frozen mint, wrong authority) will immediately return an error to the caller. The explicit Ok(()) at the end only executes if the CPI succeeded.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n\n    \n    validator_list.push(ValidatorStakeInfo {\n        status: StakeStatus::Active.into(),\n        vote_account_address: *validator_vote_info.key,\n        active_stake_lamports: 0.into(),\n        transient_stake_lamports: 0.into(),\n        last_update_epoch: 0.into(),\n        transient_seed_suffix: 0.into(),\n        unused: 0.into(),\n        validator_seed_suffix: raw_validator_seed.into(),\n    })?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nHIGH\nThe add_validator function lacks input validation: no check if validator list is at capacity, no duplicate validator check (same validator could be added multiple times), and vote account is not validated as a legitimate vote account.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_create_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_owner_record_info = next_account_info(account_info_iter)?;\n\n    let mut governance_data = Governance::unpack(&governance_info.data.borrow())?;\n    let mut proposal_owner_record = TokenOwnerRecord::unpack(&proposal_owner_record_info.data.borrow())?;\n    \n    proposal_owner_record.outstanding_proposal_count = proposal_owner_record\n        .outstanding_proposal_count\n        .checked_add(1)\n        .unwrap();\n    governance_data.active_proposal_count = governance_data\n        .active_proposal_count\n        .checked_add(1)\n        .unwrap();\n    \n    TokenOwnerRecord::pack(proposal_owner_record, &mut proposal_owner_record_info.data.borrow_mut())?;\n    Governance::pack(governance_data, &mut governance_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow - MITIGATED\nBoth counter increments use checked_add(1).unwrap(). This pattern from SPL Governance ensures overflow detection. The unwrap() is acceptable here because counter overflow is practically impossible (would require 2^64 proposals), and if it did occur, panic is the correct behavior.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\nfn check_transient_stake_address(\n    program_id: &Pubkey,\n    stake_pool_address: &Pubkey,\n    stake_account_address: &Pubkey,\n    vote_address: &Pubkey,\n    seed: u64,\n) -> Result<u8, ProgramError> {\n    let (transient_stake_address, bump_seed) = find_transient_stake_program_address(\n        program_id,\n        vote_address,\n        stake_pool_address,\n        seed,\n    );\n    if transient_stake_address != *stake_account_address {\n        Err(StakePoolError::InvalidStakeAccountAddress.into())\n    } else {\n        Ok(bump_seed)\n    }\n}\n\npub fn process_decrease_validator_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    lamports: u64,\n    transient_stake_seed: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let transient_stake_info = next_account_info(account_info_iter)?;\n    let vote_account_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    \n    let transient_stake_bump = check_transient_stake_address(\n        program_id,\n        stake_pool_info.key,\n        transient_stake_info.key,\n        vote_account_info.key,\n        transient_stake_seed,\n    )?;\n\n    let transient_stake_seeds = &[\n        TRANSIENT_STAKE_SEED_PREFIX,\n        vote_account_info.key.as_ref(),\n        stake_pool_info.key.as_ref(),\n        &transient_stake_seed.to_le_bytes(),\n        &[transient_stake_bump],\n    ];\n\n    create_stake_account(\n        transient_stake_info.clone(),\n        transient_stake_seeds,\n        STAKE_STATE_LEN,\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nThe bump is derived using find_transient_stake_program_address() which internally uses find_program_address(), returning the canonical (highest valid) bump. The address is then validated before the bump is used for signing. This pattern from SPL Stake Pool ensures only canonical PDAs are used.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_unstake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let staking_pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n    let pool_token_vault = next_account_info(account_info_iter)?;\n    let user_token_account = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let pool = StakingPool::unpack(&staking_pool_info.data.borrow())?;\n    let user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    if user_stake.staked_amount < amount {\n        return Err(StakingError::InsufficientStake.into());\n    }\n\n    let seeds = &[b\"pool_authority\", staking_pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_token_vault.key,\n        user_token_account.key,\n        pool_authority.key,\n        &[],\n        amount,\n    )?;\n    invoke_signed(&transfer_ix, &[pool_token_vault.clone(), user_token_account.clone(), pool_authority.clone()], signer)?;\n\n    let mut user_stake_mut = UserStake::unpack(&user_stake_info.data.borrow())?;\n    user_stake_mut.staked_amount = user_stake_mut.staked_amount.checked_sub(amount)\n        .ok_or(StakingError::MathOverflow)?;\n    user_stake_mut.last_unstake_timestamp = Clock::get()?.unix_timestamp;\n    \n    UserStake::pack(user_stake_mut, &mut user_stake_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nCRITICAL\nThe unstake transfer CPI executes before updating staked_amount. During the callback, the attacker can recursively call unstake() with the same amount. Since the original staked_amount hasn't been decremented, each call passes the balance check, completely draining the pool_token_vault.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_set_manager(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let new_manager_info = next_account_info(account_info_iter)?;\n    let new_manager_fee_info = next_account_info(account_info_iter)?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    check_account_owner(new_manager_fee_info, &stake_pool.token_program_id)?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    stake_pool.check_manager(manager_info)?;\n    if !new_manager_info.is_signer {\n        msg!(\"New manager signature missing\");\n        return Err(StakePoolError::SignatureMissing.into());\n    }\n\n    stake_pool.check_manager_fee_info(new_manager_fee_info)?;\n\n    stake_pool.manager = *new_manager_info.key;\n    stake_pool.manager_fee_account = *new_manager_fee_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe function implements comprehensive access control: (1) verifies account ownership, (2) validates current manager authorization, (3) requires new manager signature, and (4) validates fee account. Two-party authorization prevents unauthorized manager transfers.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn _process_initialize_multisig(\n    accounts: &[AccountInfo],\n    m: u8,\n    rent_sysvar_account: bool,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let multisig_info = next_account_info(account_info_iter)?;\n    let multisig_info_data_len = multisig_info.data_len();\n    let rent = if rent_sysvar_account {\n        Rent::from_account_info(next_account_info(account_info_iter)?)?\n    } else {\n        Rent::get()?\n    };\n\n    let mut multisig = Multisig::unpack_unchecked(&multisig_info.data.borrow())?;\n    if multisig.is_initialized {\n        return Err(TokenError::AlreadyInUse.into());\n    }\n\n    if !rent.is_exempt(multisig_info.lamports(), multisig_info_data_len) {\n        return Err(TokenError::NotRentExempt.into());\n    }\n\n    let signer_infos = account_info_iter.as_slice();\n    multisig.m = m;\n    multisig.n = signer_infos.len() as u8;\n    \n    if !is_valid_signer_index(multisig.n as usize) {\n        return Err(TokenError::InvalidNumberOfProvidedSigners.into());\n    }\n    if !is_valid_signer_index(multisig.m as usize) {\n        return Err(TokenError::InvalidNumberOfRequiredSigners.into());\n    }\n    \n    for (i, signer_info) in signer_infos.iter().enumerate() {\n        multisig.signers[i] = *signer_info.key;\n    }\n    multisig.is_initialized = true;\n\n    Multisig::pack(multisig, &mut multisig_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function validates: re-initialization prevention, rent-exemption, signer count via is_valid_signer_index (ensures n within bounds), required signers validation (ensures m is valid), and implicitly m <= n through the validation logic.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\nconst MAX_INSTRUCTIONS: usize = 10;\n\npub fn create_proposal(\n    ctx: Context<CreateProposal>,\n    instructions: Vec<ProposalInstruction>,\n) -> Result<()> {\n    let proposal = &mut ctx.accounts.proposal;\n    let governance = &ctx.accounts.governance;\n\n    require!(\n        instructions.len() <= MAX_INSTRUCTIONS,\n        GovernanceError::TooManyInstructions\n    );\n\n    require!(\n        instructions.len() > 0,\n        GovernanceError::NoInstructions\n    );\n\n    proposal.governance = governance.key();\n    proposal.proposer = ctx.accounts.proposer.key();\n    proposal.instructions = instructions;\n    proposal.state = ProposalState::Draft;\n    proposal.executed_count = 0;\n    proposal.created_at = Clock::get()?.unix_timestamp;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nMAX_INSTRUCTIONS constant limits proposal complexity at creation time. Prevents proposals with hundreds of instructions that would exceed compute budget during execution. Combined with per-instruction execution pattern, governance remains operational for any proposal size up to the limit.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_stake_delegate<'a>(\n    stake_info: AccountInfo<'a>,\n    vote_account_info: AccountInfo<'a>,\n    clock_info: AccountInfo<'a>,\n    stake_history_info: AccountInfo<'a>,\n    stake_config_info: AccountInfo<'a>,\n    authority_info: AccountInfo<'a>,\n    stake_pool: &Pubkey,\n    authority_type: &[u8],\n    bump_seed: u8,\n) -> Result<(), ProgramError> {\n    let authority_signature_seeds = [stake_pool.as_ref(), authority_type, &[bump_seed]];\n    let signers = &[&authority_signature_seeds[..]];\n\n    let ix = stake::instruction::delegate_stake(\n        stake_info.key,\n        authority_info.key,\n        vote_account_info.key,\n    );\n\n    invoke_signed(\n        &ix,\n        &[\n            stake_info,\n            vote_account_info,\n            clock_info,\n            stake_history_info,\n            stake_config_info,\n            authority_info,\n        ],\n        signers,\n    )\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nMEDIUM\nThe invoke_signed() result is returned without explicit error propagation. If delegation fails (invalid vote account, stake not initialized, wrong authority), the error may be silently ignored depending on how this helper function is called. Stake pool accounting could become inconsistent with actual stake delegation state.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\npub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    \n    Self::validate_owner(program_id, &source_account.owner, authority_info, account_info_iter.as_slice())?;\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nMEDIUM\nThe transfer function does not validate that amount is greater than zero. Zero-value transfers waste compute resources and could be used to spam the network. While checked arithmetic prevents overflow, the lack of minimum validation enables DoS attacks.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_close_and_refund(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let account_to_close = next_account_info(account_info_iter)?;\n    let destination = next_account_info(account_info_iter)?;\n    let owner = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let account_data = Account::unpack(&account_to_close.data.borrow())?;\n    \n    if account_data.amount > 0 {\n        let transfer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            account_to_close.key,\n            destination.key,\n            owner.key,\n            &[],\n            account_data.amount,\n        )?;\n        invoke(&transfer_ix, &[account_to_close.clone(), destination.clone(), owner.clone()])?;\n    }\n\n    let close_ix = spl_token::instruction::close_account(\n        token_program.key,\n        account_to_close.key,\n        destination.key,\n        owner.key,\n        &[],\n    )?;\n    invoke(&close_ix, &[account_to_close.clone(), destination.clone(), owner.clone()])?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nBoth the transfer invoke() and close_account invoke() use ? for error propagation. If the transfer fails, the account is NOT closed, preserving user funds. The account only closes after successful transfer (or if balance was already 0). No risk of fund loss from unchecked errors.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_set_authority(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    authority_type: AuthorityType,\n    new_authority: COption<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    if account_info.data_len() == Mint::get_packed_len() {\n        let mut mint = Mint::unpack(&account_info.data.borrow())?;\n        match authority_type {\n            AuthorityType::MintTokens => {\n                let mint_authority = mint.mint_authority\n                    .ok_or(Into::<ProgramError>::into(TokenError::FixedSupply))?;\n                Self::validate_owner(\n                    program_id,\n                    &mint_authority,\n                    authority_info,\n                    account_info_iter.as_slice(),\n                )?;\n                mint.mint_authority = new_authority;\n            }\n            AuthorityType::FreezeAccount => {\n                let freeze_authority = mint.freeze_authority\n                    .ok_or(Into::<ProgramError>::into(TokenError::MintCannotFreeze))?;\n                Self::validate_owner(\n                    program_id,\n                    &freeze_authority,\n                    authority_info,\n                    account_info_iter.as_slice(),\n                )?;\n                mint.freeze_authority = new_authority;\n            }\n            _ => return Err(TokenError::AuthorityTypeNotSupported.into()),\n        }\n        Mint::pack(mint, &mut account_info.data.borrow_mut())?;\n    }\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe set_authority function properly validates that the caller is the current authority through validate_owner before allowing any authority changes. Handles both mint_authority and freeze_authority with appropriate checks for fixed supply mints.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_withdraw_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let destination_lamports_info = next_account_info(account_info_iter)?;\n    let burn_from_pool_info = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    // Missing: stake_pool.check_authority_withdraw verification\n    // Missing: check_account_owner for stake_pool_info\n    \n    let withdraw_lamports = stake_pool.calc_lamports_withdraw_amount(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    Self::stake_withdraw(\n        stake_pool_info.key,\n        reserve_stake_info.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        destination_lamports_info.clone(),\n        withdraw_lamports,\n    )?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nCRITICAL\nThe withdrawal function does not verify the withdraw_authority_info against the stake pool's expected authority. An attacker could provide a fake withdraw authority and drain the reserve stake.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let reserve_info = next_account_info(account_info_iter)?;\n    let reserve_liquidity = next_account_info(account_info_iter)?;\n    let user_collateral = next_account_info(account_info_iter)?;\n    let user_liquidity = next_account_info(account_info_iter)?;\n    let reserve_collateral_mint = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let lending_market_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut reserve = Reserve::unpack(&reserve_info.data.borrow())?;\n    \n    let collateral_exchange_rate = reserve.collateral_exchange_rate()?;\n    let liquidity_amount = collateral_exchange_rate.collateral_to_liquidity(amount)?;\n    \n    require!(reserve.liquidity.available_amount >= liquidity_amount, LendingError::InsufficientLiquidity);\n\n    reserve.liquidity.available_amount = reserve.liquidity.available_amount\n        .checked_sub(liquidity_amount)?;\n    reserve.collateral.mint_total_supply = reserve.collateral.mint_total_supply\n        .checked_sub(amount)?;\n    Reserve::pack(reserve, &mut reserve_info.data.borrow_mut())?;\n\n    spl_token_burn(\n        token_program.clone(),\n        user_collateral.clone(),\n        reserve_collateral_mint.clone(),\n        user_authority.clone(),\n        amount,\n    )?;\n\n    let authority_seeds = &[lending_market_info.key.as_ref(), &[lending_market.bump_seed]];\n    let signer = &[&authority_seeds[..]];\n\n    spl_token_transfer(\n        token_program.clone(),\n        reserve_liquidity.clone(),\n        user_liquidity.clone(),\n        lending_market_authority.clone(),\n        liquidity_amount,\n        signer,\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nDouble protection: (1) State update (available_amount, mint_total_supply) happens before CPIs, (2) User's collateral tokens are burned before receiving liquidity. Even with reentrancy, the attacker has no collateral to burn for a second withdrawal, and reserve state is already updated.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\nfn relocate_lamports(\n    source_account_info: &AccountInfo,\n    destination_account_info: &AccountInfo,\n    lamports: u64,\n) -> ProgramResult {\n    {\n        let mut source_lamports = source_account_info.try_borrow_mut_lamports()?;\n        **source_lamports = source_lamports\n            .checked_sub(lamports)\n            .ok_or(ProgramError::InsufficientFunds)?;\n    }\n    {\n        let mut destination_lamports = destination_account_info.try_borrow_mut_lamports()?;\n        **destination_lamports = destination_lamports\n            .checked_add(lamports)\n            .ok_or(ProgramError::ArithmeticOverflow)?;\n    }\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow/Underflow - MITIGATED\nBoth lamport operations use checked arithmetic. The source subtraction uses checked_sub with InsufficientFunds error. The destination addition uses checked_add with ArithmeticOverflow error. This pattern from SPL Token ensures safe lamport transfers.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_compound_all(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let strategy_info = next_account_info(account_info_iter)?;\n\n    let vault = Vault::unpack(&vault_info.data.borrow())?;\n\n    for depositor in vault.depositors.iter() {\n        let pending_yield = calculate_yield(depositor)?;\n        \n        let new_shares = pending_yield\n            .checked_mul(vault.total_shares)?\n            .checked_div(vault.total_assets)?;\n        \n        update_depositor_shares(depositor, new_shares)?;\n    }\n\n    harvest_strategy(strategy_info)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nHIGH\nCompounding requires iterating all depositors. As vault grows popular, compound function fails, yield stops accumulating for everyone. Vault becomes economically broken - no one can earn yield. Should compound per-user on interaction (lazy compounding).<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\nfn token_burn<'a>(\n    token_program: AccountInfo<'a>,\n    burn_account: AccountInfo<'a>,\n    mint: AccountInfo<'a>,\n    authority: AccountInfo<'a>,\n    amount: u64,\n) -> Result<(), ProgramError> {\n    let ix = spl_token::instruction::burn(\n        token_program.key,\n        burn_account.key,\n        mint.key,\n        authority.key,\n        &[],\n        amount,\n    )?;\n\n    invoke(&ix, &[burn_account, mint, authority])?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nThe invoke() call includes the ? operator for proper error propagation. If the token burn fails for any reason (insufficient balance, frozen account, wrong authority), the error is returned immediately and the calling function will handle or propagate it further, ensuring no silent failures.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_update_validator_list_balance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    start_index: u32,\n    no_merge: bool,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let validator_stake_accounts = account_info_iter.as_slice();\n\n    let stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n\n    let epoch_rewards = EpochRewards::get()?;\n    if epoch_rewards.active {\n        return Err(StakePoolError::EpochRewardDistributionInProgress.into());\n    }\n\n    if validator_stake_accounts.len().checked_rem(2)\n        .ok_or(StakePoolError::CalculationFailure)? != 0 {\n        return Err(StakePoolError::UnexpectedValidatorListAccountSize.into());\n    }\n\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut big_vec) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n    \n    let validator_slice = ValidatorListHeader::deserialize_mut_slice(\n        &mut big_vec,\n        start_index as usize,\n        validator_stake_accounts.len() / 2,\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nPaginated processing with start_index allows updating large validator lists across multiple transactions. Epoch rewards check prevents inconsistent state during distribution. Input validation (pairs check) prevents malformed requests. Large pools remain operational via batched updates.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_withdraw_collateral(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let market_info = next_account_info(account_info_iter)?;\n    let position_info = next_account_info(account_info_iter)?;\n    let collateral_vault = next_account_info(account_info_iter)?;\n    let user_collateral = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let market_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let market = PerpMarket::unpack(&market_info.data.borrow())?;\n    let position = Position::unpack(&position_info.data.borrow())?;\n    \n    let remaining_collateral = position.collateral_amount.checked_sub(amount)\n        .ok_or(PerpError::InsufficientCollateral)?;\n    \n    let required_collateral = calculate_required_collateral(&position, &market)?;\n    if remaining_collateral < required_collateral {\n        return Err(PerpError::InsufficientMargin.into());\n    }\n\n    let seeds = &[b\"market_authority\", market_info.key.as_ref(), &[market.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        collateral_vault.key,\n        user_collateral.key,\n        market_authority.key,\n        &[],\n        amount,\n    )?;\n    invoke_signed(&transfer_ix, &[collateral_vault.clone(), user_collateral.clone(), market_authority.clone()], signer)?;\n\n    let mut position_mut = Position::unpack(&position_info.data.borrow())?;\n    position_mut.collateral_amount = remaining_collateral;\n    position_mut.last_update_slot = Clock::get()?.slot;\n    \n    Position::pack(position_mut, &mut position_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nCRITICAL\nCollateral transfer CPI executes before updating position.collateral_amount. Attacker controlling user_collateral can callback into withdraw_collateral(). The margin check uses the original collateral_amount which hasn't been reduced, allowing withdrawal of more collateral than the margin requirement permits, potentially leaving undercollateralized positions.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_flash_loan(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    loan_amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let pool_vault = next_account_info(account_info_iter)?;\n    let borrower_token = next_account_info(account_info_iter)?;\n    let borrower_program = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = FlashLoanPool::unpack(&pool_info.data.borrow())?;\n    \n    if pool.flash_loan_in_progress {\n        return Err(FlashError::ReentrancyDetected.into());\n    }\n\n    let fee = loan_amount.checked_mul(pool.fee_bps as u64)?\n        .checked_div(10000)?;\n    let vault_balance_before = get_token_balance(pool_vault)?;\n    \n    pool.flash_loan_in_progress = true;\n    pool.current_loan_amount = loan_amount;\n    FlashLoanPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n\n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let loan_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_vault.key,\n        borrower_token.key,\n        pool_authority.key,\n        &[],\n        loan_amount,\n    )?;\n    invoke_signed(&loan_ix, &[pool_vault.clone(), borrower_token.clone(), pool_authority.clone()], signer)?;\n\n    let callback_ix = Instruction {\n        program_id: *borrower_program.key,\n        accounts: vec![],\n        data: vec![],\n    };\n    invoke(&callback_ix, &[borrower_program.clone()])?;\n\n    let vault_balance_after = get_token_balance(pool_vault)?;\n    let expected_balance = vault_balance_before.checked_add(fee)?;\n    \n    if vault_balance_after < expected_balance {\n        return Err(FlashError::InsufficientRepayment.into());\n    }\n\n    let mut pool_mut = FlashLoanPool::unpack(&pool_info.data.borrow())?;\n    pool_mut.flash_loan_in_progress = false;\n    pool_mut.current_loan_amount = 0;\n    pool_mut.total_loans = pool_mut.total_loans.checked_add(1)?;\n    pool_mut.total_fees = pool_mut.total_fees.checked_add(fee)?;\n    FlashLoanPool::pack(pool_mut, &mut pool_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nImplements a reentrancy guard pattern: flash_loan_in_progress flag is set to true before any CPI. Recursive calls during the loan or callback will fail the 'if pool.flash_loan_in_progress' check at function entry, preventing nested flash loans from the same pool.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn get_governance_authority(\n    program_id: &Pubkey,\n    governance_id: &Pubkey,\n    bump: u8,\n) -> Result<Pubkey, ProgramError> {\n    Pubkey::create_program_address(\n        &[\n            b\"governance\",\n            governance_id.as_ref(),\n            &[bump],\n        ],\n        program_id,\n    ).map_err(|_| GovernanceError::InvalidSeeds.into())\n}\n\npub fn process_execute_transaction(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    instruction_data: Vec<u8>,\n    bump: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n\n    let authority = get_governance_authority(program_id, governance_info.key, bump)?;\n    \n    let seeds = &[\n        b\"governance\",\n        governance_info.key.as_ref(),\n        &[bump],\n    ];\n\n    invoke_signed(\n        &Instruction::new_with_bytes(*proposal_info.key, &instruction_data, vec![]),\n        &[proposal_info.clone()],\n        &[seeds],\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nCRITICAL\nGovernance execution accepts user-provided bump for authority derivation. An attacker could potentially execute transactions using non-canonical PDAs if they find alternative valid bumps, bypassing governance controls or accessing phantom governance accounts.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\n#[account]\npub struct Auction {\n    pub highest_bidder: Pubkey,\n    pub highest_bid: u64,\n    pub previous_bidder: Pubkey,\n    pub previous_bid: u64,\n    pub end_time: i64,\n    pub ended: bool,\n}\n\npub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n    let auction = &mut ctx.accounts.auction;\n    let clock = Clock::get()?;\n\n    require!(clock.unix_timestamp < auction.end_time, AuctionError::Ended);\n    require!(amount > auction.highest_bid, AuctionError::BidTooLow);\n\n    auction.previous_bidder = auction.highest_bidder;\n    auction.previous_bid = auction.highest_bid;\n    \n    auction.highest_bidder = ctx.accounts.bidder.key();\n    auction.highest_bid = amount;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nFixed-size storage: only tracks current and previous bid, not all bids. No Vec growth regardless of bid count. Account size remains constant. Auction cannot be bloated by many bids. Previous bidder can claim refund via pull pattern.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_execute_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    proposal_id: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n    let treasury_info = next_account_info(account_info_iter)?;\n    let recipient_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let governance = Governance::unpack(&governance_info.data.borrow())?;\n    let proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    \n    if proposal.status != ProposalStatus::Approved {\n        return Err(GovernanceError::ProposalNotApproved.into());\n    }\n    if proposal.executed {\n        return Err(GovernanceError::AlreadyExecuted.into());\n    }\n\n    let seeds = &[b\"authority\", governance_info.key.as_ref(), &[governance.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = system_instruction::transfer(\n        treasury_info.key,\n        recipient_info.key,\n        proposal.amount,\n    );\n    invoke_signed(&transfer_ix, &[treasury_info.clone(), recipient_info.clone(), authority_info.clone()], signer)?;\n\n    let mut proposal_mut = Proposal::unpack(&proposal_info.data.borrow())?;\n    proposal_mut.executed = true;\n    proposal_mut.execution_timestamp = Clock::get()?.unix_timestamp;\n    \n    Proposal::pack(proposal_mut, &mut proposal_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nCRITICAL\nThe treasury transfer CPI happens before setting proposal.executed = true. If the recipient is a program, its callback can invoke execute_proposal() again with the same proposal_id. The executed flag is still false, so the proposal passes validation and executes repeatedly, draining the entire treasury.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n\n    // Missing: validate_owner check for authority_info\n    // Anyone can transfer tokens from any account\n    \n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nCRITICAL\nThe transfer function does not validate that authority_info is the owner of the source account or an authorized delegate. Any user can drain tokens from any account by simply providing an arbitrary authority.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\npub fn process_approve(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let delegate_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n\n    Self::validate_owner(\n        program_id,\n        &source_account.owner,\n        owner_info,\n        account_info_iter.as_slice(),\n    )?;\n\n    // Allows setting delegate with 0 amount (pointless)\n    // No check if amount > account balance (misleading allowance)\n    \n    source_account.delegate = COption::Some(*delegate_info.key);\n    source_account.delegated_amount = amount;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nLOW\nThe approve function allows setting a delegate with zero amount, which is semantically pointless and wastes compute. It also allows setting delegated_amount greater than account balance, creating a misleading allowance that will fail on use.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_swap_with_callback(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount_in: u64,\n    minimum_out: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_source = next_account_info(account_info_iter)?;\n    let user_dest = next_account_info(account_info_iter)?;\n    let callback_program = next_account_info(account_info_iter)?;\n    let authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = SwapPool::unpack(&pool_info.data.borrow())?;\n    let amount_out = calculate_output(amount_in, &pool)?;\n    \n    if amount_out < minimum_out {\n        return Err(SwapError::SlippageExceeded.into());\n    }\n\n    let callback_ix = Instruction {\n        program_id: *callback_program.key,\n        accounts: vec![],\n        data: amount_out.to_le_bytes().to_vec(),\n    };\n    invoke(&callback_ix, &[callback_program.clone()]);\n\n    pool.reserve_a += amount_in;\n    pool.reserve_b -= amount_out;\n    SwapPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nHIGH\nThe callback invoke() is unchecked. If the callback fails (program doesn't exist, invalid instruction), execution continues and pool reserves are updated anyway. The user's swap appears successful but the callback (potentially critical business logic) never executed. Pool state becomes inconsistent with expected behavior.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\nconst MAX_DEPOSITORS: usize = 1000;\n\n#[account]\npub struct Vault {\n    pub depositors: Vec<Pubkey>,\n    pub balances: Vec<u64>,\n    pub total_deposited: u64,\n}\n\npub fn process_deposit(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    let user_index = vault.depositors.iter().position(|d| d == user_info.key);\n    \n    match user_index {\n        Some(idx) => {\n            vault.balances[idx] = vault.balances[idx]\n                .checked_add(amount)\n                .ok_or(VaultError::Overflow)?;\n        }\n        None => {\n            if vault.depositors.len() >= MAX_DEPOSITORS {\n                return Err(VaultError::MaxDepositorsReached.into());\n            }\n            vault.depositors.push(*user_info.key);\n            vault.balances.push(amount);\n        }\n    }\n    \n    vault.total_deposited = vault.total_deposited\n        .checked_add(amount)\n        .ok_or(VaultError::Overflow)?;\n    \n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nMAX_DEPOSITORS constant limits Vec growth. Duplicate check prevents same user added twice. Account size bounded and predictable. Compute cost for iteration is bounded. Vault operations remain within compute budget.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let pool = Pool::unpack(&pool_info.data.borrow())?;\n    \n    let authority_seeds = &[\n        b\"authority\",\n        pool_info.key.as_ref(),\n        &[pool.bump_seed],\n    ];\n    \n    let derived = Pubkey::create_program_address(authority_seeds, program_id)?;\n    if *authority_info.key != derived {\n        return Err(PoolError::InvalidAuthority.into());\n    }\n\n    invoke_signed(\n        &spl_token::instruction::transfer(\n            token_program.key,\n            pool_info.key,\n            destination_info.key,\n            authority_info.key,\n            &[],\n            amount,\n        )?,\n        &[pool_info.clone(), destination_info.clone(), authority_info.clone()],\n        &[authority_seeds],\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nMEDIUM\nWhile the stored bump is used (not user-provided per transaction), if the pool was initialized with a non-canonical bump, this function perpetuates that vulnerability. The initial storage of bump_seed must have been validated as canonical using find_program_address().<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_set_authority(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    authority_type: AuthorityType,\n    new_authority: COption<Pubkey>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut mint = Mint::unpack(&account_info.data.borrow())?;\n    \n    match authority_type {\n        AuthorityType::MintTokens => {\n            // Missing validation that authority_info matches mint.mint_authority\n            // Anyone can change the mint authority\n            mint.mint_authority = new_authority;\n        }\n        AuthorityType::FreezeAccount => {\n            mint.freeze_authority = new_authority;\n        }\n        _ => return Err(TokenError::AuthorityTypeNotSupported.into()),\n    }\n    \n    Mint::pack(mint, &mut account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nCRITICAL\nThe set_authority function does not validate that authority_info is the current mint_authority or freeze_authority. An attacker can take over the mint by setting themselves as the new authority.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_claim_all_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_info = next_account_info(account_info_iter)?;\n    let user_stakes_info = next_account_info(account_info_iter)?;\n\n    let user_stakes = UserStakes::unpack(&user_stakes_info.data.borrow())?;\n    let mut total_claimed: u64 = 0;\n\n    for stake in user_stakes.active_stakes.iter() {\n        let pool_info = find_pool_account(&stake.pool)?;\n        let pool = Pool::unpack(&pool_info.data.borrow())?;\n        \n        let pending = calculate_pending_rewards(stake, &pool)?;\n        \n        transfer_rewards(user_info, pending)?;\n        total_claimed = total_claimed.checked_add(pending)\n            .ok_or(ProgramError::ArithmeticOverflow)?;\n    }\n\n    msg!(\"Total claimed: {}\", total_claimed);\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nHIGH\nIteration over unbounded active_stakes with CPI calls inside loop. Each stake requires: account lookup, deserialization, calculation, and transfer CPI. If user has many stakes, compute budget is exhausted. Users with many small stakes cannot claim any rewards.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_deposit(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    bump: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let authority_seeds = &[\n        b\"authority\",\n        pool_info.key.as_ref(),\n        &[bump],\n    ];\n    \n    let expected_authority = Pubkey::create_program_address(\n        authority_seeds,\n        program_id,\n    )?;\n    \n    if *authority_info.key != expected_authority {\n        return Err(PoolError::InvalidAuthority.into());\n    }\n\n    invoke_signed(\n        &spl_token::instruction::transfer(\n            token_program.key,\n            user_info.key,\n            pool_info.key,\n            authority_info.key,\n            &[],\n            amount,\n        )?,\n        &[user_info.clone(), pool_info.clone(), authority_info.clone()],\n        &[authority_seeds],\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nCRITICAL\nThe bump is passed per-transaction and used for signing without stored canonical bump verification. An attacker could provide any valid bump to sign transactions, potentially accessing different PDAs or bypassing authority checks if the pool stores a different bump value.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn find_governance_program_address(\n    program_id: &Pubkey,\n    realm: &Pubkey,\n    governed_account: &Pubkey,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &[\n            b\"account-governance\",\n            realm.as_ref(),\n            governed_account.as_ref(),\n        ],\n        program_id,\n    )\n}\n\npub fn process_create_governance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    config: GovernanceConfig,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let realm_info = next_account_info(account_info_iter)?;\n    let governance_info = next_account_info(account_info_iter)?;\n    let governed_account_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n\n    let (governance_address, bump_seed) = find_governance_program_address(\n        program_id,\n        realm_info.key,\n        governed_account_info.key,\n    );\n\n    if governance_address != *governance_info.key {\n        return Err(GovernanceError::InvalidGovernanceAddress.into());\n    }\n\n    let governance_seeds = &[\n        b\"account-governance\",\n        realm_info.key.as_ref(),\n        governed_account_info.key.as_ref(),\n        &[bump_seed],\n    ];\n\n    create_and_serialize_account_signed(\n        payer_info,\n        governance_info,\n        &GovernanceV2 {\n            realm: *realm_info.key,\n            governed_account: *governed_account_info.key,\n            config,\n            bump_seed,\n            ..Default::default()\n        },\n        governance_seeds,\n        program_id,\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nThe canonical bump is derived using find_program_address() during governance creation. The governance address is verified against the derived canonical address before proceeding. The canonical bump_seed is stored in the account for future operations. This pattern from SPL Governance ensures only canonical PDAs are created.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_liquidate(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    repay_amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let lending_market_info = next_account_info(account_info_iter)?;\n    let obligation_info = next_account_info(account_info_iter)?;\n    let collateral_vault_info = next_account_info(account_info_iter)?;\n    let liquidator_collateral_info = next_account_info(account_info_iter)?;\n    let liquidator_repay_info = next_account_info(account_info_iter)?;\n    let reserve_vault_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let market = LendingMarket::unpack(&lending_market_info.data.borrow())?;\n    let mut obligation = Obligation::unpack(&obligation_info.data.borrow())?;\n    \n    let health_factor = calculate_health_factor(&obligation)?;\n    if health_factor >= LIQUIDATION_THRESHOLD {\n        return Err(LendingError::HealthyPosition.into());\n    }\n\n    let collateral_to_seize = calculate_collateral_to_seize(repay_amount, &obligation)?;\n\n    let repay_ix = spl_token::instruction::transfer(\n        token_program.key,\n        liquidator_repay_info.key,\n        reserve_vault_info.key,\n        liquidator_repay_info.key,\n        &[],\n        repay_amount,\n    )?;\n    invoke(&repay_ix, &[liquidator_repay_info.clone(), reserve_vault_info.clone(), token_program.clone()])?;\n\n    let seeds = &[b\"authority\", lending_market_info.key.as_ref(), &[market.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let seize_ix = spl_token::instruction::transfer(\n        token_program.key,\n        collateral_vault_info.key,\n        liquidator_collateral_info.key,\n        authority_info.key,\n        &[],\n        collateral_to_seize,\n    )?;\n    invoke_signed(&seize_ix, &[collateral_vault_info.clone(), liquidator_collateral_info.clone(), authority_info.clone()], signer)?;\n\n    obligation.borrowed_amount = obligation.borrowed_amount.checked_sub(repay_amount)\n        .ok_or(LendingError::MathOverflow)?;\n    obligation.collateral_amount = obligation.collateral_amount.checked_sub(collateral_to_seize)\n        .ok_or(LendingError::MathOverflow)?;\n    \n    Obligation::pack(obligation, &mut obligation_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nCRITICAL\nTwo CPIs execute before state updates: repay_ix and seize_ix. During seize CPI callback, the attacker can call liquidate() again. Since obligation state hasn't been updated, health_factor check passes again, allowing the attacker to repeatedly seize collateral while only repaying once.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn authority_id(\n    program_id: &Pubkey,\n    pool_info: &Pubkey,\n    bump_seed: u8,\n) -> Result<Pubkey, ProgramError> {\n    Pubkey::create_program_address(\n        &[&pool_info.to_bytes()[..32], &[bump_seed]],\n        program_id,\n    ).map_err(|_| PoolError::InvalidAuthorityData.into())\n}\n\npub fn process_init_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    bump_seed: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut pool = Pool::try_from_slice(&pool_account_info.data.borrow())?;\n    if pool.is_initialized() {\n        return Err(PoolError::AlreadyInUse.into());\n    }\n\n    let authority = Self::authority_id(program_id, pool_account_info.key, bump_seed)?;\n    if *authority_info.key != authority {\n        return Err(PoolError::InvalidAuthorityAccount.into());\n    }\n\n    pool.bump_seed = bump_seed;\n    pool.version = POOL_VERSION;\n    borsh::to_writer(&mut pool_account_info.data.borrow_mut()[..], &pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nHIGH\nThe bump_seed is passed as a user-controlled parameter and used directly with create_program_address(). Multiple bump values (0-255) can produce valid PDAs for the same seeds. An attacker can use a non-canonical bump to create phantom PDAs or cause collisions. Should use find_program_address() to derive the canonical (highest valid) bump.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n\n    if source_account.is_frozen() || destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    if !Self::cmp_pubkeys(&source_account.mint, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    match source_account.delegate {\n        COption::Some(ref delegate) if Self::cmp_pubkeys(authority_info.key, delegate) => {\n            Self::validate_owner(program_id, delegate, authority_info, account_info_iter.as_slice())?;\n            if source_account.delegated_amount < amount {\n                return Err(TokenError::InsufficientFunds.into());\n            }\n            source_account.delegated_amount = source_account.delegated_amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n        }\n        _ => Self::validate_owner(program_id, &source_account.owner, authority_info, account_info_iter.as_slice())?,\n    };\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe transfer function properly validates ownership through validate_owner, which checks either the account owner or an authorized delegate. It also verifies frozen status and mint consistency before any transfer.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn _process_initialize_multisig(\n    accounts: &[AccountInfo],\n    m: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let multisig_info = next_account_info(account_info_iter)?;\n    let rent = Rent::get()?;\n\n    let mut multisig = Multisig::unpack_unchecked(&multisig_info.data.borrow())?;\n    if multisig.is_initialized {\n        return Err(TokenError::AlreadyInUse.into());\n    }\n\n    let signer_infos = account_info_iter.as_slice();\n    \n    \n    multisig.m = m;\n    multisig.n = signer_infos.len() as u8;\n    for (i, signer_info) in signer_infos.iter().enumerate() {\n        multisig.signers[i] = *signer_info.key;\n    }\n    multisig.is_initialized = true;\n\n    Multisig::pack(multisig, &mut multisig_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nCRITICAL\nThe multisig initialization lacks critical validation: m could be 0 (allowing operations with no signatures), m could exceed n (making the multisig unusable), and signer count (n) is not validated against MAX_SIGNERS, potentially causing array overflow.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\nfn token_burn<'a>(\n    token_program: AccountInfo<'a>,\n    burn_account: AccountInfo<'a>,\n    mint: AccountInfo<'a>,\n    authority: AccountInfo<'a>,\n    amount: u64,\n) -> Result<(), ProgramError> {\n    let ix = spl_token::instruction::burn(\n        token_program.key,\n        burn_account.key,\n        mint.key,\n        authority.key,\n        &[],\n        amount,\n    )?;\n\n    invoke(&ix, &[burn_account, mint, authority])\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nHIGH\nThe invoke() call result is not propagated with the ? operator. If the token burn CPI fails (insufficient balance, frozen account, wrong authority), the error is silently ignored and the function returns Ok(()), leading to inconsistent state where the caller believes tokens were burned but they weren't.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_distribute_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let reward_vault = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let pool = Pool::unpack(&pool_info.data.borrow())?;\n    \n    for staker in pool.stakers.iter() {\n        let reward = calculate_reward(staker)?;\n        \n        let transfer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            reward_vault.key,\n            &staker.reward_account,\n            pool_info.key,\n            &[],\n            reward,\n        )?;\n        \n        invoke_signed(&transfer_ix, &[reward_vault.clone()], &[])?;\n    }\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nCRITICAL\nUnbounded iteration over pool.stakers without pagination. If the stakers list grows large, the transaction will exceed Solana's compute budget (200K CU default, 1.4M max). An attacker can add many small stakes to make reward distribution impossible, permanently locking rewards.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_deposit_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    deposit_lamports: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let from_user_info = next_account_info(account_info_iter)?;\n    let dest_user_pool_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    \n    let new_pool_tokens = stake_pool.calc_pool_tokens_for_deposit(deposit_lamports)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    Self::token_mint_to(\n        stake_pool_info.key,\n        token_program_info.clone(),\n        pool_mint_info.clone(),\n        dest_user_pool_info.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        new_pool_tokens,\n    )?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nHIGH\nThe deposit function lacks input validation: no check for zero deposits, no minimum deposit threshold to prevent dust deposits, and no slippage protection. Attackers could perform sandwich attacks or flood the pool with worthless micro-deposits.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) =\n        ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n\n    if !header.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n    if header.max_validators == validator_list.len() {\n        return Err(ProgramError::AccountDataTooSmall);\n    }\n    if validator_list.len() >= MAX_VALIDATORS_IN_POOL {\n        return Err(StakePoolError::TooManyValidatorsInPool.into());\n    }\n    \n    let maybe_validator = validator_list.find::<ValidatorStakeInfo, _>(|x| {\n        ValidatorStakeInfo::memcmp_pubkey(x, validator_vote_info.key)\n    });\n    if maybe_validator.is_some() {\n        return Err(StakePoolError::ValidatorAlreadyAdded.into());\n    }\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nThree-layer DoS protection: (1) header.max_validators enforces pool-specific limit. (2) MAX_VALIDATORS_IN_POOL enforces global hard cap. (3) Duplicate check prevents same validator added twice. This ensures UpdateValidatorListBalance stays within compute budget regardless of attack attempts.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let stake_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    // Missing: stake_pool.check_staker(staker_info)?\n    // Missing: check_account_owner(stake_pool_info, program_id)?\n    \n    let (stake_address, bump_seed) = crate::find_stake_program_address(\n        program_id,\n        validator_vote_info.key,\n        stake_pool_info.key,\n        NonZeroU32::new(seed),\n    );\n    \n    // Continue with validator addition...\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nHIGH\nThe add_validator function does not verify that staker_info is the authorized staker for the pool. An attacker could add malicious validators to dilute staking rewards or manipulate the validator set.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_close_account(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let source_account = Account::unpack(&source_account_info.data.borrow())?;\n\n    if !source_account.is_native() && source_account.amount != 0 {\n        return Err(TokenError::NonNativeHasBalance.into());\n    }\n\n    let authority = source_account.close_authority.unwrap_or(source_account.owner);\n    Self::validate_owner(\n        program_id,\n        &authority,\n        authority_info,\n        account_info_iter.as_slice(),\n    )?;\n\n    let destination_starting_lamports = destination_account_info.lamports();\n    **destination_account_info.lamports.borrow_mut() = destination_starting_lamports\n        .checked_add(source_account_info.lamports())\n        .ok_or(TokenError::Overflow)?;\n\n    **source_account_info.lamports.borrow_mut() = 0;\n    delete_account(source_account_info)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe close_account function properly validates authority through validate_owner, checking against either the designated close_authority or the account owner. Only authorized parties can close accounts and receive rent lamports.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_initialize_vault(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    bump: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let pda = Pubkey::create_program_address(\n        &[\n            b\"vault\",\n            owner_info.key.as_ref(),\n            &[bump],\n        ],\n        program_id,\n    ).map_err(|_| VaultError::InvalidPDA)?;\n\n    if pda != *vault_info.key {\n        return Err(VaultError::PDAmismatch.into());\n    }\n\n    let mut vault = Vault::unpack_unchecked(&vault_info.data.borrow())?;\n    vault.owner = *owner_info.key;\n    vault.bump = bump;\n    vault.is_initialized = true;\n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nHIGH\nUser-provided bump is accepted and stored without verification that it's the canonical bump. An attacker could initialize multiple vault PDAs with different bumps (254, 253, etc.) for the same owner, creating phantom accounts. The canonical bump should be derived using find_program_address().<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn check_ephemeral_stake_address(\n    program_id: &Pubkey,\n    stake_pool_address: &Pubkey,\n    stake_account_address: &Pubkey,\n    seed: u64,\n) -> Result<u8, ProgramError> {\n    let (ephemeral_stake_address, bump_seed) =\n        find_ephemeral_stake_program_address(program_id, stake_pool_address, seed);\n    if ephemeral_stake_address != *stake_account_address {\n        Err(StakePoolError::InvalidStakeAccountAddress.into())\n    } else {\n        Ok(bump_seed)\n    }\n}\n\nfn find_ephemeral_stake_program_address(\n    program_id: &Pubkey,\n    stake_pool: &Pubkey,\n    seed: u64,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &[\n            EPHEMERAL_STAKE_SEED_PREFIX,\n            stake_pool.as_ref(),\n            &seed.to_le_bytes(),\n        ],\n        program_id,\n    )\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nThe check function derives the canonical address using find_program_address() internally, then validates the provided address matches. The returned bump_seed is canonical. This pattern from SPL Stake Pool ensures all ephemeral stake accounts use canonical bumps.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_add_to_balance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    if !authority_info.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let mut user_account = UserAccount::unpack(&user_account_info.data.borrow())?;\n    \n    user_account.balance = user_account.balance\n        .checked_add(amount)\n        .ok_or(ProgramError::ArithmeticOverflow)?;\n    \n    UserAccount::pack(user_account, &mut user_account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow - MITIGATED\nThe balance addition uses checked_add() which returns None on overflow. The ok_or() converts this to an error, ensuring the transaction reverts instead of silently wrapping. No arithmetic corruption is possible.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn find_deposit_authority_program_address(\n    program_id: &Pubkey,\n    stake_pool: &Pubkey,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &[stake_pool.as_ref(), AUTHORITY_DEPOSIT],\n        program_id,\n    )\n}\n\npub fn process_deposit(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let deposit_authority_info = next_account_info(account_info_iter)?;\n    let user_token_info = next_account_info(account_info_iter)?;\n\n    let (expected_deposit_authority, _bump) = find_deposit_authority_program_address(\n        program_id,\n        stake_pool_info.key,\n    );\n    \n    if *deposit_authority_info.key != expected_deposit_authority {\n        return Err(StakePoolError::InvalidDepositAuthority.into());\n    }\n\n    let stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    if stake_pool.stake_deposit_authority != *deposit_authority_info.key {\n        return Err(StakePoolError::InvalidDepositAuthority.into());\n    }\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nDouble validation: (1) find_program_address() derives canonical PDA for comparison. (2) Stored stake_deposit_authority in pool state is also verified. This ensures both derivation and storage are consistent with canonical addressing.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    \n    let (expected_withdraw_authority, _) = Pubkey::find_program_address(\n        &[stake_pool_info.key.as_ref(), AUTHORITY_WITHDRAW],\n        program_id,\n    );\n    \n    if *withdraw_authority_info.key != expected_withdraw_authority {\n        return Err(StakePoolError::InvalidAuthority.into());\n    }\n\n    let authority_seeds = &[\n        stake_pool_info.key.as_ref(),\n        AUTHORITY_WITHDRAW,\n        &[stake_pool.stake_withdraw_bump_seed],\n    ];\n\n    invoke_signed(\n        &spl_token::instruction::transfer(\n            token_program.key,\n            stake_pool_info.key,\n            destination_info.key,\n            withdraw_authority_info.key,\n            &[],\n            amount,\n        )?,\n        &[stake_pool_info.clone(), destination_info.clone(), withdraw_authority_info.clone()],\n        &[authority_seeds],\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nDual verification: (1) Authority address is verified using find_program_address() to ensure it matches expected canonical PDA. (2) Stored bump (stake_withdraw_bump_seed) is used for signing, which was canonically derived during pool initialization. No user-provided bump is accepted.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_settle_market(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let market_info = next_account_info(account_info_iter)?;\n    let settlement_price_info = next_account_info(account_info_iter)?;\n\n    let mut market = Market::unpack(&market_info.data.borrow())?;\n    let settlement_price = get_settlement_price(settlement_price_info)?;\n\n    for order in market.open_orders.iter() {\n        let pnl = calculate_settlement_pnl(order, settlement_price)?;\n        settle_order(order, pnl)?;\n    }\n\n    market.is_settled = true;\n    Market::pack(market, &mut market_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nCRITICAL\nSettlement requires processing all open orders in one transaction. If market has many orders, settlement becomes impossible. Users cannot receive their settlement proceeds. Market remains in limbo state. Should use claim-based settlement where users settle individually.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_cast_vote(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    voter_weight: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let proposal_info = next_account_info(account_info_iter)?;\n    let voter_record_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    let mut voter_record = VoterRecord::unpack(&voter_record_info.data.borrow())?;\n    \n    proposal.yes_votes += voter_weight;\n    voter_record.unrelinquished_votes_count += 1;\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    VoterRecord::pack(voter_record, &mut voter_record_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nMEDIUM\nBoth increments use unchecked arithmetic: (1) yes_votes += voter_weight can overflow if many high-weight voters participate. (2) unrelinquished_votes_count += 1 can overflow after billions of votes. The real SPL Governance uses checked_add().unwrap() to prevent this.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_create_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_owner_record_info = next_account_info(account_info_iter)?;\n\n    let mut governance_data = Governance::unpack(&governance_info.data.borrow())?;\n    let mut proposal_owner_record = TokenOwnerRecord::unpack(&proposal_owner_record_info.data.borrow())?;\n    \n    proposal_owner_record.outstanding_proposal_count += 1;\n    governance_data.active_proposal_count += 1;\n    \n    TokenOwnerRecord::pack(proposal_owner_record, &mut proposal_owner_record_info.data.borrow_mut())?;\n    Governance::pack(governance_data, &mut governance_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nMEDIUM\nBoth counter increments use unchecked addition. While unlikely in practice, if outstanding_proposal_count or active_proposal_count reach u64::MAX and overflow, governance tracking becomes corrupted. The real SPL Governance uses checked_add().unwrap() for these counters.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\nconst AUTHORITY_WITHDRAW: &[u8] = b\"withdraw\";\n\npub fn process_initialize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    max_validators: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n\n    let (withdraw_authority_key, stake_withdraw_bump_seed) =\n        Pubkey::find_program_address(\n            &[stake_pool_info.key.as_ref(), AUTHORITY_WITHDRAW],\n            program_id,\n        );\n    \n    if *withdraw_authority_info.key != withdraw_authority_key {\n        return Err(StakePoolError::InvalidAuthority.into());\n    }\n\n    let mut stake_pool = StakePool::unpack_unchecked(&stake_pool_info.data.borrow())?;\n    stake_pool.manager = *manager_info.key;\n    stake_pool.stake_withdraw_bump_seed = stake_withdraw_bump_seed;\n    stake_pool.max_validators = max_validators;\n    \n    StakePool::pack(stake_pool, &mut stake_pool_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nThe canonical bump is derived using find_program_address() during initialization. The address is verified, and only then is the canonical bump stored in stake_withdraw_bump_seed. Future operations will use this stored canonical bump. This is the correct pattern from SPL Stake Pool.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_execute_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let proposal_info = next_account_info(account_info_iter)?;\n    let executor_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    \n    if proposal.status != ProposalStatus::Approved {\n        return Err(GovernanceError::NotApproved.into());\n    }\n    if proposal.executed {\n        return Err(GovernanceError::AlreadyExecuted.into());\n    }\n\n    for instruction in proposal.instructions.iter() {\n        let ix = solana_program::instruction::Instruction {\n            program_id: instruction.program_id,\n            accounts: instruction.accounts.clone(),\n            data: instruction.data.clone(),\n        };\n        \n        invoke(&ix, accounts)?;\n    }\n    \n    proposal.status = ProposalStatus::Executed;\n    proposal.executed = true;\n    proposal.executed_at = Some(Clock::get()?.unix_timestamp);\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nAll invoke() calls inside the loop use the ? operator. If any proposal instruction fails, the entire transaction reverts atomically. The proposal status only changes to Executed if ALL instructions succeed, ensuring governance state consistency with actual on-chain execution.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn find_pool_authority(\n    program_id: &Pubkey,\n    pool_key: &Pubkey,\n) -> (Pubkey, u8) {\n    Pubkey::find_program_address(\n        &[b\"authority\", pool_key.as_ref()],\n        program_id,\n    )\n}\n\npub fn process_init_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let payer_info = next_account_info(account_info_iter)?;\n\n    let (expected_authority, bump_seed) = find_pool_authority(program_id, pool_info.key);\n    \n    if *authority_info.key != expected_authority {\n        return Err(PoolError::InvalidAuthority.into());\n    }\n\n    let mut pool = Pool::unpack_unchecked(&pool_info.data.borrow())?;\n    pool.authority = expected_authority;\n    pool.authority_bump = bump_seed;\n    pool.is_initialized = true;\n    Pool::pack(pool, &mut pool_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nThe bump is derived using find_program_address() which always returns the canonical bump (first valid bump starting from 255 and decrementing). No user input is accepted for the bump. The derived canonical bump is stored for future use.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_finalize_governance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n\n    let mut governance = Governance::unpack(&governance_info.data.borrow())?;\n    let proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n\n    if proposal.state != ProposalState::Succeeded {\n        return Err(GovernanceError::InvalidState.into());\n    }\n\n    for instruction in proposal.instructions.iter() {\n        let ix = Instruction {\n            program_id: instruction.program_id,\n            accounts: instruction.accounts.clone(),\n            data: instruction.data.clone(),\n        };\n        invoke(&ix, accounts)?;\n    }\n\n    governance.executed_proposals = governance.executed_proposals\n        .checked_add(1)\n        .ok_or(GovernanceError::Overflow)?;\n    Governance::pack(governance, &mut governance_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nCRITICAL\nUnbounded proposal instruction execution. A malicious proposal could contain hundreds of instructions, exhausting compute budget and making execution impossible. Even legitimate large proposals become unexecutable. Should limit MAX_INSTRUCTIONS_PER_PROPOSAL.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    fee: FeeType,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n    stake_pool.check_manager(manager_info)?;\n\n    if fee.can_only_change_next_epoch() && stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    fee.check_too_high()?;\n    stake_pool.update_fee(&fee)?;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe set_fee function properly validates program ownership, stake pool state, and manager authorization. Additional protection ensures fees cannot exceed reasonable bounds and epoch-dependent fees require fresh state.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let destination_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    if vault.user_balance < amount {\n        return Err(VaultError::InsufficientBalance.into());\n    }\n\n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        vault_info.key,\n        destination_info.key,\n        vault_info.key,\n        &[],\n        amount,\n    )?;\n    invoke(&transfer_ix, &[vault_info.clone(), destination_info.clone(), token_program.clone()])?;\n\n    vault.user_balance = vault.user_balance.checked_sub(amount)\n        .ok_or(VaultError::MathOverflow)?;\n    vault.total_deposits = vault.total_deposits.checked_sub(amount)\n        .ok_or(VaultError::MathOverflow)?;\n    \n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nCRITICAL\nClassic reentrancy vulnerability: the CPI transfer is executed before updating user_balance and total_deposits. If destination_info is a program account with a callback, it can recursively call withdraw() while the original balance is still intact, draining the vault completely.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_claim_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let stake_info = next_account_info(account_info_iter)?;\n    let reward_vault = next_account_info(account_info_iter)?;\n    let user_reward = next_account_info(account_info_iter)?;\n    let authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let pool = StakingPool::unpack(&pool_info.data.borrow())?;\n    let mut stake = UserStake::unpack(&stake_info.data.borrow())?;\n    \n    let pending = calculate_rewards(&pool, &stake, clock.unix_timestamp)?;\n    \n    if pending == 0 {\n        return Err(StakingError::NoRewards.into());\n    }\n\n    let seeds = &[b\"reward_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        reward_vault.key,\n        user_reward.key,\n        authority.key,\n        &[],\n        pending,\n    )?;\n    invoke_signed(&transfer_ix, &[\n        reward_vault.clone(),\n        user_reward.clone(),\n        authority.clone(),\n    ], signer)?;\n\n    stake.last_claim = clock.unix_timestamp;\n    stake.total_claimed = stake.total_claimed\n        .checked_add(pending)\n        .ok_or(StakingError::MathOverflow)?;\n    UserStake::pack(stake, &mut stake_info.data.borrow_mut())?;\n    \n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nThe invoke_signed() uses ? for error propagation. Stake state (last_claim, total_claimed) is only updated AFTER successful transfer. If the transfer fails, state remains unchanged, allowing retry. No risk of claiming rewards without receiving them.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_swap(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount_in: u64,\n    minimum_amount_out: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let pool_token_a_info = next_account_info(account_info_iter)?;\n    let pool_token_b_info = next_account_info(account_info_iter)?;\n    let user_token_a_info = next_account_info(account_info_iter)?;\n    let user_token_b_info = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = SwapPool::unpack(&pool_info.data.borrow())?;\n    \n    let amount_out = calculate_swap_amount(\n        amount_in,\n        pool.reserve_a,\n        pool.reserve_b,\n    )?;\n    \n    if amount_out < minimum_amount_out {\n        return Err(SwapError::SlippageExceeded.into());\n    }\n\n    let transfer_in_ix = spl_token::instruction::transfer(\n        token_program.key,\n        user_token_a_info.key,\n        pool_token_a_info.key,\n        user_authority.key,\n        &[],\n        amount_in,\n    )?;\n    invoke(&transfer_in_ix, &[user_token_a_info.clone(), pool_token_a_info.clone(), user_authority.clone()])?;\n\n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_out_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_token_b_info.key,\n        user_token_b_info.key,\n        pool_authority.key,\n        &[],\n        amount_out,\n    )?;\n    invoke_signed(&transfer_out_ix, &[pool_token_b_info.clone(), user_token_b_info.clone(), pool_authority.clone()], signer)?;\n\n    pool.reserve_a = pool.reserve_a.checked_add(amount_in).ok_or(SwapError::MathOverflow)?;\n    pool.reserve_b = pool.reserve_b.checked_sub(amount_out).ok_or(SwapError::MathOverflow)?;\n    \n    SwapPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nHIGH\nThe swap executes two CPIs before updating pool reserves. During the transfer_out callback, an attacker can call swap() again with the original favorable reserve ratio. Since reserve_a and reserve_b haven't been updated, each recursive call gets the same advantageous exchange rate, draining pool_token_b.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_emergency_claim(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let user_token_info = next_account_info(account_info_iter)?;\n    let vault_token_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    if !vault.emergency_mode {\n        return Err(VaultError::NotEmergency.into());\n    }\n\n    let user_shares = get_user_shares(&vault, user_info.key)?;\n    if user_shares == 0 {\n        return Err(VaultError::NoShares.into());\n    }\n\n    let claim_amount = user_shares\n        .checked_mul(vault.total_assets)?\n        .checked_div(vault.total_shares)?;\n\n    burn_user_shares(vault_info, user_info.key)?;\n    \n    transfer_tokens(\n        token_program,\n        vault_token_info,\n        user_token_info,\n        claim_amount,\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nIndividual emergency claims: users rescue their own funds. Admin only needs to set emergency_mode flag (single operation). No iteration over users required. Vault can have unlimited users and still allow emergency exits. Each claim is O(1).<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_claim_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let pool = StakingPool::unpack(&pool_info.data.borrow())?;\n    let mut user = UserStake::unpack(&user_info.data.borrow())?;\n    \n    let time_elapsed = clock.unix_timestamp - user.last_claim_timestamp;\n    let pending_rewards = user.staked_amount * pool.reward_rate * time_elapsed as u64 / PRECISION;\n    \n    user.claimed_rewards += pending_rewards;\n    user.last_claim_timestamp = clock.unix_timestamp;\n    \n    UserStake::pack(user, &mut user_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow/Underflow\nHIGH\nTwo issues: (1) clock.unix_timestamp - user.last_claim_timestamp can underflow if last_claim is somehow in the future (clock drift, manipulation). (2) The multiplication chain staked_amount * reward_rate * time_elapsed can easily overflow before division, resulting in incorrect rewards.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_increase_validator_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    lamports: u64,\n    transient_stake_seed: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let validator_stake_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    stake_pool.check_staker(staker_info)?;\n    \n    \n    Self::stake_split(\n        stake_pool_info.key,\n        reserve_stake_info.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        lamports,\n        validator_stake_info.clone(),\n    )?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nHIGH\nThe increase_validator_stake function does not validate the lamports parameter. Missing checks include: zero amount validation, minimum delegation requirement (could create invalid stake), and reserve balance bounds (could drain reserve below minimum).<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let stake_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    stake_pool.check_authority_withdraw(withdraw_authority_info.key, program_id, stake_pool_info.key)?;\n    stake_pool.check_staker(staker_info)?;\n    stake_pool.check_reserve_stake(reserve_stake_info)?;\n    stake_pool.check_validator_list(validator_list_info)?;\n\n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    check_account_owner(validator_list_info, program_id)?;\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n    \n    let maybe_validator = validator_list.find::<ValidatorStakeInfo, _>(|x| ValidatorStakeInfo::memcmp_pubkey(x, validator_vote_info.key));\n    if maybe_validator.is_some() {\n        return Err(StakePoolError::ValidatorAlreadyAdded.into());\n    }\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe add_validator function implements thorough access control: verifies program ownership, validates staker authorization, checks withdraw authority, verifies reserve stake and validator list. Prevents duplicate validators and requires fresh epoch data.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    fee: FeeType,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    // Missing: check_account_owner(stake_pool_info, program_id)?\n    // Missing: stake_pool.check_manager(manager_info)?\n    \n    fee.check_too_high()?;\n    stake_pool.update_fee(&fee)?;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nHIGH\nThe set_fee function does not verify that manager_info is the actual pool manager or that stake_pool_info is owned by the program. Anyone can modify pool fees, potentially extracting value from depositors.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_set_staker(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let set_staker_authority_info = next_account_info(account_info_iter)?;\n    let new_staker_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n\n    // Only checks if caller is signer, not if they are authorized\n    if !set_staker_authority_info.is_signer {\n        return Err(StakePoolError::SignatureMissing.into());\n    }\n    \n    stake_pool.staker = *new_staker_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nCRITICAL\nThe function only verifies that set_staker_authority_info is a signer but does not check if they are the current staker or manager. Any signer can change the staker role, allowing unauthorized control over stake delegation.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\nfn process_set_manager(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let new_manager_info = next_account_info(account_info_iter)?;\n    let new_manager_fee_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    // Missing: stake_pool.check_manager(manager_info)?\n    // Missing: new_manager_info.is_signer check\n    \n    stake_pool.manager = *new_manager_info.key;\n    stake_pool.manager_fee_account = *new_manager_fee_info.key;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nCRITICAL\nThe function allows anyone to change the stake pool manager without verifying that the caller is the current manager and without requiring the new manager to sign. An attacker can take over pool management and redirect fees.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_unstake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n    let pool_token_vault = next_account_info(account_info_iter)?;\n    let user_token_account = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = StakingPool::unpack(&pool_info.data.borrow())?;\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    if user_stake.staked_amount < amount {\n        return Err(StakingError::InsufficientStake.into());\n    }\n\n    user_stake.staked_amount = user_stake.staked_amount.checked_sub(amount)?;\n    user_stake.last_unstake_timestamp = Clock::get()?.unix_timestamp;\n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n\n    pool.total_staked = pool.total_staked.checked_sub(amount)?;\n    StakingPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n\n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_token_vault.key,\n        user_token_account.key,\n        pool_authority.key,\n        &[],\n        amount,\n    )?;\n    invoke_signed(&transfer_ix, &[pool_token_vault.clone(), user_token_account.clone(), pool_authority.clone()], signer)?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nCorrect CEI pattern: both user_stake.staked_amount and pool.total_staked are updated and written to storage BEFORE the transfer CPI. A reentrancy attempt during the transfer would see the reduced staked_amount and fail the balance check.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_transfer_with_pda(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    bump: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_info = next_account_info(account_info_iter)?;\n    let dest_info = next_account_info(account_info_iter)?;\n    let pda_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let seeds = &[b\"transfer_authority\", source_info.key.as_ref(), &[bump]];\n    \n    invoke_signed(\n        &spl_token::instruction::transfer(\n            token_program.key,\n            source_info.key,\n            dest_info.key,\n            pda_authority.key,\n            &[],\n            amount,\n        )?,\n        &[source_info.clone(), dest_info.clone(), pda_authority.clone()],\n        &[seeds],\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nCRITICAL\nUser-provided bump is used directly in invoke_signed without any validation. If an attacker finds multiple valid bumps, they could potentially sign transfers from different PDA-controlled accounts. Must derive and verify canonical bump using find_program_address().<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\nfn sol_transfer<'a>(\n    source: AccountInfo<'a>,\n    destination: AccountInfo<'a>,\n    amount: u64,\n) -> Result<(), ProgramError> {\n    let ix = solana_program::system_instruction::transfer(\n        source.key,\n        destination.key,\n        amount,\n    );\n    invoke(&ix, &[source, destination])?;\n    Ok(())\n}\n\npub fn process_withdraw_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let destination = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    \n    if vault.get_user_balance(user_info.key)? < amount {\n        return Err(VaultError::InsufficientBalance.into());\n    }\n\n    sol_transfer(vault_info.clone(), destination.clone(), amount)?;\n\n    vault.set_user_balance(user_info.key, \n        vault.get_user_balance(user_info.key)?.checked_sub(amount)\n            .ok_or(VaultError::MathOverflow)?\n    )?;\n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    \n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nBoth the helper function sol_transfer() and the calling process_withdraw_sol() properly propagate errors with ?. The sol_transfer helper returns Result and uses ? on invoke(). The caller also uses ? when calling sol_transfer. Balance is only reduced after successful transfer.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_withdraw_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n    minimum_lamports_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let stake_split_from = next_account_info(account_info_iter)?;\n    let stake_split_to = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let pool_tokens_fee = stake_pool\n        .calc_pool_tokens_stake_withdrawal_fee(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n    let pool_tokens_burnt = pool_tokens\n        .checked_sub(pool_tokens_fee)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let withdraw_lamports = stake_pool\n        .calc_lamports_withdraw_amount(pool_tokens_burnt)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if withdraw_lamports == 0 {\n        return Err(StakePoolError::WithdrawalTooSmall.into());\n    }\n\n    if let Some(minimum_lamports_out) = minimum_lamports_out {\n        if withdraw_lamports < minimum_lamports_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    let stake_minimum_delegation = stake::tools::get_minimum_delegation()?;\n    let stake_state = try_from_slice_unchecked::<stake::state::StakeStateV2>(&stake_split_from.data.borrow())?;\n    let meta = stake_state.meta().ok_or(StakePoolError::WrongStakeStake)?;\n    let required_lamports = minimum_stake_lamports(&meta, stake_minimum_delegation);\n\n    let remaining_lamports = stake_split_from.lamports().saturating_sub(withdraw_lamports);\n    if remaining_lamports < required_lamports {\n        return Err(StakePoolError::StakeLamportsNotEqualToMinimum.into());\n    }\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function implements comprehensive validation: epoch freshness check, minimum withdrawal threshold (withdraw_lamports == 0), slippage protection, stake minimum delegation verification, and remaining balance check to ensure stake account stays above minimum.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_claim_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let staking_pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n    let reward_vault_info = next_account_info(account_info_iter)?;\n    let user_reward_account = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let pool = StakingPool::unpack(&staking_pool_info.data.borrow())?;\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    let pending_rewards = calculate_pending_rewards(&pool, &user_stake)?;\n    \n    if pending_rewards == 0 {\n        return Err(StakingError::NoRewardsToClaim.into());\n    }\n\n    let seeds = &[b\"authority\", staking_pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        reward_vault_info.key,\n        user_reward_account.key,\n        authority_info.key,\n        &[],\n        pending_rewards,\n    )?;\n    invoke_signed(&transfer_ix, &[reward_vault_info.clone(), user_reward_account.clone(), authority_info.clone()], signer)?;\n\n    user_stake.last_claim_timestamp = Clock::get()?.unix_timestamp;\n    user_stake.rewards_claimed = user_stake.rewards_claimed.checked_add(pending_rewards)\n        .ok_or(StakingError::MathOverflow)?;\n    \n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nHIGH\nThe rewards transfer CPI occurs before updating last_claim_timestamp and rewards_claimed. An attacker controlling the user_reward_account program can callback into claim_rewards(), and since last_claim_timestamp hasn't changed, calculate_pending_rewards() returns the same value, allowing multiple claims.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    if destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if destination_account.is_native() {\n        return Err(TokenError::NativeNotSupported.into());\n    }\n    if !Self::cmp_pubkeys(mint_info.key, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    match mint.mint_authority {\n        COption::Some(mint_authority) => Self::validate_owner(\n            program_id,\n            &mint_authority,\n            owner_info,\n            account_info_iter.as_slice(),\n        )?,\n        COption::None => return Err(TokenError::FixedSupply.into()),\n    }\n\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe mint_to function properly validates that owner_info matches the mint's mint_authority through validate_owner. It also handles the fixed supply case and verifies mint consistency with the destination account.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\npub fn process_approve(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let expected_mint_info = if let Some(expected_decimals) = expected_decimals {\n        Some((next_account_info(account_info_iter)?, expected_decimals))\n    } else {\n        None\n    };\n    let delegate_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n\n    if source_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n\n    if let Some((mint_info, expected_decimals)) = expected_mint_info {\n        if !Self::cmp_pubkeys(mint_info.key, &source_account.mint) {\n            return Err(TokenError::MintMismatch.into());\n        }\n        let mint = Mint::unpack(&mint_info.data.borrow_mut())?;\n        if expected_decimals != mint.decimals {\n            return Err(TokenError::MintDecimalsMismatch.into());\n        }\n    }\n\n    Self::validate_owner(\n        program_id,\n        &source_account.owner,\n        owner_info,\n        account_info_iter.as_slice(),\n    )?;\n\n    source_account.delegate = COption::Some(*delegate_info.key);\n    source_account.delegated_amount = amount;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function validates: frozen account status, optional decimals matching for ApproveChecked variant, mint consistency when decimals provided, and owner authorization. The amount parameter is intentionally flexible as allowances can exceed balance.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    fee: FeeType,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    check_account_owner(stake_pool_info, program_id)?;\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    if !stake_pool.is_valid() {\n        return Err(StakePoolError::InvalidState.into());\n    }\n    stake_pool.check_manager(manager_info)?;\n\n    if fee.can_only_change_next_epoch() && stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    fee.check_too_high()?;\n    stake_pool.update_fee(&fee)?;\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function validates: program ownership, pool state validity, manager authorization, epoch-dependent fee change timing, and fee bounds via check_too_high(). The FeeType abstraction encapsulates validation logic for different fee types.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\n#[account]\npub struct ValidatorList {\n    pub validators: Vec<ValidatorInfo>,\n}\n\npub fn process_add_validator(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    vote_account: Pubkey,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n\n    let pool = StakePool::unpack(&pool_info.data.borrow())?;\n    let mut validator_list = ValidatorList::unpack(&validator_list_info.data.borrow())?;\n    \n    pool.check_manager(manager_info)?;\n\n    let new_validator = ValidatorInfo {\n        vote_account,\n        stake_lamports: 0,\n        last_update_epoch: Clock::get()?.epoch,\n    };\n    \n    validator_list.validators.push(new_validator);\n    ValidatorList::pack(validator_list, &mut validator_list_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nHIGH\nNo limit on validator list size. An attacker (or compromised manager) could add validators until: (1) Account data exceeds Solana's 10MB limit. (2) Iteration over validators in other functions exceeds compute budget. (3) Reallocation costs become prohibitive. Should enforce MAX_VALIDATORS limit.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_liquidate(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    repay_amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let obligation_info = next_account_info(account_info_iter)?;\n    let repay_reserve_info = next_account_info(account_info_iter)?;\n    let withdraw_reserve_info = next_account_info(account_info_iter)?;\n    let liquidator_repay = next_account_info(account_info_iter)?;\n    let liquidator_withdraw = next_account_info(account_info_iter)?;\n    let repay_reserve_liquidity = next_account_info(account_info_iter)?;\n    let withdraw_reserve_collateral = next_account_info(account_info_iter)?;\n    let liquidator_authority = next_account_info(account_info_iter)?;\n    let lending_market_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut obligation = Obligation::unpack(&obligation_info.data.borrow())?;\n    let repay_reserve = Reserve::unpack(&repay_reserve_info.data.borrow())?;\n    let withdraw_reserve = Reserve::unpack(&withdraw_reserve_info.data.borrow())?;\n    \n    let health_factor = calculate_health_factor(&obligation)?;\n    require!(health_factor < LIQUIDATION_THRESHOLD, LendingError::HealthyObligation);\n\n    let collateral_to_seize = calculate_liquidation_collateral(repay_amount, &repay_reserve, &withdraw_reserve)?;\n    \n    obligation.borrowed_value = obligation.borrowed_value.checked_sub(repay_amount)?;\n    obligation.deposited_value = obligation.deposited_value.checked_sub(collateral_to_seize)?;\n    obligation.last_update_slot = Clock::get()?.slot;\n    Obligation::pack(obligation, &mut obligation_info.data.borrow_mut())?;\n\n    spl_token_transfer(\n        token_program.clone(),\n        liquidator_repay.clone(),\n        repay_reserve_liquidity.clone(),\n        liquidator_authority.clone(),\n        repay_amount,\n        &[],\n    )?;\n\n    let authority_seeds = &[lending_market_info.key.as_ref(), &[lending_market.bump_seed]];\n    let signer = &[&authority_seeds[..]];\n    \n    spl_token_transfer(\n        token_program.clone(),\n        withdraw_reserve_collateral.clone(),\n        liquidator_withdraw.clone(),\n        lending_market_authority.clone(),\n        collateral_to_seize,\n        signer,\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nObligation state (borrowed_value, deposited_value) is updated before any CPIs. A reentrancy attempt during either transfer would see the updated obligation, which now has a healthier position (higher health_factor), causing the liquidation threshold check to fail on recursive calls.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_distribute_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    reward_amounts: Vec<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let reward_vault = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let recipients: Vec<&AccountInfo> = account_info_iter.collect();\n    \n    if recipients.len() != reward_amounts.len() {\n        return Err(ProgramError::InvalidArgument);\n    }\n\n    let seeds = &[b\"vault_authority\", &[authority_bump]];\n    let signer = &[&seeds[..]];\n\n    for (i, recipient) in recipients.iter().enumerate() {\n        let transfer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            reward_vault.key,\n            recipient.key,\n            authority_info.key,\n            &[],\n            reward_amounts[i],\n        )?;\n        \n        invoke_signed(&transfer_ix, &[\n            reward_vault.clone(),\n            (*recipient).clone(),\n            authority_info.clone(),\n        ], signer)?;\n    }\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nEach invoke_signed() in the loop properly propagates errors with ?. If any single reward transfer fails, the entire batch reverts. This atomic all-or-nothing behavior ensures either everyone receives their rewards or no one does, preventing partial distribution inconsistencies.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\n#[derive(Accounts)]\npub struct PlaceBid<'info> {\n    #[account(mut)]\n    pub auction: Account<'info, Auction>,\n    #[account(mut)]\n    pub bidder: Signer<'info>,\n}\n\n#[account]\npub struct Auction {\n    pub bids: Vec<Bid>,\n    pub highest_bid: u64,\n    pub end_time: i64,\n}\n\npub fn place_bid(ctx: Context<PlaceBid>, amount: u64) -> Result<()> {\n    let auction = &mut ctx.accounts.auction;\n    let clock = Clock::get()?;\n\n    require!(clock.unix_timestamp < auction.end_time, AuctionError::Ended);\n    require!(amount > auction.highest_bid, AuctionError::BidTooLow);\n\n    auction.bids.push(Bid {\n        bidder: ctx.accounts.bidder.key(),\n        amount,\n        timestamp: clock.unix_timestamp,\n    });\n    \n    auction.highest_bid = amount;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV10 - Denial of Service\nHIGH\nUnbounded Vec growth for bids. Each bid permanently increases storage. Attack: place many minimum-increment bids to grow the Vec until account reallocation fails or future operations on the auction exceed compute budget. Should only track current highest bid or limit bid history.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_settle_position(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let market_info = next_account_info(account_info_iter)?;\n    let position_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let user_token_info = next_account_info(account_info_iter)?;\n    let vault_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let market = Market::unpack(&market_info.data.borrow())?;\n    let mut position = Position::unpack(&position_info.data.borrow())?;\n\n    if !market.is_settled {\n        return Err(MarketError::NotSettled.into());\n    }\n    if position.owner != *user_info.key {\n        return Err(MarketError::InvalidOwner.into());\n    }\n    if position.is_settled {\n        return Err(MarketError::AlreadySettled.into());\n    }\n\n    let pnl = calculate_settlement_pnl(&position, market.settlement_price)?;\n    \n    position.is_settled = true;\n    Position::pack(position, &mut position_info.data.borrow_mut())?;\n\n    if pnl > 0 {\n        transfer_pnl(vault_info, user_token_info, pnl as u64, token_program)?;\n    }\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nIndividual settlement: each user settles their own position. Market settlement (setting is_settled flag) is separate from position settlements. No iteration over positions. Market can handle unlimited positions because settlement is O(1) per position.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_burn(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n\n    // Missing: validate_owner for source_account.owner or delegate\n    // Anyone can burn tokens from any account\n    \n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_sub(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nCRITICAL\nThe burn function does not validate that authority_info is the account owner or an authorized delegate. An attacker can burn any user's tokens, destroying their holdings without permission.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for Denial of Service (DoS) vulnerabilities.\n\nCode:\npub fn process_claim_reward(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n    let user_reward_info = next_account_info(account_info_iter)?;\n    let reward_vault = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let pool = Pool::unpack(&pool_info.data.borrow())?;\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    if user_stake.owner != *user_info.key {\n        return Err(StakingError::InvalidOwner.into());\n    }\n\n    let pending = calculate_pending_rewards(&user_stake, &pool)?;\n    \n    if pending == 0 {\n        return Err(StakingError::NoRewards.into());\n    }\n\n    user_stake.reward_debt = user_stake.amount\n        .checked_mul(pool.acc_reward_per_share)?\n        .checked_div(PRECISION)?;\n    user_stake.last_claim = Clock::get()?.unix_timestamp;\n    \n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n\n    transfer_reward(reward_vault, user_reward_info, pending, token_program)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV10 - Denial of Service - MITIGATED\nPull-payment pattern: each user claims their own rewards individually. No iteration over users, no mass operations. User A's claim cannot affect User B. Compute cost is constant regardless of total stakers. Protocol scales to unlimited users.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "DoS",
    "owasp_code": "V10"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_burn(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let mint_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut source_account = Account::unpack(&source_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    if source_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if source_account.is_native() {\n        return Err(TokenError::NativeNotSupported.into());\n    }\n    if source_account.amount < amount {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    if !Self::cmp_pubkeys(mint_info.key, &source_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    match source_account.delegate {\n        COption::Some(ref delegate) if Self::cmp_pubkeys(authority_info.key, delegate) => {\n            Self::validate_owner(program_id, delegate, authority_info, account_info_iter.as_slice())?;\n            if source_account.delegated_amount < amount {\n                return Err(TokenError::InsufficientFunds.into());\n            }\n            source_account.delegated_amount = source_account.delegated_amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n        }\n        _ => Self::validate_owner(program_id, &source_account.owner, authority_info, account_info_iter.as_slice())?,\n    }\n\n    source_account.amount = source_account.amount.checked_sub(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_sub(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(source_account, &mut source_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV1 - Access Control - MITIGATED\nThe burn function validates authority through validate_owner, supporting both owner and delegate burning. It checks frozen status, native token restrictions, sufficient funds, mint consistency, and delegate allowance before burning.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_deposit_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    deposit_lamports: u64,\n    minimum_pool_tokens_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let from_user_lamports = next_account_info(account_info_iter)?;\n    let dest_user_pool = next_account_info(account_info_iter)?;\n    let manager_fee_info = next_account_info(account_info_iter)?;\n    let referrer_fee_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let system_program_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    \n    let new_pool_tokens = stake_pool.calc_pool_tokens_for_deposit(deposit_lamports)?;\n    let pool_tokens_fee = stake_pool.calc_pool_tokens_sol_deposit_fee(new_pool_tokens)?;\n    let pool_tokens_user = new_pool_tokens.checked_sub(pool_tokens_fee)?;\n\n    if pool_tokens_user == 0 {\n        return Err(StakePoolError::DepositTooSmall.into());\n    }\n    if let Some(minimum_pool_tokens_out) = minimum_pool_tokens_out {\n        if pool_tokens_user < minimum_pool_tokens_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    stake_pool.pool_token_supply = stake_pool.pool_token_supply\n        .checked_add(new_pool_tokens)?;\n    stake_pool.total_lamports = stake_pool.total_lamports\n        .checked_add(deposit_lamports)?;\n    StakePool::pack(stake_pool, &mut stake_pool_info.data.borrow_mut())?;\n\n    Self::sol_transfer(from_user_lamports.clone(), reserve_stake_info.clone(), deposit_lamports)?;\n\n    Self::token_mint_to(\n        stake_pool_info.key,\n        token_program_info.clone(),\n        pool_mint_info.clone(),\n        dest_user_pool.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        pool_tokens_user,\n    )?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nCorrect CEI pattern implementation. State updates (pool_token_supply, total_lamports) happen BEFORE any CPIs (sol_transfer, token_mint_to). Even if an attacker triggers a callback during the mint operation, the pool state already reflects the new deposit, preventing any manipulation.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn calculate_pool_tokens(\n    deposit_lamports: u64,\n    total_lamports: u64,\n    pool_token_supply: u64,\n) -> Result<u64, ProgramError> {\n    if total_lamports == 0 || pool_token_supply == 0 {\n        return Ok(deposit_lamports);\n    }\n    \n    let pool_tokens = (deposit_lamports as u128)\n        .checked_mul(pool_token_supply as u128)\n        .ok_or(StakePoolError::CalculationFailure)?\n        .checked_div(total_lamports as u128)\n        .ok_or(StakePoolError::CalculationFailure)? as u64;\n    \n    Ok(pool_tokens)\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow - MITIGATED\nThe calculation uses u128 intermediate type to handle the multiplication before division. checked_mul and checked_div ensure any overflow is caught. This pattern from SPL Stake Pool safely handles large values without wraparound.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\npub fn process_claim_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    user_bump: u8,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let reward_vault = next_account_info(account_info_iter)?;\n\n    let expected_user_stake = Pubkey::create_program_address(\n        &[\n            b\"user_stake\",\n            pool_info.key.as_ref(),\n            user_info.key.as_ref(),\n            &[user_bump],\n        ],\n        program_id,\n    )?;\n\n    if *user_stake_info.key != expected_user_stake {\n        return Err(StakingError::InvalidUserStake.into());\n    }\n\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    let rewards = calculate_pending_rewards(&user_stake)?;\n    \n    user_stake.last_claim = Clock::get()?.unix_timestamp;\n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV9 - Bump Seed Canonicalization\nHIGH\nUser-provided bump for user_stake PDA verification. An attacker could claim rewards using a non-canonical bump, potentially creating multiple stake accounts for the same user and double-claiming rewards across different PDA instances.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_close_account(program_id: &Pubkey, accounts: &[AccountInfo]) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_account_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let source_account = Account::unpack(&source_account_info.data.borrow())?;\n    \n    if source_account.amount != 0 {\n        return Err(TokenError::NonNativeHasBalance.into());\n    }\n\n    // Missing owner/close_authority validation\n    // Any signer can close any empty account\n    \n    let destination_starting_lamports = destination_account_info.lamports();\n    **destination_account_info.lamports.borrow_mut() = destination_starting_lamports\n        .checked_add(source_account_info.lamports())\n        .ok_or(TokenError::Overflow)?;\n\n    **source_account_info.lamports.borrow_mut() = 0;\n    delete_account(source_account_info)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nHIGH\nThe close_account function does not verify that authority_info is the account owner or designated close_authority. Any user can close empty token accounts and receive the rent lamports.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_redeem_nft(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let nft_mint_info = next_account_info(account_info_iter)?;\n    let nft_token_account = next_account_info(account_info_iter)?;\n    let pool_token_vault = next_account_info(account_info_iter)?;\n    let user_token_account = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = NFTPool::unpack(&pool_info.data.borrow())?;\n    \n    let nft_account = Account::unpack(&nft_token_account.data.borrow())?;\n    if nft_account.amount != 1 || nft_account.owner != *user_authority.key {\n        return Err(NFTError::InvalidNFTOwnership.into());\n    }\n\n    let redemption_value = pool.floor_price;\n\n    let seeds = &[b\"pool_authority\", pool_info.key.as_ref(), &[pool.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_token_vault.key,\n        user_token_account.key,\n        pool_authority.key,\n        &[],\n        redemption_value,\n    )?;\n    invoke_signed(&transfer_ix, &[pool_token_vault.clone(), user_token_account.clone(), pool_authority.clone()], signer)?;\n\n    let burn_ix = spl_token::instruction::burn(\n        token_program.key,\n        nft_token_account.key,\n        nft_mint_info.key,\n        user_authority.key,\n        &[],\n        1,\n    )?;\n    invoke(&burn_ix, &[nft_token_account.clone(), nft_mint_info.clone(), user_authority.clone()])?;\n\n    pool.total_redeemed = pool.total_redeemed.checked_add(1).ok_or(NFTError::MathOverflow)?;\n    pool.total_value_redeemed = pool.total_value_redeemed.checked_add(redemption_value)\n        .ok_or(NFTError::MathOverflow)?;\n    \n    NFTPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nHIGH\nThe redemption value transfer happens before burning the NFT. During the transfer callback, the attacker can call redeem_nft() again. Since the NFT hasn't been burned yet, ownership validation passes, allowing multiple redemptions of the same NFT until the pool vault is drained.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    let user_balance = vault.get_user_balance(user_info.key)?;\n    \n    let new_balance = user_balance\n        .checked_sub(amount)\n        .ok_or(VaultError::InsufficientBalance)?;\n    vault.set_user_balance(user_info.key, new_balance)?;\n    \n    vault.total_deposited = vault.total_deposited\n        .checked_sub(amount)\n        .ok_or(VaultError::CalculationFailure)?;\n    \n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Underflow - MITIGATED\nBoth subtractions use checked_sub() which returns None on underflow. The user balance check prevents insufficient funds, and total_deposited is also protected. Any underflow attempt results in a clear error rather than silent wraparound.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_transfer_with_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_info = next_account_info(account_info_iter)?;\n    let dest_info = next_account_info(account_info_iter)?;\n    let fee_info = next_account_info(account_info_iter)?;\n\n    let mut source = TokenAccount::unpack(&source_info.data.borrow())?;\n    let mut dest = TokenAccount::unpack(&dest_info.data.borrow())?;\n    let mut fee_account = TokenAccount::unpack(&fee_info.data.borrow())?;\n    \n    let fee = amount.checked_div(100).unwrap_or(0);\n    let total_deduction = amount\n        .checked_add(fee)\n        .ok_or(TokenError::Overflow)?;\n    \n    source.balance = source.balance\n        .checked_sub(total_deduction)\n        .ok_or(TokenError::InsufficientFunds)?;\n    dest.balance = dest.balance\n        .checked_add(amount)\n        .ok_or(TokenError::Overflow)?;\n    fee_account.balance = fee_account.balance\n        .checked_add(fee)\n        .ok_or(TokenError::Overflow)?;\n    \n    TokenAccount::pack(source, &mut source_info.data.borrow_mut())?;\n    TokenAccount::pack(dest, &mut dest_info.data.borrow_mut())?;\n    TokenAccount::pack(fee_account, &mut fee_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow - MITIGATED\nAll arithmetic operations use checked methods: checked_div for fee calculation, checked_add for total deduction and balance increases, checked_sub for source deduction. Any overflow or underflow returns an error instead of corrupting state.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn calculate_rewards(\n    staked_amount: u64,\n    reward_rate: u64,\n    time_elapsed: u64,\n) -> Result<u64, ProgramError> {\n    let numerator = (staked_amount as u128)\n        .checked_mul(reward_rate as u128)\n        .and_then(|v| v.checked_mul(time_elapsed as u128))\n        .ok_or(ProgramError::ArithmeticOverflow)?;\n    \n    let rewards = (numerator / SECONDS_PER_YEAR as u128) as u64;\n    Ok(rewards)\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow - MITIGATED\nThe calculation uses u128 intermediate values to prevent overflow during multiplication. checked_mul() is chained with and_then() for safe multiplication. The final division and cast to u64 happens after the multiplication chain, ensuring correct results for realistic stake amounts.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn calculate_swap_output(\n    amount_in: u64,\n    reserve_in: u64,\n    reserve_out: u64,\n    fee_numerator: u64,\n    fee_denominator: u64,\n) -> Result<u64, ProgramError> {\n    if reserve_in == 0 || reserve_out == 0 {\n        return Err(SwapError::EmptyPool.into());\n    }\n    \n    let amount_in_with_fee = amount_in * (fee_denominator - fee_numerator);\n    let numerator = amount_in_with_fee * reserve_out;\n    let denominator = reserve_in * fee_denominator + amount_in_with_fee;\n    \n    let amount_out = numerator / denominator;\n    Ok(amount_out)\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nCRITICAL\nMultiple overflow points in AMM calculation: (1) amount_in * (fee_denominator - fee_numerator) can overflow. (2) amount_in_with_fee * reserve_out will overflow for large swaps. (3) reserve_in * fee_denominator + amount_in_with_fee can overflow. These can cause incorrect swap amounts or division by zero after wrap.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_swap(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount_in: u64,\n    minimum_amount_out: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let pool_token_a = next_account_info(account_info_iter)?;\n    let pool_token_b = next_account_info(account_info_iter)?;\n    let user_token_a = next_account_info(account_info_iter)?;\n    let user_token_b = next_account_info(account_info_iter)?;\n    let user_authority = next_account_info(account_info_iter)?;\n    let pool_authority = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut pool = LiquidityPool::unpack(&pool_info.data.borrow())?;\n    \n    let amount_out = calculate_swap_output(amount_in, pool.token_a_balance, pool.token_b_balance)?;\n    \n    require!(amount_out >= minimum_amount_out, SwapError::SlippageExceeded);\n\n    pool.token_a_balance = pool.token_a_balance.checked_add(amount_in)?;\n    pool.token_b_balance = pool.token_b_balance.checked_sub(amount_out)?;\n    LiquidityPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n\n    let transfer_in_ix = spl_token::instruction::transfer(\n        token_program.key,\n        user_token_a.key,\n        pool_token_a.key,\n        user_authority.key,\n        &[],\n        amount_in,\n    )?;\n    invoke(&transfer_in_ix, &[user_token_a.clone(), pool_token_a.clone(), user_authority.clone()])?;\n\n    let seeds = &[b\"pool\", pool.token_a_mint.as_ref(), pool.token_b_mint.as_ref(), &[pool.bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_out_ix = spl_token::instruction::transfer(\n        token_program.key,\n        pool_token_b.key,\n        user_token_b.key,\n        pool_authority.key,\n        &[],\n        amount_out,\n    )?;\n    invoke_signed(&transfer_out_ix, &[pool_token_b.clone(), user_token_b.clone(), pool_authority.clone()], signer)?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nProper CEI pattern: pool reserves (token_a_balance, token_b_balance) are updated BEFORE either transfer CPI. If an attacker attempts reentrancy during transfer callbacks, the swap calculation will use the already-updated reserves, yielding a correct (less favorable) exchange rate. No arbitrage opportunity exists.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_add_validator_to_pool(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    raw_validator_seed: u32,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let staker_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let stake_info = next_account_info(account_info_iter)?;\n    let validator_vote_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    stake_pool.check_staker(staker_info)?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let mut validator_list_data = validator_list_info.data.borrow_mut();\n    let (header, mut validator_list) = ValidatorListHeader::deserialize_vec(&mut validator_list_data)?;\n    \n    if header.max_validators == validator_list.len() {\n        return Err(ProgramError::AccountDataTooSmall);\n    }\n    if validator_list.len() >= MAX_VALIDATORS_IN_POOL {\n        return Err(StakePoolError::TooManyValidatorsInPool.into());\n    }\n    \n    let maybe_validator = validator_list.find::<ValidatorStakeInfo, _>(|x| {\n        ValidatorStakeInfo::memcmp_pubkey(x, validator_vote_info.key)\n    });\n    if maybe_validator.is_some() {\n        return Err(StakePoolError::ValidatorAlreadyAdded.into());\n    }\n\n    let (stake_address, _) = crate::find_stake_program_address(\n        program_id, validator_vote_info.key, stake_pool_info.key, NonZeroU32::new(raw_validator_seed)\n    );\n    if stake_address != *stake_info.key {\n        return Err(StakePoolError::InvalidStakeAccountAddress.into());\n    }\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function validates: staker authorization, epoch freshness, validator list capacity (both header and global max), duplicate validator prevention, and stake account address derivation verification. Comprehensive input validation prevents all common attack vectors.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_close_and_refund(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let account_to_close = next_account_info(account_info_iter)?;\n    let destination = next_account_info(account_info_iter)?;\n    let owner = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let account_data = Account::unpack(&account_to_close.data.borrow())?;\n    \n    if account_data.amount > 0 {\n        let transfer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            account_to_close.key,\n            destination.key,\n            owner.key,\n            &[],\n            account_data.amount,\n        )?;\n        invoke(&transfer_ix, &[account_to_close.clone(), destination.clone(), owner.clone()]);\n    }\n\n    let close_ix = spl_token::instruction::close_account(\n        token_program.key,\n        account_to_close.key,\n        destination.key,\n        owner.key,\n        &[],\n    )?;\n    invoke(&close_ix, &[account_to_close.clone(), destination.clone(), owner.clone()])?;\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nHIGH\nThe transfer invoke() inside the if block lacks error propagation, while close_account invoke() has it. If transfer fails (frozen account, destination doesn't exist), execution continues and the account gets closed anyway. User loses their token balance permanently as the account is destroyed without successful transfer.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_batch_transfer(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    transfers: Vec<TransferData>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut success_count = 0u32;\n    \n    for transfer in transfers.iter() {\n        let destination = find_account_by_key(accounts, &transfer.destination)?;\n        \n        let transfer_ix = spl_token::instruction::transfer(\n            token_program.key,\n            source_info.key,\n            destination.key,\n            authority_info.key,\n            &[],\n            transfer.amount,\n        )?;\n        \n        match invoke(&transfer_ix, &[source_info.clone(), destination.clone(), authority_info.clone()]) {\n            Ok(_) => success_count += 1,\n            Err(_) => continue,\n        }\n    }\n\n    msg!(\"Successful transfers: {}/{}\", success_count, transfers.len());\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nHIGH\nFailed transfers are silently swallowed with 'Err(_) => continue'. While success_count tracks successful transfers, there's no way to identify which specific transfers failed. Callers cannot distinguish between partial success and full success, leading to potential fund reconciliation issues.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_transfer_with_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_info = next_account_info(account_info_iter)?;\n    let dest_info = next_account_info(account_info_iter)?;\n    let fee_info = next_account_info(account_info_iter)?;\n\n    let mut source = TokenAccount::unpack(&source_info.data.borrow())?;\n    let mut dest = TokenAccount::unpack(&dest_info.data.borrow())?;\n    let mut fee_account = TokenAccount::unpack(&fee_info.data.borrow())?;\n    \n    let fee = amount / 100;\n    let total_deduction = amount + fee;\n    \n    if source.balance < total_deduction {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    \n    source.balance -= total_deduction;\n    dest.balance += amount;\n    fee_account.balance += fee;\n    \n    TokenAccount::pack(source, &mut source_info.data.borrow_mut())?;\n    TokenAccount::pack(dest, &mut dest_info.data.borrow_mut())?;\n    TokenAccount::pack(fee_account, &mut fee_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV8 - Integer Overflow\nCRITICAL\nMultiple overflow vulnerabilities: (1) amount + fee can overflow if amount is near u64::MAX, making the balance check pass incorrectly. (2) dest.balance += amount can overflow. (3) fee_account.balance += fee can overflow. All arithmetic operations use unchecked operators.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\npub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    if destination_account.is_frozen() {\n        return Err(TokenError::AccountFrozen.into());\n    }\n    if destination_account.is_native() {\n        return Err(TokenError::NativeNotSupported.into());\n    }\n    if !Self::cmp_pubkeys(mint_info.key, &destination_account.mint) {\n        return Err(TokenError::MintMismatch.into());\n    }\n\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n    if let Some(expected_decimals) = expected_decimals {\n        if expected_decimals != mint.decimals {\n            return Err(TokenError::MintDecimalsMismatch.into());\n        }\n    }\n\n    match mint.mint_authority {\n        COption::Some(mint_authority) => Self::validate_owner(\n            program_id, &mint_authority, owner_info, account_info_iter.as_slice()\n        )?,\n        COption::None => return Err(TokenError::FixedSupply.into()),\n    }\n\n    if amount == 0 {\n        Self::check_account_owner(program_id, mint_info)?;\n        Self::check_account_owner(program_id, destination_account_info)?;\n    }\n\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function validates: frozen status, native token restriction, mint-account consistency, optional decimals verification, fixed supply handling, and zero-amount with ownership verification. Checked arithmetic prevents overflow.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_claim_vested(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vesting_info = next_account_info(account_info_iter)?;\n    let vesting_vault = next_account_info(account_info_iter)?;\n    let beneficiary_token = next_account_info(account_info_iter)?;\n    let beneficiary = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let vesting = VestingSchedule::unpack(&vesting_info.data.borrow())?;\n    \n    if vesting.beneficiary != *beneficiary.key {\n        return Err(VestingError::InvalidBeneficiary.into());\n    }\n\n    let current_time = Clock::get()?.unix_timestamp;\n    let vested_amount = calculate_vested_amount(&vesting, current_time)?;\n    let claimable = vested_amount.checked_sub(vesting.claimed_amount)\n        .ok_or(VestingError::MathOverflow)?;\n    \n    if claimable == 0 {\n        return Err(VestingError::NothingToClaim.into());\n    }\n\n    let seeds = &[b\"authority\", vesting_info.key.as_ref(), &[vesting.authority_bump]];\n    let signer = &[&seeds[..]];\n    \n    let transfer_ix = spl_token::instruction::transfer(\n        token_program.key,\n        vesting_vault.key,\n        beneficiary_token.key,\n        authority_info.key,\n        &[],\n        claimable,\n    )?;\n    invoke_signed(&transfer_ix, &[vesting_vault.clone(), beneficiary_token.clone(), authority_info.clone()], signer)?;\n\n    let mut vesting_mut = VestingSchedule::unpack(&vesting_info.data.borrow())?;\n    vesting_mut.claimed_amount = vesting_mut.claimed_amount.checked_add(claimable)\n        .ok_or(VestingError::MathOverflow)?;\n    vesting_mut.last_claim_timestamp = current_time;\n    \n    VestingSchedule::pack(vesting_mut, &mut vesting_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV5 - Reentrancy Attacks\nHIGH\nThe vested token transfer executes before updating claimed_amount. An attacker controlling beneficiary_token can callback into claim_vested(). Since claimed_amount hasn't been updated, calculate_vested_amount() returns the same claimable value, allowing the beneficiary to claim their entire vesting allocation in one transaction.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_deposit_sol(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    deposit_lamports: u64,\n    minimum_pool_tokens_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let reserve_stake_info = next_account_info(account_info_iter)?;\n    let from_user_info = next_account_info(account_info_iter)?;\n    let dest_user_pool_info = next_account_info(account_info_iter)?;\n    let manager_fee_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    if stake_pool.last_update_epoch < clock.epoch {\n        return Err(StakePoolError::StakeListAndPoolOutOfDate.into());\n    }\n\n    let new_pool_tokens = stake_pool.calc_pool_tokens_for_deposit(deposit_lamports)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let pool_tokens_sol_deposit_fee = stake_pool\n        .calc_pool_tokens_sol_deposit_fee(new_pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    let pool_tokens_user = new_pool_tokens\n        .checked_sub(pool_tokens_sol_deposit_fee)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    if pool_tokens_user == 0 {\n        return Err(StakePoolError::DepositTooSmall.into());\n    }\n\n    if let Some(minimum_pool_tokens_out) = minimum_pool_tokens_out {\n        if pool_tokens_user < minimum_pool_tokens_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV4 - Input Validation - MITIGATED\nThe function implements proper input validation: epoch freshness check prevents stale state attacks, minimum output check (pool_tokens_user == 0) prevents dust deposits, and slippage protection via minimum_pool_tokens_out prevents sandwich attacks.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for bump seed canonicalization vulnerabilities.\n\nCode:\n#[derive(Accounts)]\n#[instruction(pool_seed: [u8; 32])]\npub struct CreatePool<'info> {\n    #[account(\n        init,\n        payer = creator,\n        space = 8 + Pool::LEN,\n        seeds = [b\"pool\", pool_seed.as_ref()],\n        bump,\n    )]\n    pub pool: Account<'info, Pool>,\n    #[account(\n        seeds = [b\"pool_authority\", pool.key().as_ref()],\n        bump,\n    )]\n    pub pool_authority: AccountInfo<'info>,\n    #[account(mut)]\n    pub creator: Signer<'info>,\n    pub system_program: Program<'info, System>,\n}\n\npub fn create_pool(ctx: Context<CreatePool>, pool_seed: [u8; 32]) -> Result<()> {\n    let pool = &mut ctx.accounts.pool;\n    pool.seed = pool_seed;\n    pool.creator = ctx.accounts.creator.key();\n    pool.pool_bump = ctx.bumps.pool;\n    pool.authority_bump = ctx.bumps.pool_authority;\n    pool.total_deposited = 0;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV9 - Bump Seed Canonicalization - MITIGATED\nAnchor derives canonical bumps for both pool and pool_authority PDAs via seeds constraints with 'bump' (unspecified value). ctx.bumps provides canonical bumps which are stored (pool_bump, authority_bump) for future verification. No user-provided bumps are accepted.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Bump Seed",
    "owasp_code": "V9"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_cast_vote(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    voter_weight: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let proposal_info = next_account_info(account_info_iter)?;\n    let voter_record_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    let mut voter_record = VoterRecord::unpack(&voter_record_info.data.borrow())?;\n    \n    proposal.yes_votes = proposal.yes_votes\n        .checked_add(voter_weight)\n        .unwrap();\n    voter_record.unrelinquished_votes_count = voter_record\n        .unrelinquished_votes_count\n        .checked_add(1)\n        .unwrap();\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    VoterRecord::pack(voter_record, &mut voter_record_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow - MITIGATED\nBoth additions use checked_add().unwrap(). This matches the SPL Governance pattern where overflow is theoretically possible but practically impossible (would require more votes than total token supply). The unwrap() causes a clean panic rather than silent corruption.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn calculate_swap_output(\n    amount_in: u64,\n    reserve_in: u64,\n    reserve_out: u64,\n    fee_numerator: u64,\n    fee_denominator: u64,\n) -> Result<u64, ProgramError> {\n    if reserve_in == 0 || reserve_out == 0 || fee_denominator == 0 {\n        return Err(SwapError::InvalidInput.into());\n    }\n    \n    let fee_adjusted = fee_denominator\n        .checked_sub(fee_numerator)\n        .ok_or(SwapError::InvalidFee)?;\n    \n    let amount_in_with_fee = (amount_in as u128)\n        .checked_mul(fee_adjusted as u128)\n        .ok_or(SwapError::Overflow)?;\n    \n    let numerator = amount_in_with_fee\n        .checked_mul(reserve_out as u128)\n        .ok_or(SwapError::Overflow)?;\n    \n    let denominator = (reserve_in as u128)\n        .checked_mul(fee_denominator as u128)\n        .ok_or(SwapError::Overflow)?\n        .checked_add(amount_in_with_fee)\n        .ok_or(SwapError::Overflow)?;\n    \n    let amount_out = numerator\n        .checked_div(denominator)\n        .ok_or(SwapError::DivisionByZero)? as u64;\n    \n    Ok(amount_out)\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Overflow - MITIGATED\nThe AMM calculation uses u128 intermediates and checked arithmetic throughout. Input validation prevents division by zero. Each multiplication and addition is checked, with early return on any overflow. This pattern safely handles large swap amounts.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_liquidate_and_seize(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    repay_amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let obligation_info = next_account_info(account_info_iter)?;\n    let repay_reserve = next_account_info(account_info_iter)?;\n    let collateral_reserve = next_account_info(account_info_iter)?;\n    let liquidator_repay = next_account_info(account_info_iter)?;\n    let liquidator_receive = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n    let token_program = next_account_info(account_info_iter)?;\n\n    let mut obligation = Obligation::unpack(&obligation_info.data.borrow())?;\n    let collateral_to_seize = calculate_liquidation_amount(repay_amount)?;\n\n    let repay_ix = spl_token::instruction::transfer(\n        token_program.key,\n        liquidator_repay.key,\n        repay_reserve.key,\n        authority_info.key,\n        &[],\n        repay_amount,\n    )?;\n    invoke(&repay_ix, &[liquidator_repay.clone(), repay_reserve.clone(), authority_info.clone()]);\n\n    let seize_ix = spl_token::instruction::transfer(\n        token_program.key,\n        collateral_reserve.key,\n        liquidator_receive.key,\n        authority_info.key,\n        &[],\n        collateral_to_seize,\n    )?;\n    invoke(&seize_ix, &[collateral_reserve.clone(), liquidator_receive.clone(), authority_info.clone()]);\n\n    obligation.borrowed_amount -= repay_amount;\n    obligation.collateral_amount -= collateral_to_seize;\n    Obligation::pack(obligation, &mut obligation_info.data.borrow_mut())?;\n    \n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nCRITICAL\nBoth invoke() calls lack error propagation. Critical failure modes: (1) If repay fails but seize succeeds, liquidator receives collateral without paying. (2) If repay succeeds but seize fails, liquidator pays but receives nothing. (3) Both fail but obligation state is still updated, corrupting the lending protocol.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.\n\nCode:\npub fn process_cancel_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n\n    let mut governance_data = Governance::unpack(&governance_info.data.borrow())?;\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    \n    proposal.state = ProposalState::Cancelled;\n    governance_data.active_proposal_count = governance_data\n        .active_proposal_count\n        .saturating_sub(1);\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    Governance::pack(governance_data, &mut governance_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV8 - Integer Underflow - MITIGATED\nThe counter decrement uses saturating_sub(1) which returns 0 if underflow would occur instead of wrapping. This is the pattern used in SPL Governance for counter decrements where the exact count is less critical than preventing wraparound.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Integer Flow",
    "owasp_code": "V8"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for CPI reentrancy vulnerabilities.\n\nCode:\npub fn process_withdraw_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n    minimum_lamports_out: Option<u64>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let validator_list_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let stake_split_from = next_account_info(account_info_iter)?;\n    let stake_split_to = next_account_info(account_info_iter)?;\n    let user_stake_authority = next_account_info(account_info_iter)?;\n    let user_transfer_authority = next_account_info(account_info_iter)?;\n    let burn_from_pool_info = next_account_info(account_info_iter)?;\n    let manager_fee_info = next_account_info(account_info_iter)?;\n    let pool_mint_info = next_account_info(account_info_iter)?;\n    let token_program_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let mut stake_pool = StakePool::unpack(&stake_pool_info.data.borrow())?;\n    stake_pool.check_authority_withdraw(withdraw_authority_info.key, program_id, stake_pool_info.key)?;\n\n    let pool_tokens_fee = stake_pool.calc_pool_tokens_stake_withdrawal_fee(pool_tokens)?;\n    let pool_tokens_burnt = pool_tokens.checked_sub(pool_tokens_fee)?;\n    let withdraw_lamports = stake_pool.calc_lamports_withdraw_amount(pool_tokens_burnt)?;\n\n    if let Some(minimum_lamports_out) = minimum_lamports_out {\n        if withdraw_lamports < minimum_lamports_out {\n            return Err(StakePoolError::ExceededSlippage.into());\n        }\n    }\n\n    Self::token_burn(\n        token_program_info.clone(),\n        burn_from_pool_info.clone(),\n        pool_mint_info.clone(),\n        user_transfer_authority.clone(),\n        pool_tokens_burnt,\n    )?;\n\n    Self::stake_split(\n        stake_pool_info.key,\n        stake_split_from.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        withdraw_lamports,\n        stake_split_to.clone(),\n    )?;\n\n    Self::stake_authorize_signed(\n        stake_pool_info.key,\n        stake_split_to.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        user_stake_authority.key,\n        clock_info.clone(),\n    )?;\n\n    stake_pool.pool_token_supply = stake_pool.pool_token_supply\n        .checked_sub(pool_tokens_burnt)?;\n    stake_pool.total_lamports = stake_pool.total_lamports\n        .checked_sub(withdraw_lamports)?;\n    \n    StakePool::pack(stake_pool, &mut stake_pool_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV5 - Reentrancy Attacks - MITIGATED\nThe function correctly follows the CEI pattern with a crucial twist: it burns pool tokens FIRST via CPI. This destroys the user's withdrawal authorization before any value transfer. Even if an attacker attempts reentrancy during stake_split, they no longer have pool tokens to initiate another withdrawal.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "CPI",
    "owasp_code": "V5"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\nfn token_mint_to<'a>(\n    stake_pool: &Pubkey,\n    token_program: AccountInfo<'a>,\n    mint: AccountInfo<'a>,\n    destination: AccountInfo<'a>,\n    authority: AccountInfo<'a>,\n    authority_type: &[u8],\n    bump_seed: u8,\n    amount: u64,\n) -> Result<(), ProgramError> {\n    let authority_signature_seeds = [stake_pool.as_ref(), authority_type, &[bump_seed]];\n    let signers = &[&authority_signature_seeds[..]];\n\n    let ix = spl_token::instruction::mint_to(\n        token_program.key,\n        mint.key,\n        destination.key,\n        authority.key,\n        &[],\n        amount,\n    )?;\n\n    invoke_signed(&ix, &[mint, destination, authority], signers)\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV6 - Unchecked External Calls\nHIGH\nThe invoke_signed() result is returned directly without error checking. While this appears to propagate the error, if used in a context where the return value is ignored (common in helper functions), mint failures will be silent. The function should explicitly use ? to ensure error propagation.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_set_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    new_fee_numerator: u64,\n    new_fee_denominator: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let manager_info = next_account_info(account_info_iter)?;\n\n    let mut stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    stake_pool.check_manager(manager_info)?;\n\n    \n    stake_pool.epoch_fee.numerator = new_fee_numerator;\n    stake_pool.epoch_fee.denominator = new_fee_denominator;\n\n    borsh::to_writer(&mut stake_pool_info.data.borrow_mut()[..], &stake_pool)?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nCRITICAL\nThe set_fee function has critical validation gaps: no check for denominator being zero (causing division by zero), no check that numerator <= denominator (allowing fees > 100%), and no rate limiting on fee increases (sudden fee spikes could drain users).<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for access control vulnerabilities.\n\nCode:\npub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    // Missing mint_authority validation\n    // Should check: mint.mint_authority matches owner_info\n    \n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV1 - Access Control\nCRITICAL\nThe mint_to function does not verify that owner_info matches the mint's mint_authority. Anyone can mint unlimited tokens, causing severe inflation and destroying the token's value.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Missing Key Check",
    "owasp_code": "V1"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for unchecked external call vulnerabilities.\n\nCode:\npub fn process_stake_delegate<'a>(\n    stake_info: AccountInfo<'a>,\n    vote_account_info: AccountInfo<'a>,\n    clock_info: AccountInfo<'a>,\n    stake_history_info: AccountInfo<'a>,\n    stake_config_info: AccountInfo<'a>,\n    authority_info: AccountInfo<'a>,\n    stake_pool: &Pubkey,\n    authority_type: &[u8],\n    bump_seed: u8,\n) -> Result<(), ProgramError> {\n    let authority_signature_seeds = [stake_pool.as_ref(), authority_type, &[bump_seed]];\n    let signers = &[&authority_signature_seeds[..]];\n\n    let ix = stake::instruction::delegate_stake(\n        stake_info.key,\n        authority_info.key,\n        vote_account_info.key,\n    );\n\n    invoke_signed(\n        &ix,\n        &[\n            stake_info,\n            vote_account_info,\n            clock_info,\n            stake_history_info,\n            stake_config_info,\n            authority_info,\n        ],\n        signers,\n    )?;\n    \n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSAFE\nV6 - Unchecked External Calls - MITIGATED\nThe invoke_signed() call properly uses ? for error propagation. Any delegation failure (invalid vote account, stake already delegated, wrong authority) will return an error immediately. The calling function will be aware of the failure and can handle it appropriately.<|eot_id|>",
    "label": "SAFE",
    "vulnerability_type": "Unchecked Calls",
    "owasp_code": "V6"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\nfn process_withdraw_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    pool_tokens: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let stake_pool_info = next_account_info(account_info_iter)?;\n    let withdraw_authority_info = next_account_info(account_info_iter)?;\n    let stake_split_from = next_account_info(account_info_iter)?;\n    let stake_split_to = next_account_info(account_info_iter)?;\n    let user_transfer_authority_info = next_account_info(account_info_iter)?;\n\n    let stake_pool = try_from_slice_unchecked::<StakePool>(&stake_pool_info.data.borrow())?;\n    \n    \n    let withdraw_lamports = stake_pool.calc_lamports_withdraw_amount(pool_tokens)\n        .ok_or(StakePoolError::CalculationFailure)?;\n\n    Self::stake_split(\n        stake_pool_info.key,\n        stake_split_from.clone(),\n        withdraw_authority_info.clone(),\n        AUTHORITY_WITHDRAW,\n        stake_pool.stake_withdraw_bump_seed,\n        withdraw_lamports,\n        stake_split_to.clone(),\n    )?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nHIGH\nThe withdrawal function lacks critical input validation: no check for zero pool_tokens, no minimum withdrawal threshold, and no slippage protection. Users could lose value to sandwich attacks or receive dust amounts after fees.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  },
  {
    "text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze code for vulnerabilities according to OWASP Top 10 for Blockchain. Respond with the vulnerability status and details.<|eot_id|><|start_header_id|>user<|end_header_id|>\n\nYou are a Solana smart contract security analyzer. Analyze the following Rust code for input validation vulnerabilities.\n\nCode:\npub fn process_mint_to(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n    expected_decimals: Option<u8>,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let mint_info = next_account_info(account_info_iter)?;\n    let destination_account_info = next_account_info(account_info_iter)?;\n    let owner_info = next_account_info(account_info_iter)?;\n\n    let mut destination_account = Account::unpack(&destination_account_info.data.borrow())?;\n    let mut mint = Mint::unpack(&mint_info.data.borrow())?;\n\n    // expected_decimals not validated against mint\n\n    match mint.mint_authority {\n        COption::Some(mint_authority) => Self::validate_owner(\n            program_id, &mint_authority, owner_info, account_info_iter.as_slice()\n        )?,\n        COption::None => return Err(TokenError::FixedSupply.into()),\n    }\n\n    destination_account.amount = destination_account.amount.checked_add(amount).ok_or(TokenError::Overflow)?;\n    mint.supply = mint.supply.checked_add(amount).ok_or(TokenError::Overflow)?;\n\n    Account::pack(destination_account, &mut destination_account_info.data.borrow_mut())?;\n    Mint::pack(mint, &mut mint_info.data.borrow_mut())?;\n    Ok(())\n}<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVULNERABLE\nV4 - Input Validation\nMEDIUM\nThe mint_to function does not validate that amount is non-zero, wasting compute for no-op operations. The optional expected_decimals parameter is not validated against the actual mint decimals when provided, which could lead to precision mismatches.<|eot_id|>",
    "label": "VULNERABLE",
    "vulnerability_type": "Type Confusion",
    "owasp_code": "V4"
  }
]
