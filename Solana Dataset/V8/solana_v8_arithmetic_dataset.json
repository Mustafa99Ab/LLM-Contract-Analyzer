[
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_add_to_balance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    if !authority_info.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let mut user_account = UserAccount::unpack(&user_account_info.data.borrow())?;\n    \n    user_account.balance += amount;\n    \n    UserAccount::pack(user_account, &mut user_account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nCRITICAL\nThe balance addition uses the += operator without overflow protection. In Rust release builds, integer overflow wraps around silently. If balance is near u64::MAX and amount is added, the balance wraps to a small value, potentially allowing attackers to manipulate account state or drain funds.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    let user_balance = vault.get_user_balance(user_info.key)?;\n    \n    if user_balance < amount {\n        return Err(VaultError::InsufficientBalance.into());\n    }\n    \n    let new_balance = user_balance - amount;\n    vault.set_user_balance(user_info.key, new_balance)?;\n    \n    vault.total_deposited -= amount;\n    \n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV8 - Integer Underflow\nHIGH\nWhile user_balance is checked before subtraction, total_deposited uses unchecked subtraction with -=. If total_deposited is somehow less than amount (due to rounding, fees, or state corruption), this will underflow and wrap to a large value, corrupting the vault's accounting.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn calculate_rewards(\n    staked_amount: u64,\n    reward_rate: u64,\n    time_elapsed: u64,\n) -> Result<u64, ProgramError> {\n    let rewards = staked_amount * reward_rate * time_elapsed / SECONDS_PER_YEAR;\n    Ok(rewards)\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nCRITICAL\nThe multiplication chain (staked_amount * reward_rate * time_elapsed) can easily overflow u64. For example: 1_000_000_000_000 * 1000 * 31536000 far exceeds u64::MAX. The result wraps to a small or zero value, causing users to receive incorrect (likely zero) rewards.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_transfer_with_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_info = next_account_info(account_info_iter)?;\n    let dest_info = next_account_info(account_info_iter)?;\n    let fee_info = next_account_info(account_info_iter)?;\n\n    let mut source = TokenAccount::unpack(&source_info.data.borrow())?;\n    let mut dest = TokenAccount::unpack(&dest_info.data.borrow())?;\n    let mut fee_account = TokenAccount::unpack(&fee_info.data.borrow())?;\n    \n    let fee = amount / 100;\n    let total_deduction = amount + fee;\n    \n    if source.balance < total_deduction {\n        return Err(TokenError::InsufficientFunds.into());\n    }\n    \n    source.balance -= total_deduction;\n    dest.balance += amount;\n    fee_account.balance += fee;\n    \n    TokenAccount::pack(source, &mut source_info.data.borrow_mut())?;\n    TokenAccount::pack(dest, &mut dest_info.data.borrow_mut())?;\n    TokenAccount::pack(fee_account, &mut fee_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nCRITICAL\nMultiple overflow vulnerabilities: (1) amount + fee can overflow if amount is near u64::MAX, making the balance check pass incorrectly. (2) dest.balance += amount can overflow. (3) fee_account.balance += fee can overflow. All arithmetic operations use unchecked operators.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_stake(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_stake_info = next_account_info(account_info_iter)?;\n\n    let mut pool = StakingPool::unpack(&pool_info.data.borrow())?;\n    let mut user_stake = UserStake::unpack(&user_stake_info.data.borrow())?;\n    \n    pool.total_staked += amount;\n    user_stake.staked_amount += amount;\n    user_stake.reward_debt = user_stake.staked_amount * pool.acc_reward_per_share / PRECISION;\n    \n    StakingPool::pack(pool, &mut pool_info.data.borrow_mut())?;\n    UserStake::pack(user_stake, &mut user_stake_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nHIGH\nThree overflow risks: (1) pool.total_staked += amount can overflow with many stakers. (2) user_stake.staked_amount += amount can overflow. (3) The reward_debt calculation multiplies staked_amount by acc_reward_per_share, which can overflow even before division. All use unchecked arithmetic.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn calculate_pool_tokens(\n    deposit_lamports: u64,\n    total_lamports: u64,\n    pool_token_supply: u64,\n) -> Result<u64, ProgramError> {\n    if total_lamports == 0 || pool_token_supply == 0 {\n        return Ok(deposit_lamports);\n    }\n    \n    let pool_tokens = deposit_lamports * pool_token_supply / total_lamports;\n    Ok(pool_tokens)\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nHIGH\nThe multiplication deposit_lamports * pool_token_supply can overflow before division. For a large stake pool with billions of lamports and tokens, this multiplication exceeds u64::MAX, wrapping to an incorrect small value and minting wrong token amounts to depositors.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_create_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_owner_record_info = next_account_info(account_info_iter)?;\n\n    let mut governance_data = Governance::unpack(&governance_info.data.borrow())?;\n    let mut proposal_owner_record = TokenOwnerRecord::unpack(&proposal_owner_record_info.data.borrow())?;\n    \n    proposal_owner_record.outstanding_proposal_count += 1;\n    governance_data.active_proposal_count += 1;\n    \n    TokenOwnerRecord::pack(proposal_owner_record, &mut proposal_owner_record_info.data.borrow_mut())?;\n    Governance::pack(governance_data, &mut governance_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nMEDIUM\nBoth counter increments use unchecked addition. While unlikely in practice, if outstanding_proposal_count or active_proposal_count reach u64::MAX and overflow, governance tracking becomes corrupted. The real SPL Governance uses checked_add().unwrap() for these counters.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn calculate_swap_output(\n    amount_in: u64,\n    reserve_in: u64,\n    reserve_out: u64,\n    fee_numerator: u64,\n    fee_denominator: u64,\n) -> Result<u64, ProgramError> {\n    if reserve_in == 0 || reserve_out == 0 {\n        return Err(SwapError::EmptyPool.into());\n    }\n    \n    let amount_in_with_fee = amount_in * (fee_denominator - fee_numerator);\n    let numerator = amount_in_with_fee * reserve_out;\n    let denominator = reserve_in * fee_denominator + amount_in_with_fee;\n    \n    let amount_out = numerator / denominator;\n    Ok(amount_out)\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nCRITICAL\nMultiple overflow points in AMM calculation: (1) amount_in * (fee_denominator - fee_numerator) can overflow. (2) amount_in_with_fee * reserve_out will overflow for large swaps. (3) reserve_in * fee_denominator + amount_in_with_fee can overflow. These can cause incorrect swap amounts or division by zero after wrap.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_cast_vote(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    voter_weight: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let proposal_info = next_account_info(account_info_iter)?;\n    let voter_record_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    let mut voter_record = VoterRecord::unpack(&voter_record_info.data.borrow())?;\n    \n    proposal.yes_votes += voter_weight;\n    voter_record.unrelinquished_votes_count += 1;\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    VoterRecord::pack(voter_record, &mut voter_record_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow\nMEDIUM\nBoth increments use unchecked arithmetic: (1) yes_votes += voter_weight can overflow if many high-weight voters participate. (2) unrelinquished_votes_count += 1 can overflow after billions of votes. The real SPL Governance uses checked_add().unwrap() to prevent this.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_claim_rewards(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let pool_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n    let clock = Clock::get()?;\n\n    let pool = StakingPool::unpack(&pool_info.data.borrow())?;\n    let mut user = UserStake::unpack(&user_info.data.borrow())?;\n    \n    let time_elapsed = clock.unix_timestamp - user.last_claim_timestamp;\n    let pending_rewards = user.staked_amount * pool.reward_rate * time_elapsed as u64 / PRECISION;\n    \n    user.claimed_rewards += pending_rewards;\n    user.last_claim_timestamp = clock.unix_timestamp;\n    \n    UserStake::pack(user, &mut user_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "VULNERABLE\nV8 - Integer Overflow/Underflow\nHIGH\nTwo issues: (1) clock.unix_timestamp - user.last_claim_timestamp can underflow if last_claim is somehow in the future (clock drift, manipulation). (2) The multiplication chain staked_amount * reward_rate * time_elapsed can easily overflow before division, resulting in incorrect rewards.",
    "label": "VULNERABLE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_add_to_balance(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let user_account_info = next_account_info(account_info_iter)?;\n    let authority_info = next_account_info(account_info_iter)?;\n\n    if !authority_info.is_signer {\n        return Err(ProgramError::MissingRequiredSignature);\n    }\n\n    let mut user_account = UserAccount::unpack(&user_account_info.data.borrow())?;\n    \n    user_account.balance = user_account.balance\n        .checked_add(amount)\n        .ok_or(ProgramError::ArithmeticOverflow)?;\n    \n    UserAccount::pack(user_account, &mut user_account_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV8 - Integer Overflow - MITIGATED\nThe balance addition uses checked_add() which returns None on overflow. The ok_or() converts this to an error, ensuring the transaction reverts instead of silently wrapping. No arithmetic corruption is possible.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_withdraw(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let vault_info = next_account_info(account_info_iter)?;\n    let user_info = next_account_info(account_info_iter)?;\n\n    let mut vault = Vault::unpack(&vault_info.data.borrow())?;\n    let user_balance = vault.get_user_balance(user_info.key)?;\n    \n    let new_balance = user_balance\n        .checked_sub(amount)\n        .ok_or(VaultError::InsufficientBalance)?;\n    vault.set_user_balance(user_info.key, new_balance)?;\n    \n    vault.total_deposited = vault.total_deposited\n        .checked_sub(amount)\n        .ok_or(VaultError::CalculationFailure)?;\n    \n    Vault::pack(vault, &mut vault_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV8 - Integer Underflow - MITIGATED\nBoth subtractions use checked_sub() which returns None on underflow. The user balance check prevents insufficient funds, and total_deposited is also protected. Any underflow attempt results in a clear error rather than silent wraparound.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn calculate_rewards(\n    staked_amount: u64,\n    reward_rate: u64,\n    time_elapsed: u64,\n) -> Result<u64, ProgramError> {\n    let numerator = (staked_amount as u128)\n        .checked_mul(reward_rate as u128)\n        .and_then(|v| v.checked_mul(time_elapsed as u128))\n        .ok_or(ProgramError::ArithmeticOverflow)?;\n    \n    let rewards = (numerator / SECONDS_PER_YEAR as u128) as u64;\n    Ok(rewards)\n}",
    "output": "SAFE\nV8 - Integer Overflow - MITIGATED\nThe calculation uses u128 intermediate values to prevent overflow during multiplication. checked_mul() is chained with and_then() for safe multiplication. The final division and cast to u64 happens after the multiplication chain, ensuring correct results for realistic stake amounts.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_transfer_with_fee(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    amount: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let source_info = next_account_info(account_info_iter)?;\n    let dest_info = next_account_info(account_info_iter)?;\n    let fee_info = next_account_info(account_info_iter)?;\n\n    let mut source = TokenAccount::unpack(&source_info.data.borrow())?;\n    let mut dest = TokenAccount::unpack(&dest_info.data.borrow())?;\n    let mut fee_account = TokenAccount::unpack(&fee_info.data.borrow())?;\n    \n    let fee = amount.checked_div(100).unwrap_or(0);\n    let total_deduction = amount\n        .checked_add(fee)\n        .ok_or(TokenError::Overflow)?;\n    \n    source.balance = source.balance\n        .checked_sub(total_deduction)\n        .ok_or(TokenError::InsufficientFunds)?;\n    dest.balance = dest.balance\n        .checked_add(amount)\n        .ok_or(TokenError::Overflow)?;\n    fee_account.balance = fee_account.balance\n        .checked_add(fee)\n        .ok_or(TokenError::Overflow)?;\n    \n    TokenAccount::pack(source, &mut source_info.data.borrow_mut())?;\n    TokenAccount::pack(dest, &mut dest_info.data.borrow_mut())?;\n    TokenAccount::pack(fee_account, &mut fee_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV8 - Integer Overflow - MITIGATED\nAll arithmetic operations use checked methods: checked_div for fee calculation, checked_add for total deduction and balance increases, checked_sub for source deduction. Any overflow or underflow returns an error instead of corrupting state.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn calculate_pool_tokens(\n    deposit_lamports: u64,\n    total_lamports: u64,\n    pool_token_supply: u64,\n) -> Result<u64, ProgramError> {\n    if total_lamports == 0 || pool_token_supply == 0 {\n        return Ok(deposit_lamports);\n    }\n    \n    let pool_tokens = (deposit_lamports as u128)\n        .checked_mul(pool_token_supply as u128)\n        .ok_or(StakePoolError::CalculationFailure)?\n        .checked_div(total_lamports as u128)\n        .ok_or(StakePoolError::CalculationFailure)? as u64;\n    \n    Ok(pool_tokens)\n}",
    "output": "SAFE\nV8 - Integer Overflow - MITIGATED\nThe calculation uses u128 intermediate type to handle the multiplication before division. checked_mul and checked_div ensure any overflow is caught. This pattern from SPL Stake Pool safely handles large values without wraparound.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_create_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_owner_record_info = next_account_info(account_info_iter)?;\n\n    let mut governance_data = Governance::unpack(&governance_info.data.borrow())?;\n    let mut proposal_owner_record = TokenOwnerRecord::unpack(&proposal_owner_record_info.data.borrow())?;\n    \n    proposal_owner_record.outstanding_proposal_count = proposal_owner_record\n        .outstanding_proposal_count\n        .checked_add(1)\n        .unwrap();\n    governance_data.active_proposal_count = governance_data\n        .active_proposal_count\n        .checked_add(1)\n        .unwrap();\n    \n    TokenOwnerRecord::pack(proposal_owner_record, &mut proposal_owner_record_info.data.borrow_mut())?;\n    Governance::pack(governance_data, &mut governance_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV8 - Integer Overflow - MITIGATED\nBoth counter increments use checked_add(1).unwrap(). This pattern from SPL Governance ensures overflow detection. The unwrap() is acceptable here because counter overflow is practically impossible (would require 2^64 proposals), and if it did occur, panic is the correct behavior.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_cancel_proposal(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let governance_info = next_account_info(account_info_iter)?;\n    let proposal_info = next_account_info(account_info_iter)?;\n\n    let mut governance_data = Governance::unpack(&governance_info.data.borrow())?;\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    \n    proposal.state = ProposalState::Cancelled;\n    governance_data.active_proposal_count = governance_data\n        .active_proposal_count\n        .saturating_sub(1);\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    Governance::pack(governance_data, &mut governance_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV8 - Integer Underflow - MITIGATED\nThe counter decrement uses saturating_sub(1) which returns 0 if underflow would occur instead of wrapping. This is the pattern used in SPL Governance for counter decrements where the exact count is less critical than preventing wraparound.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn calculate_swap_output(\n    amount_in: u64,\n    reserve_in: u64,\n    reserve_out: u64,\n    fee_numerator: u64,\n    fee_denominator: u64,\n) -> Result<u64, ProgramError> {\n    if reserve_in == 0 || reserve_out == 0 || fee_denominator == 0 {\n        return Err(SwapError::InvalidInput.into());\n    }\n    \n    let fee_adjusted = fee_denominator\n        .checked_sub(fee_numerator)\n        .ok_or(SwapError::InvalidFee)?;\n    \n    let amount_in_with_fee = (amount_in as u128)\n        .checked_mul(fee_adjusted as u128)\n        .ok_or(SwapError::Overflow)?;\n    \n    let numerator = amount_in_with_fee\n        .checked_mul(reserve_out as u128)\n        .ok_or(SwapError::Overflow)?;\n    \n    let denominator = (reserve_in as u128)\n        .checked_mul(fee_denominator as u128)\n        .ok_or(SwapError::Overflow)?\n        .checked_add(amount_in_with_fee)\n        .ok_or(SwapError::Overflow)?;\n    \n    let amount_out = numerator\n        .checked_div(denominator)\n        .ok_or(SwapError::DivisionByZero)? as u64;\n    \n    Ok(amount_out)\n}",
    "output": "SAFE\nV8 - Integer Overflow - MITIGATED\nThe AMM calculation uses u128 intermediates and checked arithmetic throughout. Input validation prevents division by zero. Each multiplication and addition is checked, with early return on any overflow. This pattern safely handles large swap amounts.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "pub fn process_cast_vote(\n    program_id: &Pubkey,\n    accounts: &[AccountInfo],\n    voter_weight: u64,\n) -> ProgramResult {\n    let account_info_iter = &mut accounts.iter();\n    let proposal_info = next_account_info(account_info_iter)?;\n    let voter_record_info = next_account_info(account_info_iter)?;\n\n    let mut proposal = Proposal::unpack(&proposal_info.data.borrow())?;\n    let mut voter_record = VoterRecord::unpack(&voter_record_info.data.borrow())?;\n    \n    proposal.yes_votes = proposal.yes_votes\n        .checked_add(voter_weight)\n        .unwrap();\n    voter_record.unrelinquished_votes_count = voter_record\n        .unrelinquished_votes_count\n        .checked_add(1)\n        .unwrap();\n    \n    Proposal::pack(proposal, &mut proposal_info.data.borrow_mut())?;\n    VoterRecord::pack(voter_record, &mut voter_record_info.data.borrow_mut())?;\n    Ok(())\n}",
    "output": "SAFE\nV8 - Integer Overflow - MITIGATED\nBoth additions use checked_add().unwrap(). This matches the SPL Governance pattern where overflow is theoretically possible but practically impossible (would require more votes than total token supply). The unwrap() causes a clean panic rather than silent corruption.",
    "label": "SAFE"
  },
  {
    "instruction": "You are a Solana smart contract security analyzer. Analyze the following Rust code for arithmetic overflow/underflow vulnerabilities.",
    "input": "fn relocate_lamports(\n    source_account_info: &AccountInfo,\n    destination_account_info: &AccountInfo,\n    lamports: u64,\n) -> ProgramResult {\n    {\n        let mut source_lamports = source_account_info.try_borrow_mut_lamports()?;\n        **source_lamports = source_lamports\n            .checked_sub(lamports)\n            .ok_or(ProgramError::InsufficientFunds)?;\n    }\n    {\n        let mut destination_lamports = destination_account_info.try_borrow_mut_lamports()?;\n        **destination_lamports = destination_lamports\n            .checked_add(lamports)\n            .ok_or(ProgramError::ArithmeticOverflow)?;\n    }\n    Ok(())\n}",
    "output": "SAFE\nV8 - Integer Overflow/Underflow - MITIGATED\nBoth lamport operations use checked arithmetic. The source subtraction uses checked_sub with InsufficientFunds error. The destination addition uses checked_add with ArithmeticOverflow error. This pattern from SPL Token ensures safe lamport transfers.",
    "label": "SAFE"
  }
]
