{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_add(a, b):\n    # Vulnerable: No check before adding.\n    result = a + b\n    return result\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_subtract(balance, amount):\n    # Vulnerable: No check for underflow.\n    new_balance = balance - amount\n    return new_balance\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_multiply(items, price):\n    # Vulnerable: No check for overflow.\n    total_cost = items * price\n    return total_cost\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_update_score(score, points):\n    # Panics on overflow\n    return score + points\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_burn_tokens(supply, burn_amount):\n    # Panics on underflow\n    return supply - burn_amount\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_calc_interest(principal, rate):\n    # Panics on overflow\n    return principal * rate\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.none)\ndef vulnerable_update_balance(user, amount):\n    current_balance = App.localGet(user, Bytes(\"balance\"))\n    # Vulnerable: The '+' operation can panic\n    new_balance = current_balance + amount\n    return App.localPut(user, Bytes(\"balance\"), new_balance)\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.none)\ndef vulnerable_withdraw(user, amount):\n    current_balance = App.localGet(user, Bytes(\"balance\"))\n    # Vulnerable: The '-' operation can panic\n    new_balance = current_balance - amount\n    return App.localPut(user, Bytes(\"balance\"), new_balance)\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_get_scaled_value(val):\n    # Vulnerable: Multiplying by a constant can still overflow\n    scaled_val = val * Int(1000)\n    return scaled_val\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef vulnerable_complex(a, b, c):\n    # This can panic at the '+' or the '-' step\n    result = (a + b) - c\n    return result\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nVulnerable (Integer Overflow and Underflow (V8))<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_add(a, b):\n    # Safe: We check for overflow *before* adding.\n    return Seq(\n        Assert(a <= (Global.max_int() - b)),\n        Return(a + b)\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_subtract(balance, amount):\n    # Safe: We check for underflow *before* subtracting.\n    return Seq(\n        Assert(balance >= amount),\n        Return(balance - amount)\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_multiply(items, price):\n    # Safe: Multiplication check\n    return Seq(\n        If(Or(items == Int(0), price == Int(0)),\n            Return(Int(0))\n        ,\n            Seq(\n                Assert(items <= (Global.max_int() / price)),\n                Return(items * price)\n            )\n        )\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_update_score(score, points):\n    # Safe check\n    return Seq(\n        Assert(score <= (Global.max_int() - points)),\n        Return(score + points)\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_burn_tokens(supply, burn_amount):\n    # Safe check\n    return Seq(\n        Assert(supply >= burn_amount),\n        Return(supply - burn_amount)\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_calc_interest(principal, rate):\n    # Safe check\n    return Seq(\n        If(principal == Int(0),\n            Return(Int(0))\n        ,\n            Seq(\n                Assert(rate <= (Global.max_int() / principal)),\n                Return(principal * rate)\n            )\n        )\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.none)\ndef safe_update_balance(user, amount):\n    current_balance = App.localGet(user, Bytes(\"balance\"))\n    # Safe: Check *before* adding\n    return Seq(\n        Assert(current_balance <= (Global.max_int() - amount)),\n        App.localPut(user, Bytes(\"balance\"), current_balance + amount)\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.none)\ndef safe_withdraw(user, amount):\n    current_balance = App.localGet(user, Bytes(\"balance\"))\n    # Safe: Check *before* subtracting\n    return Seq(\n        Assert(current_balance >= amount),\n        App.localPut(user, Bytes(\"balance\"), current_balance - amount)\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_get_scaled_value(val):\n    # Safe: Check for overflow\n    return Seq(\n        Assert(val <= (Global.max_int() / Int(1000))),\n        Return(val * Int(1000))\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
{"text": "<|begin_of_text|><|start_header_id|>system<|end_header_id|>\n\n<SYS> You are a smart contract security analyzer. You receive smart contract written in PyTeal as input and answer with the vulnerability identified if exist. </SYS><|eot_id|><|start_header_id|>user<|end_header_id|>\n\nCode Snippet:\n@Subroutine(TealType.uint64)\ndef safe_complex(a, b, c):\n    # We must check *both* steps.\n    return Seq(\n        Assert(\n            And(\n                a <= (Global.max_int() - b),\n                (a + b) >= c\n            )\n        ),\n        Return((a + b) - c)\n    )\n<|eot_id|><|start_header_id|>assistant<|end_header_id|>\n\nSafe<|eot_id|>"}
